  ~/Projects/master-thesis/dap     new-native    1  1  clear                                                                                            11174  22:52:13  


















































  ~/Projects/master-thesis/dap     new-native    1  1  sbt clean compile                                                                                11174  22:52:14  
[info] welcome to sbt 1.10.11 (Oracle Corporation Java 21.0.2)
[info] loading settings for project dap-build-build-build from metals.sbt...
[info] loading project definition from /Users/lucatassi/Projects/master-thesis/dap/project/project/project
[info] loading settings for project dap-build-build from metals.sbt...
[info] loading project definition from /Users/lucatassi/Projects/master-thesis/dap/project/project
[success] Generated .bloop/dap-build-build.json
[success] Total time: 1 s, completed May 1, 2025, 10:52:20 PM
[info] loading settings for project dap-build from metals.sbt, plugins.sbt...
[info] loading project definition from /Users/lucatassi/Projects/master-thesis/dap/project
[success] Generated .bloop/dap-build.json
[success] Total time: 0 s, completed May 1, 2025, 10:52:21 PM
[info] loading settings for project dap from build.sbt...
[info] set current project to dap (in build file:/Users/lucatassi/Projects/master-thesis/dap/)
[info] Executing in batch mode. For better performance use sbt's shell
[success] Total time: 0 s, completed May 1, 2025, 10:52:23 PM
[info] compiling 28 Scala sources to /Users/lucatassi/Projects/master-thesis/dap/dap/jvm/target/scala-3.6.4/classes ...
[info] compiling 32 Scala sources to /Users/lucatassi/Projects/master-thesis/dap/dap/native/target/scala-3.6.4/classes ...
[info] compiling 30 Scala sources to /Users/lucatassi/Projects/master-thesis/dap/dap/js/target/scala-3.6.4/classes ...
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:26:52 
[warn] 26 |    socket.on("connect")(_ => connPromise.trySuccess(createConnection(socket)))
[warn]    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Boolean. Add `: Unit` to discard silently.
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:28:28 
[warn] 28 |      connPromise.tryFailure(Exception(err.toString))
[warn]    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |      unused value of type Boolean
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:46:62 
[warn] 46 |    server.on("listening")(_ => connListenerPromise.trySuccess(listener))
[warn]    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Boolean. Add `: Unit` to discard silently.
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:48:36 
[warn] 48 |      connListenerPromise.tryFailure(new Exception(err.toString))
[warn]    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |      unused value of type Boolean
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/utils/Platform.scala:10:24 
[warn] 10 |    setTimeout(duration)(p.success(()))
[warn]    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |    unused value of type scala.scalajs.js.timers.SetTimeoutHandle
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:42:14 
[warn] 42 |    ): Unit = simulation.launch(port)(s => updateFn(s))
[warn]    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type scala.concurrent.Future[Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:44:87 
[warn] 44 |    override def stop[Token](simulation: DASPSimulation[Token]): Unit = simulation.stop()
[warn]    |                                                                        ^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[simulation.SimulationError, Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:42:14 
[warn] 42 |    ): Unit = simulation.launch(port)(s => updateFn(s))
[warn]    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type scala.concurrent.Future[Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:44:87 
[warn] 44 |    override def stop[Token](simulation: DASPSimulation[Token]): Unit = simulation.stop()
[warn]    |                                                                        ^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[simulation.SimulationError, Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:46:25 
[warn] 46 |      .in(configuration)(inChannel.push)
[warn]    |                         ^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[it.unibo.dap.utils.Channel.Error, Unit]. Add `: Unit` to discard silently.
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:53:21 
[warn] 53 |      inChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:54:22 
[warn] 54 |      outChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:46:25 
[warn] 46 |      .in(configuration)(inChannel.push)
[warn]    |                         ^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[it.unibo.dap.utils.Channel.Error, Unit]. Add `: Unit` to discard silently.
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:53:21 
[warn] 53 |      inChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:54:22 
[warn] 54 |      outChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:42:14 
[warn] 42 |    ): Unit = simulation.launch(port)(s => updateFn(s))
[warn]    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type scala.concurrent.Future[Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:44:87 
[warn] 44 |    override def stop[Token](simulation: DASPSimulation[Token]): Unit = simulation.stop()
[warn]    |                                                                        ^^^^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[simulation.SimulationError, Unit]. Add `: Unit` to discard silently.
[warn] -- [E175] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:46:25 
[warn] 46 |      .in(configuration)(inChannel.push)
[warn]    |                         ^^^^^^^^^^^^^^
[warn]    |discarded non-Unit value of type Either[it.unibo.dap.utils.Channel.Error, Unit]. Add `: Unit` to discard silently.
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:53:21 
[warn] 53 |      inChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[warn] -- [E176] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala:54:22 
[warn] 54 |      outChannel.close()
[warn]    |      ^^^^^^^^^^^^^^^^^^
[warn]    |     unused value of type Either[it.unibo.dap.utils.Channel.Error, Unit]
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/api/JSProductAPI.scala
[info] package it.unibo.dap.api {
[info]   import scala.scalajs.js.JSConverters.{JSRichIterableOnce, JSRichOption}
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala
[info]   import scala.scalajs.concurrent.JSExecutionContext
[info]   import scala.concurrent.ExecutionContext
[info] package it.unibo.dap.boundary.sockets {
[info]   import java.net.{ServerSocket, Socket}
[info]   import scala.scalajs.js.annotation.{JSExportAll, JSExportTopLevel}
[info]   import scala.scalajs.js
[info]   import scala.collection.Iterator.continually
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]   import scala.util.Try
[info]     final lazy module val JSProductAPI: it.unibo.dap.api.JSProductAPI =
[info]     new it.unibo.dap.api.JSProductAPI()
[info]   import it.unibo.dap.controller.Serializable
[info]   import it.unibo.dap.controller.Serializable.{deserialize, serialize}
[info]   @SourceFile("dap/js/src/main/scala/it/unibo/dap/api/JSProductAPI.scala")
[info]   @SourceFile(
[info]     
[info]       "dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala"
[info]       
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketNetworking[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T],
[info]     x$1: scala.concurrent.ExecutionContext) extends Object,
[info]     it.unibo.dap.boundary.sockets.Networking[SocketNetworking.this.T,
[info]       SocketNetworking.this.T],
[info]   it.unibo.dap.boundary.sockets.InetTypes {
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     private[this] given val x$1: scala.concurrent.ExecutionContext
[info]     override def out(
[info]       endpoint:
[info]     final module class JSProductAPI() extends Object(), it.unibo.dap.api.
[info]     ProductApi { this: it.unibo.dap.api.JSProductAPI.type =>
[info]         Tuple2[SocketNetworking.this.Address, SocketNetworking.this.Port]
[info]     ): scala.concurrent.Future[SocketNetworking.this.Connection] =
[info]     private def writeReplace(): AnyRef =
[info]       scala.concurrent.Future.fromTry[SocketNetworking.this.Connection](
[info]         scala.util.Try.apply[java.net.Socket](
[info]           new java.net.Socket(endpoint._1, endpoint._2)).map[
[info]           SocketNetworking.this.Connection]((socket: java.net.Socket) =>
[info]           {
[info]             val conn: SocketNetworking.this.Connection =
[info]               {
[info]                 final class $anon() extends Object(), SocketNetworking.this.
[info]                   Connection {
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.JSProductAPI.type])
[info]                   override def send(msg: SocketNetworking.this.T):
[info]                     scala.concurrent.Future[Unit] =
[info]                     scala.concurrent.Future.fromTry[Unit](
[info]                       scala.util.Try.apply[Unit](
[info]                         socket.getOutputStream().write(
[info]                           it.unibo.dap.controller.Serializable.serialize[T](msg)
[info]                             (
[info]                             it.unibo.dap.boundary.sockets.SocketNetworking.this.
[info]                               evidence$1
[info]                           )
[info]     override val interface: it.unibo.dap.api.JSProductAPI.ProductInterface =
[info]       it.unibo.dap.api.JSProductAPI.JSInterface
[info]                         )
[info]                       )
[info]                     )
[info]                   override def isOpen: Boolean = socket.isClosed().unary_!
[info]     @JSExportAll @JSExportTopLevel("DAPApi") final lazy module val JSInterface:
[info]       it.unibo.dap.api.JSProductAPI.JSInterface =
[info]       new it.unibo.dap.api.JSProductAPI.JSInterface()
[info]     @JSExportAll @JSExportTopLevel("DAPApi") final module class JSInterface()
[info]                   override def close(): Unit = socket.close()
[info]                 }
[info]        extends Object(), it.unibo.dap.api.JSProductAPI.ProductInterface, 
[info]       it.unibo.dap.api.JSProductAPI.ADTs {
[info]       this: it.unibo.dap.api.JSProductAPI.JSInterface.type =>
[info]                 new $anon():SocketNetworking.this.Connection
[info]               }
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]             conn:SocketNetworking.this.Connection
[info]           }
[info]         )
[info]           classOf[it.unibo.dap.api.JSProductAPI.JSInterface.type])
[info]       override final lazy given val given_ExecutionContext:
[info]       )
[info]     override def in(port: SocketNetworking.this.Port)(onReceive: T => Unit):
[info]         scala.concurrent.ExecutionContext =
[info]         scala.scalajs.concurrent.JSExecutionContext.queue
[info]       scala.concurrent.Future[SocketNetworking.this.ConnectionListener] =
[info]       override type IString = String
[info]       override final lazy given val given_Iso_IString_String:
[info]         it.unibo.dap.api.JSProductAPI.JSInterface.Iso[
[info]       scala.concurrent.Future.fromTry[SocketNetworking.this.ConnectionListener](
[info]         scala.util.Try.apply[java.net.ServerSocket](
[info]           new java.net.ServerSocket(port)).map[
[info]           SocketNetworking.this.ConnectionListener]((
[info]           socketServer: java.net.ServerSocket) =>
[info]           {
[info]             val connListener: SocketNetworking.this.ConnectionListener =
[info]               {
[info]           it.unibo.dap.api.JSProductAPI.JSInterface.IString, String]
[info]                 final class $anon() extends Object(), SocketNetworking.this.
[info]        =
[info]         {
[info]           val toFn$proxy1: String => String = (x: String) => identity[String](x)
[info]                   ConnectionListener {
[info]           val fromFn$proxy1: String => String = (x: String) =>
[info]             identity[String](x)
[info]           {
[info]             final class $anon() extends Object(), it.unibo.dap.utils.Iso[
[info]               String, String] {
[info]               def to(a: String): String = toFn$proxy1.apply(a)
[info]                   private[this] val acceptLoop: scala.concurrent.Future[Unit] =
[info]                     scala.concurrent.Future.apply[Unit](
[info]                       scala.collection.Iterator.continually[
[info]               def from(b: String): String = fromFn$proxy1.apply(b)
[info]             }
[info]                         scala.util.Try[java.net.Socket]](
[info]                         scala.util.Try.apply[java.net.Socket](
[info]                           socketServer.accept())
[info]                       ).filter((_$1: scala.util.Try[java.net.Socket]) =>
[info]                         _$1.isSuccess).foreach[scala.concurrent.Future[Unit]]((
[info]                         s: scala.util.Try[java.net.Socket]) => this.serve(s.get)
[info]             new $anon():it.unibo.dap.utils.Iso[String, String]
[info]           }:it.unibo.dap.utils.Iso[String, String]
[info]                         )
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1)
[info]         }
[info]       override type IOption[T >: Nothing <: Any] = scala.scalajs.js.UndefOr[T]
[info]                   private[this] def serve(client: java.net.Socket):
[info]       override final given def given_Iso_IOption_Option[T >: Nothing <: Any]:
[info]         it.unibo.dap.api.JSProductAPI.JSInterface.Iso[
[info]                     scala.concurrent.Future[Unit] =
[info]           it.unibo.dap.api.JSProductAPI.JSInterface.IOption[T], Option[T]]
[info]        =
[info]         {
[info]           val toFn$proxy2: T | Unit => Option[T] = (_$1: T | Unit) =>
[info]                     scala.concurrent.Future.apply[Unit](
[info]                       {
[info]                         val in: java.io.InputStream = client.getInputStream()
[info]                         val buffer: Array[Byte] =
[info]                           new Array[Byte](_length = 2048)
[info]                         scala.collection.Iterator.continually[Int](
[info]                           in.read(buffer)).takeWhile((_$2: Int) => _$2.>(0)).
[info]                           foreach[Unit]((readBytes: Int) =>
[info]                           {
[info]                             val message: T =
[info]                               it.unibo.dap.controller.Serializable.deserialize[T
[info]             scala.scalajs.js.internal.UnitOps.unitOrOps[T](_$1).toOption
[info]                                 ](byteArrayOps(buffer).take(readBytes))(
[info]                                 it.unibo.dap.boundary.sockets.SocketNetworking.
[info]                                   this.evidence$1
[info]           val fromFn$proxy2: Option[T] => T | Unit = (_$2: Option[T]) =>
[info]                               )
[info]                             onReceive.apply(message)
[info]                           }
[info]                         )
[info]             scala.scalajs.js.JSConverters.JSRichOption[T](_$2).orUndefined
[info]           {
[info]             final class $anon() extends Object(), it.unibo.dap.utils.Iso[
[info]                         client.close()
[info]               T | Unit, Option[T]] {
[info]                       }
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1).
[info]               def to(a: T | Unit): Option[T] = toFn$proxy2.apply(a)
[info]               def from(b: Option[T]): T | Unit = fromFn$proxy2.apply(b)
[info]                       recover[Unit]((x$1: Throwable) =>
[info]                       x$1 match 
[info]                         {
[info]                           case _:Exception =>
[info]                             if client.isClosed().unary_! then client.close()
[info]                                else ()
[info]                         }
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1)
[info]                   override def isOpen: Boolean = socketServer.isClosed()
[info]                   override def close(): Unit = socketServer.close()
[info]                 }
[info]                 new $anon():SocketNetworking.this.ConnectionListener
[info]               }
[info]             connListener:SocketNetworking.this.ConnectionListener
[info]           }
[info]         )
[info]             }
[info]             new $anon():it.unibo.dap.utils.Iso[T | Unit, Option[T]]
[info]           }:it.unibo.dap.utils.Iso[T | Unit, Option[T]]
[info]         }
[info]       override type ISeq[T >: Nothing <: Any] = scala.scalajs.js.Array[T]
[info]       override final given def iseqc[T >: Nothing <: Any]:
[info]       )
[info]   }
[info] }
[info]         Conversion[it.unibo.dap.api.JSProductAPI.JSInterface.ISeq[T], Seq[T]] =
[info]         (_$3: scala.scalajs.js.Array[T]) =>
[info]         scala.scalajs.js.Any.jsArrayOps[T](_$3).toSeq
[info]       override final given def iseqcc[T >: Nothing <: Any]:
[info]         Conversion[Seq[T], it.unibo.dap.api.JSProductAPI.JSInterface.ISeq[T]] =
[info]         (_$4: Seq[T]) =>
[info]         scala.scalajs.js.JSConverters.JSRichIterableOnce[T](_$4).toJSArray
[info]       override type IFunction1[T1 >: Nothing <: Any, R >: Nothing <: Any] =
[info]         scala.scalajs.js.Function1[T1, R]
[info]       override final given def f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]:
[info]         Conversion[it.unibo.dap.api.JSProductAPI.JSInterface.IFunction1[T1, R],
[info]           T1 => R]
[info]        = (_$5: scala.scalajs.js.Function1[T1, R]) => (arg1: T1) =>
[info]         _$5.apply(arg1)
[info]       override type IFunction2[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any] = scala.scalajs.js.Function2[T1, T2, R]
[info]       override final given def f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]:
[info]         Conversion[
[info]           it.unibo.dap.api.JSProductAPI.JSInterface.IFunction2[T1, T2, R],
[info]           (T1, T2) => R]
[info]        = (_$6: scala.scalajs.js.Function2[T1, T2, R]) => (arg1: T1, arg2: T2)
[info]          => _$6.apply(arg1, arg2)
[info]       final def $js$exported$prop$given_ExecutionContext: Any =
[info]         this.given_ExecutionContext
[info]       final def $js$exported$prop$given_Iso_IString_String: Any =
[info]         this.given_Iso_IString_String
[info]       final def $js$exported$prop$given_Iso_IOption_Option[T]: Any =
[info]         this.given_Iso_IOption_Option[T]
[info]       final def $js$exported$prop$iseqc[T]: Any = this.iseqc[T]
[info]       final def $js$exported$prop$iseqcc[T]: Any = this.iseqcc[T]
[info]       final def $js$exported$prop$f1c[T1, R]: Any = this.f1c[T1, R]
[info]       final def $js$exported$prop$f2c[T1, T2, R]: Any = this.f2c[T1, T2, R]
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import java.net.{ServerSocket, Socket}
[info]   import scala.collection.Iterator.continually
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import scala.util.Try
[info]   import it.unibo.dap.controller.Serializable
[info]   import it.unibo.dap.controller.Serializable.{deserialize, serialize}
[info]   @SourceFile(
[info]     
[info]       "dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketNetworking[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T],
[info]     x$1: scala.concurrent.ExecutionContext) extends Object,
[info]     it.unibo.dap.boundary.sockets.Networking[SocketNetworking.this.T,
[info]       SocketNetworking.this.T],
[info]   it.unibo.dap.boundary.sockets.InetTypes {
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     private[this] given val x$1: scala.concurrent.ExecutionContext
[info]     override def out(
[info]       endpoint:
[info]         Tuple2[SocketNetworking.this.Address, SocketNetworking.this.Port]
[info]     ): scala.concurrent.Future[SocketNetworking.this.Connection] =
[info]       scala.concurrent.Future.fromTry[SocketNetworking.this.Connection](
[info]         scala.util.Try.apply[java.net.Socket](
[info]           new java.net.Socket(endpoint._1, endpoint._2)).map[
[info]           SocketNetworking.this.Connection]((socket: java.net.Socket) =>
[info]           {
[info]             val conn: SocketNetworking.this.Connection =
[info]               {
[info]                 final class $anon() extends Object(), SocketNetworking.this.
[info]                   Connection {
[info]                   override def send(msg: SocketNetworking.this.T):
[info]                     scala.concurrent.Future[Unit] =
[info]                     scala.concurrent.Future.fromTry[Unit](
[info]                       scala.util.Try.apply[Unit](
[info]                         socket.getOutputStream().write(
[info]                           it.unibo.dap.controller.Serializable.serialize[T](msg)
[info]                             (
[info]                             it.unibo.dap.boundary.sockets.SocketNetworking.this.
[info]                               evidence$1
[info]                           )
[info]                         )
[info]                       )
[info]                     )
[info]                   override def isOpen: Boolean = socket.isClosed().unary_!
[info]                   override def close(): Unit = socket.close()
[info]                 }
[info]                 new $anon():SocketNetworking.this.Connection
[info]               }
[info]             conn:SocketNetworking.this.Connection
[info]           }
[info]         )
[info]       )
[info]     override def in(port: SocketNetworking.this.Port)(onReceive: T => Unit):
[info]       scala.concurrent.Future[SocketNetworking.this.ConnectionListener] =
[info]       scala.concurrent.Future.fromTry[SocketNetworking.this.ConnectionListener](
[info]         scala.util.Try.apply[java.net.ServerSocket](
[info]           new java.net.ServerSocket(port)).map[
[info]           SocketNetworking.this.ConnectionListener]((
[info]           socketServer: java.net.ServerSocket) =>
[info]           {
[info]             val connListener: SocketNetworking.this.ConnectionListener =
[info]               {
[info]                 final class $anon() extends Object(), SocketNetworking.this.
[info]                   ConnectionListener {
[info]                   private[this] val acceptLoop: scala.concurrent.Future[Unit] =
[info]                     scala.concurrent.Future.apply[Unit](
[info]                       scala.collection.Iterator.continually[
[info]                         scala.util.Try[java.net.Socket]](
[info]                         scala.util.Try.apply[java.net.Socket](
[info]                           socketServer.accept())
[info]                       ).filter((_$1: scala.util.Try[java.net.Socket]) =>
[info]                         _$1.isSuccess).foreach[scala.concurrent.Future[Unit]]((
[info]                         s: scala.util.Try[java.net.Socket]) => this.serve(s.get)
[info]                         )
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1)
[info]                   private[this] def serve(client: java.net.Socket):
[info]                     scala.concurrent.Future[Unit] =
[info]                     scala.concurrent.Future.apply[Unit](
[info]                       {
[info]                         val in: java.io.InputStream = client.getInputStream()
[info]                         val buffer: Array[Byte] =
[info]                           new Array[Byte](_length = 2048)
[info]                         scala.collection.Iterator.continually[Int](
[info]                           in.read(buffer)).takeWhile((_$2: Int) => _$2.>(0)).
[info]                           foreach[Unit]((readBytes: Int) =>
[info]                           {
[info]                             val message: T =
[info]                               it.unibo.dap.controller.Serializable.deserialize[T
[info]                                 ](byteArrayOps(buffer).take(readBytes))(
[info]                                 it.unibo.dap.boundary.sockets.SocketNetworking.
[info]                                   this.evidence$1
[info]                               )
[info]                             onReceive.apply(message)
[info]                           }
[info]                         )
[info]                         client.close()
[info]                       }
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1).
[info]                       recover[Unit]((x$1: Throwable) =>
[info]                       x$1 match 
[info]                         {
[info]                           case _:Exception =>
[info]                             if client.isClosed().unary_! then client.close()
[info]                                else ()
[info]                         }
[info]                     )(it.unibo.dap.boundary.sockets.SocketNetworking.this.x$1)
[info]                   override def isOpen: Boolean = socketServer.isClosed()
[info]                   override def close(): Unit = socketServer.close()
[info]                 }
[info]                 new $anon():SocketNetworking.this.ConnectionListener
[info]               }
[info]             connListener:SocketNetworking.this.ConnectionListener
[info]           }
[info]         )
[info]       )
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/utils/Platform.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{blocking, ExecutionContext, Future}
[info]   import scala.concurrent.duration.FiniteDuration
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Platform: it.unibo.dap.utils.Platform =
[info]     new it.unibo.dap.utils.Platform()
[info]   @SourceFile("dap/jvm-native/src/main/scala/it/unibo/dap/utils/Platform.scala")
[info]      @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Platform() extends Object() {
[info]     this: it.unibo.dap.utils.Platform.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Platform.type])
[info]     def asyncOps: it.unibo.dap.utils.AsyncOperations =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.utils.AsyncOperations
[info]            {
[info]           final lazy given val given_ExecutionContext:
[info]             scala.concurrent.ExecutionContext =
[info]             scala.concurrent.ExecutionContext.global
[info]           override def sleep(duration: scala.concurrent.duration.FiniteDuration)
[info]             : scala.concurrent.Future[Unit] =
[info]             scala.concurrent.Future.apply[Unit](
[info]               scala.concurrent.blocking[Unit](Thread.sleep(duration.toMillis)))(
[info]               this.given_ExecutionContext)
[info]         }
[info]         new $anon():it.unibo.dap.utils.AsyncOperations
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/utils/Platform.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{blocking, ExecutionContext, Future}
[info]   import scala.concurrent.duration.FiniteDuration
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Platform: it.unibo.dap.utils.Platform =
[info]     new it.unibo.dap.utils.Platform()
[info]   @SourceFile("dap/jvm-native/src/main/scala/it/unibo/dap/utils/Platform.scala")
[info]      @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Platform() extends Object() {
[info]     this: it.unibo.dap.utils.Platform.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Platform.type])
[info]     def asyncOps: it.unibo.dap.utils.AsyncOperations =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.utils.AsyncOperations
[info]            {
[info]           final lazy given val given_ExecutionContext:
[info]             scala.concurrent.ExecutionContext =
[info]             scala.concurrent.ExecutionContext.global
[info]           override def sleep(duration: scala.concurrent.duration.FiniteDuration)
[info]             : scala.concurrent.Future[Unit] =
[info]             scala.concurrent.Future.apply[Unit](
[info]               scala.concurrent.blocking[Unit](Thread.sleep(duration.toMillis)))(
[info]               this.given_ExecutionContext)
[info]         }
[info]         new $anon():it.unibo.dap.utils.AsyncOperations
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/JSSocketsFacade.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.scalajs.js.typedarray.Uint8Array
[info]   import scala.scalajs.js.annotation.*
[info]   import scala.scalajs.js
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @JSImport("net", scala.scalajs.js.annotation.JSImport.Namespace) @native
[info]     final lazy module val Net: it.unibo.dap.boundary.sockets.Net =
[info]     new it.unibo.dap.boundary.sockets.Net()
[info]   @JSType
[info]     @SourceFile(
[info]       
[info]         "dap/js/src/main/scala/it/unibo/dap/boundary/sockets/JSSocketsFacade.scala"
[info]         
[info]     )
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @JSImport("net", scala.scalajs.js.annotation.JSImport.Namespace) @native
[info]     final module class Net() extends scala.scalajs.js.Object() {
[info]     this: it.unibo.dap.boundary.sockets.Net.type =>
[info]     def connect(port: Int, host: String): it.unibo.dap.boundary.sockets.Socket
[info]        = scala.scalajs.js.package.native
[info]     def createServer(
[info]       cb: scala.scalajs.js.Function1[it.unibo.dap.boundary.sockets.Socket, Unit]
[info]       ): it.unibo.dap.boundary.sockets.Server = scala.scalajs.js.package.native
[info]   }
[info]   @JSType
[info]     @SourceFile(
[info]       
[info]         "dap/js/src/main/scala/it/unibo/dap/boundary/sockets/JSSocketsFacade.scala"
[info]         
[info]     )
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @native trait Server() extends scala.scalajs.js.Object {
[info]     def listen(port: Int): Unit = scala.scalajs.js.package.native
[info]     def close(): Unit = scala.scalajs.js.package.native
[info]     def on(event: String)(
[info]       callback: scala.scalajs.js.Function1[scala.scalajs.js.Any, Unit]): Unit =
[info]       scala.scalajs.js.package.native
[info]   }
[info]   @JSType
[info]     @SourceFile(
[info]       
[info]         "dap/js/src/main/scala/it/unibo/dap/boundary/sockets/JSSocketsFacade.scala"
[info]         
[info]     )
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @native trait Socket() extends scala.scalajs.js.Object {
[info]     def write(data: scala.scalajs.js.typedarray.Uint8Array)(
[info]       callback: scala.scalajs.js.Function1[Error | Null, Any]): Unit =
[info]       scala.scalajs.js.package.native
[info]     def on(event: String)(
[info]       callback: scala.scalajs.js.Function1[scala.scalajs.js.Any, Unit]): Unit =
[info]       scala.scalajs.js.package.native
[info]     def destroy(): Unit = scala.scalajs.js.package.native
[info]     def destroyed: Boolean = scala.scalajs.js.package.native
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/native/src/main/scala/it/unibo/dap/api/CArraySeq.scala
[info] package it.unibo.dap.api {
[info]   import scala.scalanative.unsafe.*
[info]   @SourceFile("dap/native/src/main/scala/it/unibo/dap/api/CArraySeq.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     case class CArraySeq[T >: Nothing <: Any](
[info]     ptr: scala.scalanative.unsafe.Ptr[T], length: Int)(using 
[info]     evidence$1: scala.scalanative.unsafe.Tag[T]) extends Object(),
[info]     IndexedSeq[CArraySeq.this.T], _root_.scala.Product, _root_.scala.
[info]     Serializable {
[info]     override def productArity: Int = 2
[info]     override def productPrefix: String = "CArraySeq"
[info]     override def productElement(n: Int): Any =
[info]       n match 
[info]         {
[info]           case 0 => this._1
[info]           case 1 => this._2
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     override def productElementName(n: Int): String =
[info]       n match 
[info]         {
[info]           case 0 => "ptr"
[info]           case 1 => "length"
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     T
[info]     val ptr: scala.scalanative.unsafe.Ptr[T]
[info]     override val length: Int
[info]     private[this] given val evidence$1: scala.scalanative.unsafe.Tag[T]
[info]     override def apply(i: Int): CArraySeq.this.T =
[info]       {
[info]         require(0.<=(i).&&(i.<(CArraySeq.this.length)),
[info]           _root_.scala.StringContext.apply(
[info]             ["Index "," out of bounds for length ","" : String]*).s(
[info]             [i,CArraySeq.this.length : Any]*)
[info]         )
[info]         CArraySeq.this.ptr.apply(i)(CArraySeq.this.evidence$1)
[info]       }
[info]     def copy[T](ptr: scala.scalanative.unsafe.Ptr[T], length: Int)(using 
[info]       evidence$1: scala.scalanative.unsafe.Tag[T]):
[info]       it.unibo.dap.api.CArraySeq[T] =
[info]       new it.unibo.dap.api.CArraySeq[T](ptr, length)(using evidence$1)
[info]     def copy$default$1[T]: scala.scalanative.unsafe.Ptr[T] = CArraySeq.this.ptr
[info]     def copy$default$2[T]: Int @uncheckedVariance = CArraySeq.this.length
[info]     def _1: scala.scalanative.unsafe.Ptr[T] = this.ptr
[info]     def _2: Int = this.length
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CArraySeq: it.unibo.dap.api.CArraySeq =
[info]     new it.unibo.dap.api.CArraySeq()
[info]   @SourceFile("dap/native/src/main/scala/it/unibo/dap/api/CArraySeq.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CArraySeq() extends AnyRef() {
[info]     this: it.unibo.dap.api.CArraySeq.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.CArraySeq.type])
[info]     def apply[T](ptr: scala.scalanative.unsafe.Ptr[T], length: Int)(using 
[info]       evidence$1: scala.scalanative.unsafe.Tag[T]):
[info]       it.unibo.dap.api.CArraySeq[T] =
[info]       new it.unibo.dap.api.CArraySeq[T](ptr, length)(using evidence$1)
[info]     def unapply[T](x$1: it.unibo.dap.api.CArraySeq[T]):
[info]       it.unibo.dap.api.CArraySeq[T] = x$1
[info]     override def toString: String = "CArraySeq"
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/native/src/main/scala/it/unibo/dap/api/CTypes.scala
[info] package it.unibo.dap.api {
[info]   import scala.scalanative.unsafe.{Tag, *}
[info]   import scala.scalanative.libc.stddef.size_t
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTypes$package: it.unibo.dap.api.CTypes$package =
[info]     new it.unibo.dap.api.CTypes$package()
[info]   @SourceFile("dap/native/src/main/scala/it/unibo/dap/api/CTypes.scala") final
[info]     module class CTypes$package() extends Object() {
[info]     this: it.unibo.dap.api.CTypes$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.CTypes$package.type])
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type CSeq[T >: Nothing <: Any] =
[info]       scala.scalanative.unsafe.CStruct2[scala.scalanative.unsafe.Ptr[T],
[info]         scala.scalanative.libc.stddef.size_t]
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type CToken = scala.scalanative.unsafe.Ptr[Byte]
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       final lazy given val ctokenTag:
[info]       scala.scalanative.unsafe.Tag[it.unibo.dap.api.CToken] =
[info]       scala.scalanative.unsafe.Tag.Ptr.apply[Byte](
[info]         scala.scalanative.unsafe.Tag.Byte)
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       final lazy given val given_Tag_Ptr:
[info]       scala.scalanative.unsafe.Tag[
[info]         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken]]
[info]      =
[info]       scala.scalanative.unsafe.Tag.Ptr.apply[scala.scalanative.unsafe.Ptr[Byte]]
[info]         (it.unibo.dap.api.ctokenTag)
[info]     extension [T >: Nothing <: Any](a: it.unibo.dap.api.CSeq[T])
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def elements
[info]     : scala.scalanative.unsafe.Ptr[T] =
[info]       a._1(
[info]         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]           scala.scalanative.unsafe.Ptr[T], scala.scalanative.unsigned.USize](
[info]           scala.scalanative.unsafe.Tag.materializePtrClassNotGivenClassTag[T](
[info]             scala.util.NotGiven.value),
[info]           scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]       )
[info]     extension [T >: Nothing <: Any](a: it.unibo.dap.api.CSeq[T])
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def size
[info]     : scala.scalanative.libc.stddef.size_t =
[info]       a._2(
[info]         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]           scala.scalanative.unsafe.Ptr[T], scala.scalanative.unsigned.USize](
[info]           scala.scalanative.unsafe.Tag.materializePtrClassNotGivenClassTag[T](
[info]             scala.util.NotGiven.value),
[info]           scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]       )
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type CRule =
[info]       scala.scalanative.unsafe.CStruct4[
[info]         scala.scalanative.unsafe.Ptr[
[info]           it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]       Double,
[info]         scala.scalanative.unsafe.Ptr[
[info]           it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]         it.unibo.dap.api.CToken]
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala
[info] package it.unibo.dap.boundary.sockets {
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type CNeighbor =
[info]       scala.scalanative.unsafe.CStruct1[scala.scalanative.unsafe.CString]
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type CState =
[info]       scala.scalanative.unsafe.CStruct2[
[info]         scala.scalanative.unsafe.Ptr[
[info]           it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]         it.unibo.dap.api.CToken]
[info]   }
[info] }
[info]   import scala.scalajs.js.typedarray.Uint8Array
[info]   import scala.concurrent.{ExecutionContext, Future, Promise}
[info]   import it.unibo.dap.controller.Serializable
[info]   import it.unibo.dap.controller.Serializable.{deserialize, serialize}
[info]   @SourceFile(
[info]     "dap/js/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala"
[info]     ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketNetworking[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T],
[info]     x$1: scala.concurrent.ExecutionContext) extends Object,
[info]     it.unibo.dap.boundary.sockets.Networking[SocketNetworking.this.T,
[info]       SocketNetworking.this.T],
[info]   it.unibo.dap.boundary.sockets.InetTypes {
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     private[this] given val x$1: scala.concurrent.ExecutionContext
[info]     override def out(endpoint: SocketNetworking.this.Endpoint):
[info]       scala.concurrent.Future[SocketNetworking.this.Connection] =
[info]       {
[info]         def createConnection(socket: it.unibo.dap.boundary.sockets.Socket):
[info]           SocketNetworking.this.Connection =
[info]           {
[info]             final class $anon() extends Object(), SocketNetworking.this.
[info]               Connection {
[info]               override def send(msg: SocketNetworking.this.T):
[info]                 scala.concurrent.Future[Unit] =
[info]                 if this.isOpen.unary_! then
[info]                   scala.concurrent.Future.failed[Nothing](
[info]                     new IllegalStateException("Connection is closed!"))
[info]                  else 
[info]                   {
[info]                     val promise: scala.concurrent.Promise[Unit] =
[info]                       scala.concurrent.Promise.apply[Unit]()
[info]                     val bytes: Array[Byte] =
[info]                       it.unibo.dap.controller.Serializable.serialize[T](msg)(
[info]                         it.unibo.dap.boundary.sockets.SocketNetworking.this.
[info]                           evidence$1
[info]                       )
[info]                     val data: scala.scalajs.js.typedarray.Uint8Array =
[info]                       new scala.scalajs.js.typedarray.Uint8Array(bytes.length)
[info]                     byteArrayOps(bytes).indices.foreach[Unit]((i: Int) =>
[info]                       data.update(i, Byte.byte2short(bytes.apply(i))))
[info]                     socket.write(data)((err: Error | Null) =>
[info]                       if err.!=(null) then
[info]                         promise.tryFailure(new Exception(err)) else 
[info]                         promise.trySuccess(())
[info]                     )
[info]                     promise.future:scala.concurrent.Future[Unit]
[info]                   }
[info]               override def isOpen: Boolean = socket.destroyed.unary_!
[info]               override def close(): Unit = socket.destroy()
[info]             }
[info]             new $anon():SocketNetworking.this.Connection
[info]           }
[info]         val connPromise:
[info]           scala.concurrent.Promise[SocketNetworking.this.Connection] =
[info]           scala.concurrent.Promise.apply[SocketNetworking.this.Connection]()
[info]         val socket: it.unibo.dap.boundary.sockets.Socket =
[info]           it.unibo.dap.boundary.sockets.Net.connect(endpoint._2, endpoint._1)
[info]         socket.on("connect")((_$1: scala.scalajs.js.Any) =>
[info]           {
[info]             connPromise.trySuccess(createConnection(socket))
[info]             ()
[info]           }
[info]         )
[info]         socket.on("error")((err: scala.scalajs.js.Any) =>
[info]           {
[info]             connPromise.tryFailure(new Exception(err.toString()))
[info]             socket.destroy()
[info]           }
[info]         )
[info]         connPromise.future:
[info]           scala.concurrent.Future[SocketNetworking.this.Connection]
[info]       }
[info]     override def in(port: SocketNetworking.this.Port)(onReceive: T => Unit):
[info]       scala.concurrent.Future[SocketNetworking.this.ConnectionListener] =
[info]       {
[info]         val connListenerPromise:
[info]           scala.concurrent.Promise[SocketNetworking.this.ConnectionListener] =
[info]           scala.concurrent.Promise.apply[
[info]             SocketNetworking.this.ConnectionListener]()
[info]         def react(data: scala.scalajs.js.typedarray.Uint8Array): Unit =
[info]           {
[info]             val bytes: Array[Byte] = new Array[Byte](data.length)
[info]             intWrapper(0).until(data.length).foreach[Unit]((i: Int) =>
[info]               bytes.update(i, data.apply(i).toByte))
[info]             onReceive.apply(
[info]               it.unibo.dap.controller.Serializable.deserialize[T](bytes)(
[info]                 this.evidence$1)
[info]             )
[info]           }
[info]         val server: it.unibo.dap.boundary.sockets.Server =
[info]           it.unibo.dap.boundary.sockets.Net.createServer((
[info]             _$2: it.unibo.dap.boundary.sockets.Socket) =>
[info]             _$2.on("data")((data: scala.scalajs.js.Any) =>
[info]               react(data.asInstanceOf[scala.scalajs.js.typedarray.Uint8Array]))
[info]           )
[info]         val listener: SocketNetworking.this.ConnectionListener =
[info]           {
[info]             final class $anon() extends Object(), SocketNetworking.this.
[info]               ConnectionListener {
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/Api.scala
[info] package it.unibo.dap.api {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/Api.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]               @volatile private[this] var open: Boolean = true
[info]               override def isOpen: Boolean = this.open
[info]               override def close(): Unit =
[info]                 {
[info]                   this.open = false
[info]                   server.close()
[info]                 }
[info]             }
[info]             new $anon():SocketNetworking.this.ConnectionListener
[info]           }
[info]         server.on("listening")((_$3: scala.scalajs.js.Any) =>
[info]           {
[info]             connListenerPromise.trySuccess(listener)
[info]             ()
[info]           }
[info]         )
[info]         server.on("error")((err: scala.scalajs.js.Any) =>
[info]           {
[info]             connListenerPromise.tryFailure(new Exception(err.toString()))
[info]             server.close()
[info]           }
[info]         )
[info]         server.listen(port)
[info]         connListenerPromise.future:
[info]           scala.concurrent.Future[SocketNetworking.this.ConnectionListener]
[info]       }
[info]   }
[info] }
[info]     trait Api() extends Object {
[info]     val interface: Api.this.Interface
[info]     trait ADTs() extends Object {
[info]       import it.unibo.dap.utils.Iso
[info]       export scala.scalajs.js.annotation.{JSExport, JSExportAll}
[info]       @SourceFile(
[info]         "src/main/scala/scala/scalajs/js/annotation/ExportAnnotations.scala")
[info]         final type JSExport = scala.scalajs.js.annotation.JSExport
[info]       @SourceFile(
[info]         "src/main/scala/scala/scalajs/js/annotation/ExportAnnotations.scala")
[info]         final type JSExportAll = scala.scalajs.js.annotation.JSExportAll
[info]       type IString >: Nothing <: Any
[info]       lazy given val given_Iso_IString_String:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IString, String]
[info]       type IOption[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def given_Iso_IOption_Option[T >: Nothing <: Any]:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IOption[T], Option[T]]
[info]       type ISeq[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def iseqc[T >: Nothing <: Any]:
[info]         Conversion[ADTs.this.ISeq[T], Seq[T]]
[info]       given def iseqcc[T >: Nothing <: Any]:
[info]         Conversion[Seq[T], ADTs.this.ISeq[T]]
[info]       type IFunction1[T1 >: Nothing <: Any, R >: Nothing <: Any]
[info]          >: Nothing <: Any
[info]       given def f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction1[T1, R], T1 => R]
[info]       type IFunction2[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any] >: Nothing <: Any
[info]       given def f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction2[T1, T2, R], (T1, T2) => R]
[info]       @JSExport type Neighbor = ADTs.this.IString
[info]       @JSExport case class Neighborhood(
[info]         neighbors: Seq[ADTs.this.Neighbor] @Repeated) extends Object(),
[info]         _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Neighborhood @unchecked =>
[info]                   this.neighbors.==(x$0.neighbors).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Neighborhood @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "Neighborhood"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "neighbors"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         val neighbors: Seq[ADTs.this.Neighbor] @Repeated
[info]         def _1: Seq[ADTs.this.Neighbor] @Repeated = this.neighbors
[info]       }
[info]       final lazy module val Neighborhood: ADTs.this.Neighborhood =
[info]         new ADTs.this.Neighborhood()
[info]       final module class Neighborhood() extends AnyRef(), 
[info]         scala.deriving.Mirror.Product {
[info]         this: Api.this.ADTs.this.Neighborhood.type =>
[info]         def apply(neighbors: Seq[ADTs.this.Neighbor] @Repeated):
[info]           ADTs.this.Neighborhood = new ADTs.this.Neighborhood(neighbors*)
[info]         def unapplySeq(x$1: ADTs.this.Neighborhood): ADTs.this.Neighborhood =
[info]           x$1
[info]         override def toString: String = "Neighborhood"
[info]         type MirroredMonoType = ADTs.this.Neighborhood
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Neighborhood.MirroredMonoType =
[info]           new ADTs.this.Neighborhood(
[info]             x$0.productElement(0).$asInstanceOf[Seq[ADTs.this.Neighbor]]*)
[info]       }
[info]       @JSExportAll @JSExport case class MSet[T >: Nothing <: Any](
[info]         elems: ADTs.this.ISeq[T]) extends Object(), _root_.scala.Product, _root_
[info]         .scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.MSet[T] @unchecked =>
[info]                   this.elems.==(x$0.elems).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.MSet[T] @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "MSet"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/js/src/main/scala/it/unibo/dap/utils/Platform.scala
[info] package it.unibo.dap.utils {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "elems"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]   import scala.concurrent.Promise
[info]   import scala.scalajs.js.timers.setTimeout
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Platform: it.unibo.dap.utils.Platform =
[info]     new it.unibo.dap.utils.Platform()
[info]   @SourceFile("dap/js/src/main/scala/it/unibo/dap/utils/Platform.scala")
[info]         T
[info]         val elems: ADTs.this.ISeq[T]
[info]         def copy[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def copy$default$1[T]: ADTs.this.ISeq[T] = MSet.this.elems
[info]         def _1: ADTs.this.ISeq[T] = this.elems
[info]       }
[info]       final lazy module val MSet: ADTs.this.MSet = new ADTs.this.MSet()
[info]       final module class MSet() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.MSet.type =>
[info]         def apply[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def unapply[T](x$1: ADTs.this.MSet[T]): ADTs.this.MSet[T] = x$1
[info]         override def toString: String = "MSet"
[info]         type MirroredMonoType = ADTs.this.MSet[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.MSet.MirroredMonoType =
[info]           new ADTs.this.MSet[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.ISeq[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class Rule[Token >: Nothing <: Any](
[info]         pre: ADTs.this.MSet[Token], rate: Double, eff: ADTs.this.MSet[Token],
[info]         msg: ADTs.this.IOption[Token]) extends Object(), _root_.scala.Product,
[info]         _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           {
[info]             var acc: Int = -889275714
[info]             acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Platform() extends Object() {
[info]     this: it.unibo.dap.utils.Platform.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Platform.type])
[info]                 scala.runtime.Statics.anyHash(Rule.this.pre))
[info]     def asyncOps: it.unibo.dap.utils.AsyncOperations = (
[info]       duration: scala.concurrent.duration.FiniteDuration) =>
[info]       {
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.doubleHash(Rule.this.rate))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.eff))
[info]             acc =
[info]         val p: scala.concurrent.Promise[Unit] =
[info]           scala.concurrent.Promise.apply[Unit]()
[info]         scala.scalajs.js.timers.setTimeout(duration)(
[info]           {
[info]             p.success(())
[info]             ()
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.msg))
[info]             scala.runtime.Statics.finalizeHash(acc, 4)
[info]           }
[info]           }
[info]         )
[info]         p.future:scala.concurrent.Future[Unit]
[info]       }
[info]   }
[info] }
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Rule[Token] @unchecked =>
[info]                   this.rate.==(x$0.rate).&&(this.pre.==(x$0.pre)).&&(
[info]                     this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Rule[Token] @unchecked]
[info]         override def productArity: Int = 4
[info]         override def productPrefix: String = "Rule"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case 2 => this._3
[info]               case 3 => this._4
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "pre"
[info]               case 1 => "rate"
[info]               case 2 => "eff"
[info]               case 3 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val pre: ADTs.this.MSet[Token]
[info]         val rate: Double
[info]         val eff: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = Rule.this.pre
[info]         def copy$default$2[Token]: Double @uncheckedVariance = Rule.this.rate
[info]         def copy$default$3[Token]: ADTs.this.MSet[Token] = Rule.this.eff
[info]         def copy$default$4[Token]: ADTs.this.IOption[Token] = Rule.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.pre
[info]         def _2: Double = this.rate
[info]         def _3: ADTs.this.MSet[Token] = this.eff
[info]         def _4: ADTs.this.IOption[Token] = this.msg
[info]       }
[info]       final lazy module val Rule: ADTs.this.Rule = new ADTs.this.Rule()
[info]       final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.Rule.type =>
[info]         def apply[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def unapply[Token](x$1: ADTs.this.Rule[Token]): ADTs.this.Rule[Token] =
[info]           x$1
[info]         override def toString: String = "Rule"
[info]         type MirroredMonoType = ADTs.this.Rule[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Rule.MirroredMonoType =
[info]           new ADTs.this.Rule[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[Double],
[info]             x$0.productElement(2).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(3).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class State[Token >: Nothing <: Any](
[info]         tokens: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]) extends
[info]         Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.State[Token] @unchecked =>
[info]                   this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.State[Token] @unchecked]
[info]         override def productArity: Int = 2
[info]         override def productPrefix: String = "State"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "tokens"
[info]               case 1 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val tokens: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = State.this.tokens
[info]         def copy$default$2[Token]: ADTs.this.IOption[Token] = State.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.tokens
[info]         def _2: ADTs.this.IOption[Token] = this.msg
[info]       }
[info]       final lazy module val State: ADTs.this.State = new ADTs.this.State()
[info]       final module class State() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.State.type =>
[info]         def apply[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def unapply[Token](x$1: ADTs.this.State[Token]): ADTs.this.State[Token]
[info]            = x$1
[info]         override def toString: String = "State"
[info]         type MirroredMonoType = ADTs.this.State[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.State.MirroredMonoType =
[info]           new ADTs.this.State[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]     }
[info]     trait Interface() extends Object { ctx: Api.this.ADTs =>
[info]       export it.unibo.dap.controller.Serializable
[info]       final def Serializable: it.unibo.dap.controller.Serializable.type =
[info]         it.unibo.dap.controller.Serializable
[info]       final type Serializable[T] = it.unibo.dap.controller.Serializable[T]
[info]       export it.unibo.dap.model.Equatable
[info]       final def Equatable: it.unibo.dap.model.Equatable.type =
[info]         it.unibo.dap.model.Equatable
[info]       final type Equatable[T] = it.unibo.dap.model.Equatable[T]
[info]       @JSExport def simulation[Token >: Nothing <: Any](
[info]         rules: Interface.this.ISeq[Interface.this.Rule[Token]],
[info]         initialState: Interface.this.State[Token],
[info]         neighborhood: Interface.this.ISeq[Interface.this.Neighbor],
[info]         serializer: Interface.this.IFunction1[Token, Interface.this.IString],
[info]         deserializer: Interface.this.IFunction1[Interface.this.IString, Token],
[info]         equalizer: Interface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token]
[info]       @JSExport def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn: Interface.this.IFunction1[Interface.this.State[Token], Unit])
[info]         : Unit
[info]       @JSExport def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/Api.scala
[info] package it.unibo.dap.api {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/Api.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Api() extends Object {
[info]     val interface: Api.this.Interface
[info]     trait ADTs() extends Object {
[info]       import it.unibo.dap.utils.Iso
[info]       export scala.scalajs.js.annotation.{JSExport, JSExportAll}
[info]       @field @getter @setter final type JSExport
[info]          = scala.scalajs.js.annotation.JSExport
[info]       final type JSExportAll = scala.scalajs.js.annotation.JSExportAll
[info]       type IString >: Nothing <: Any
[info]       lazy given val given_Iso_IString_String:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IString, String]
[info]       type IOption[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def given_Iso_IOption_Option[T >: Nothing <: Any]:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IOption[T], Option[T]]
[info]       type ISeq[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def iseqc[T >: Nothing <: Any]:
[info]         Conversion[ADTs.this.ISeq[T], Seq[T]]
[info]       given def iseqcc[T >: Nothing <: Any]:
[info]         Conversion[Seq[T], ADTs.this.ISeq[T]]
[info]       type IFunction1[T1 >: Nothing <: Any, R >: Nothing <: Any]
[info]          >: Nothing <: Any
[info]       given def f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction1[T1, R], T1 => R]
[info]       type IFunction2[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any] >: Nothing <: Any
[info]       given def f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction2[T1, T2, R], (T1, T2) => R]
[info]       @JSExport type Neighbor = ADTs.this.IString
[info]       @JSExport case class Neighborhood(
[info]         neighbors: Seq[ADTs.this.Neighbor] @Repeated) extends Object(),
[info]         _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Neighborhood @unchecked =>
[info]                   this.neighbors.==(x$0.neighbors).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Neighborhood @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "Neighborhood"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "neighbors"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         val neighbors: Seq[ADTs.this.Neighbor] @Repeated
[info]         def _1: Seq[ADTs.this.Neighbor] @Repeated = this.neighbors
[info]       }
[info]       final lazy module val Neighborhood: ADTs.this.Neighborhood =
[info]         new ADTs.this.Neighborhood()
[info]       final module class Neighborhood() extends AnyRef(), 
[info]         scala.deriving.Mirror.Product {
[info]         this: Api.this.ADTs.this.Neighborhood.type =>
[info]         def apply(neighbors: Seq[ADTs.this.Neighbor] @Repeated):
[info]           ADTs.this.Neighborhood = new ADTs.this.Neighborhood(neighbors*)
[info]         def unapplySeq(x$1: ADTs.this.Neighborhood): ADTs.this.Neighborhood =
[info]           x$1
[info]         override def toString: String = "Neighborhood"
[info]         type MirroredMonoType = ADTs.this.Neighborhood
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Neighborhood.MirroredMonoType =
[info]           new ADTs.this.Neighborhood(
[info]             x$0.productElement(0).$asInstanceOf[Seq[ADTs.this.Neighbor]]*)
[info]       }
[info]       @JSExportAll @JSExport case class MSet[T >: Nothing <: Any](
[info]         elems: ADTs.this.ISeq[T]) extends Object(), _root_.scala.Product, _root_
[info]         .scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.MSet[T] @unchecked =>
[info]                   this.elems.==(x$0.elems).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.MSet[T] @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "MSet"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "elems"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         T
[info]         val elems: ADTs.this.ISeq[T]
[info]         def copy[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def copy$default$1[T]: ADTs.this.ISeq[T] = MSet.this.elems
[info]         def _1: ADTs.this.ISeq[T] = this.elems
[info]         def $js$exported$prop$elems: Any = this.elems
[info]       }
[info]       final lazy module val MSet: ADTs.this.MSet = new ADTs.this.MSet()
[info]       final module class MSet() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.MSet.type =>
[info]         def apply[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def unapply[T](x$1: ADTs.this.MSet[T]): ADTs.this.MSet[T] = x$1
[info]         override def toString: String = "MSet"
[info]         type MirroredMonoType = ADTs.this.MSet[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.MSet.MirroredMonoType =
[info]           new ADTs.this.MSet[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.ISeq[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class Rule[Token >: Nothing <: Any](
[info]         pre: ADTs.this.MSet[Token], rate: Double, eff: ADTs.this.MSet[Token],
[info]         msg: ADTs.this.IOption[Token]) extends Object(), _root_.scala.Product,
[info]         _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           {
[info]             var acc: Int = -889275714
[info]             acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.pre))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.doubleHash(Rule.this.rate))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.eff))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.msg))
[info]             scala.runtime.Statics.finalizeHash(acc, 4)
[info]           }
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Rule[Token] @unchecked =>
[info]                   this.rate.==(x$0.rate).&&(this.pre.==(x$0.pre)).&&(
[info]                     this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Rule[Token] @unchecked]
[info]         override def productArity: Int = 4
[info]         override def productPrefix: String = "Rule"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case 2 => this._3
[info]               case 3 => this._4
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "pre"
[info]               case 1 => "rate"
[info]               case 2 => "eff"
[info]               case 3 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val pre: ADTs.this.MSet[Token]
[info]         val rate: Double
[info]         val eff: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = Rule.this.pre
[info]         def copy$default$2[Token]: Double @uncheckedVariance = Rule.this.rate
[info]         def copy$default$3[Token]: ADTs.this.MSet[Token] = Rule.this.eff
[info]         def copy$default$4[Token]: ADTs.this.IOption[Token] = Rule.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.pre
[info]         def _2: Double = this.rate
[info]         def _3: ADTs.this.MSet[Token] = this.eff
[info]         def _4: ADTs.this.IOption[Token] = this.msg
[info]         def $js$exported$prop$pre: Any = this.pre
[info]         def $js$exported$prop$rate: Any = this.rate
[info]         def $js$exported$prop$eff: Any = this.eff
[info]         def $js$exported$prop$msg: Any = this.msg
[info]       }
[info]       final lazy module val Rule: ADTs.this.Rule = new ADTs.this.Rule()
[info]       final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.Rule.type =>
[info]         def apply[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def unapply[Token](x$1: ADTs.this.Rule[Token]): ADTs.this.Rule[Token] =
[info]           x$1
[info]         override def toString: String = "Rule"
[info]         type MirroredMonoType = ADTs.this.Rule[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Rule.MirroredMonoType =
[info]           new ADTs.this.Rule[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[Double],
[info]             x$0.productElement(2).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(3).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class State[Token >: Nothing <: Any](
[info]         tokens: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]) extends
[info]         Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.State[Token] @unchecked =>
[info]                   this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.State[Token] @unchecked]
[info]         override def productArity: Int = 2
[info]         override def productPrefix: String = "State"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "tokens"
[info]               case 1 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val tokens: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = State.this.tokens
[info]         def copy$default$2[Token]: ADTs.this.IOption[Token] = State.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.tokens
[info]         def _2: ADTs.this.IOption[Token] = this.msg
[info]         def $js$exported$prop$tokens: Any = this.tokens
[info]         def $js$exported$prop$msg: Any = this.msg
[info]       }
[info]       final lazy module val State: ADTs.this.State = new ADTs.this.State()
[info]       final module class State() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.State.type =>
[info]         def apply[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def unapply[Token](x$1: ADTs.this.State[Token]): ADTs.this.State[Token]
[info]            = x$1
[info]         override def toString: String = "State"
[info]         type MirroredMonoType = ADTs.this.State[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.State.MirroredMonoType =
[info]           new ADTs.this.State[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]       def $js$exported$meth$Neighborhood(neighbors: ADTs.this.Neighbor*):
[info]         ADTs.this.Neighborhood = new ADTs.this.Neighborhood(neighbors)
[info]       def $js$exported$meth$MSet[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T]
[info]          = new ADTs.this.MSet[T](elems)
[info]       def $js$exported$meth$Rule[Token](pre: ADTs.this.MSet[Token],
[info]         rate: Double, eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token])
[info]         : ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]       def $js$exported$meth$State[Token](tokens: ADTs.this.MSet[Token],
[info]         msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]         new ADTs.this.State[Token](tokens, msg)
[info]     }
[info]     trait Interface() extends Object { ctx: Api.this.ADTs =>
[info]       export it.unibo.dap.controller.Serializable
[info]       final def Serializable: it.unibo.dap.controller.Serializable.type =
[info]         it.unibo.dap.controller.Serializable
[info]       final type Serializable[T] = it.unibo.dap.controller.Serializable[T]
[info]       export it.unibo.dap.model.Equatable
[info]       final def Equatable: it.unibo.dap.model.Equatable.type =
[info]         it.unibo.dap.model.Equatable
[info]       final type Equatable[T] = it.unibo.dap.model.Equatable[T]
[info]       @JSExport def simulation[Token >: Nothing <: Any](
[info]         rules: Interface.this.ISeq[Interface.this.Rule[Token]],
[info]         initialState: Interface.this.State[Token],
[info]         neighborhood: Interface.this.ISeq[Interface.this.Neighbor],
[info]         serializer: Interface.this.IFunction1[Token, Interface.this.IString],
[info]         deserializer: Interface.this.IFunction1[Interface.this.IString, Token],
[info]         equalizer: Interface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token]
[info]       @JSExport def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn: Interface.this.IFunction1[Interface.this.State[Token], Unit])
[info]         : Unit
[info]       @JSExport def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit
[info]       def $js$exported$meth$simulation[Token](
[info]         rules: Interface.this.ISeq[Interface.this.Rule[Token]],
[info]         initialState: Interface.this.State[Token],
[info]         neighborhood: Interface.this.ISeq[Interface.this.Neighbor],
[info]         serializer: Interface.this.IFunction1[Token, Interface.this.IString],
[info]         deserializer: Interface.this.IFunction1[Interface.this.IString, Token],
[info]         equalizer: Interface.this.IFunction2[Token, Token, Boolean]): Any =
[info]         this.simulation[Token](rules, initialState, neighborhood, serializer,
[info]           deserializer, equalizer)
[info]       def $js$exported$meth$launch[Token](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn: Interface.this.IFunction1[Interface.this.State[Token], Unit])
[info]         : Any = this.launch[Token](simulation, port, updateFn)
[info]       def $js$exported$meth$stop[Token](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Any =
[info]         this.stop[Token](simulation)
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala
[info] package it.unibo.dap.api {
[info]   import scala.concurrent.ExecutionContext
[info]   import it.unibo.dap.boundary.sockets.{InetNeighborhoodResolver,
[info]     SocketExchangeComponent, SocketNetworking}
[info]   import it.unibo.dap.model.DAP.*
[info]   import it.unibo.dap.model.{CTMC, DAP, Equatable}
[info]   import it.unibo.dap.controller.DistributableInstances.given
[info]   import it.unibo.dap.controller.{DAPSimulation, Serializable}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DASPSimulation[Token >: Nothing <: Any](
[info]     initialState: it.unibo.dap.model.DAP.State[Token],
[info]     rules: Set[it.unibo.dap.model.DAP.Rule[Token]])(using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.DAPSimulation[DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketExchangeComponent[
[info]       DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketNetworking[DASPSimulation.this.Token], 
[info]     it.unibo.dap.boundary.sockets.InetNeighborhoodResolver {
[info]     Token
[info]     private[this] val initialState: it.unibo.dap.model.DAP.State[Token]
[info]     private[this] val rules: Set[it.unibo.dap.model.DAP.Rule[Token]]
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]     override def initial:
[info]       it.unibo.dap.model.DAP.State[DASPSimulation.this.Token] =
[info]       this.initialState
[info]     override def behavior:
[info]       it.unibo.dap.model.CTMC[
[info]         it.unibo.dap.model.DAP.State[DASPSimulation.this.Token]]
[info]      =
[info]       it.unibo.dap.model.DAP.given_Conversion_DAP_CTMC[Token](this.evidence$1).
[info]         apply(it.unibo.dap.model.DAP.apply[Token](this.rules)(this.evidence$1))
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DASPSimulation: it.unibo.dap.api.DASPSimulation =
[info]     new it.unibo.dap.api.DASPSimulation()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DASPSimulation() extends Object() {
[info]     this: it.unibo.dap.api.DASPSimulation.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.DASPSimulation.type])
[info]     def withStaticNeighbors[Token >: Nothing <: Any](
[info]       s0: it.unibo.dap.model.DAP.State[Token],
[info]       rules: Set[it.unibo.dap.model.DAP.Rule[Token]], neighbors: Set[String])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[Token],
[info]       evidence$2: it.unibo.dap.controller.Serializable[Token],
[info]       x$4: scala.concurrent.ExecutionContext):
[info]       it.unibo.dap.api.DASPSimulation[Token] =
[info]       {
[info]         final class $anon() extends Object(),
[info]           
[info]             it.unibo.dap.controller.Simulation[it.unibo.dap.model.CTMC, Token,
[info]               it.unibo.dap.model.DAP.State[Token]]
[info]           (it.unibo.dap.model.CTMC.given_Simulatable_CTMC,
[info]             it.unibo.dap.controller.DistributableInstances.
[info]               given_Distributable_State_T[Token](evidence$2)
[info]           )(),
[info]           it.unibo.dap.controller.DAPSimulation[Token](evidence$1, evidence$2)()
[info]             ,
[info]           it.unibo.dap.boundary.sockets.SocketExchangeComponent[Token](
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.Networking[Token, Token](evidence$2,
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.SocketNetworking[Token](evidence$2, x$4)
[info]             (),
[info]         it.unibo.dap.api.DASPSimulation[Token](s0, rules)(evidence$1, evidence$2
[info]           ) {
[info]           override val neighborhoodResolver: NeighborhoodResolver =
[info]             this.NeighborhoodResolver.static(
[info]               neighbors.map[(Address, Port)]((x$1: String) =>
[info]                 x$1 match 
[info]                   {
[info]                     case 
[info]                       _root_.scala.StringContext.apply(["",":","" : String]*).s(
[info]                         address @ _, port @ _)
[info]                      =>
[info]                       Tuple2.apply[String, Int](address,
[info]                         augmentString(port).toInt)
[info]                     case _ =>
[info]                       throw 
[info]                         new IllegalArgumentException(
[info]                           "Invalid address:port format")
[info]                   }
[info]               )
[info]             )
[info]         }
[info]         new $anon():it.unibo.dap.api.DASPSimulation[Token]
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala
[info] package it.unibo.dap.api {
[info]   import scala.concurrent.ExecutionContext
[info]   import it.unibo.dap.boundary.sockets.{InetNeighborhoodResolver,
[info]     SocketExchangeComponent, SocketNetworking}
[info]   import it.unibo.dap.model.DAP.*
[info]   import it.unibo.dap.model.{CTMC, DAP, Equatable}
[info]   import it.unibo.dap.controller.DistributableInstances.given
[info]   import it.unibo.dap.controller.{DAPSimulation, Serializable}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DASPSimulation[Token >: Nothing <: Any](
[info]     initialState: it.unibo.dap.model.DAP.State[Token],
[info]     rules: Set[it.unibo.dap.model.DAP.Rule[Token]])(using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.DAPSimulation[DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketExchangeComponent[
[info]       DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketNetworking[DASPSimulation.this.Token], 
[info]     it.unibo.dap.boundary.sockets.InetNeighborhoodResolver {
[info]     Token
[info]     private[this] val initialState: it.unibo.dap.model.DAP.State[Token]
[info]     private[this] val rules: Set[it.unibo.dap.model.DAP.Rule[Token]]
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]     override def initial:
[info]       it.unibo.dap.model.DAP.State[DASPSimulation.this.Token] =
[info]       this.initialState
[info]     override def behavior:
[info]       it.unibo.dap.model.CTMC[
[info]         it.unibo.dap.model.DAP.State[DASPSimulation.this.Token]]
[info]      =
[info]       it.unibo.dap.model.DAP.given_Conversion_DAP_CTMC[Token](this.evidence$1).
[info]         apply(it.unibo.dap.model.DAP.apply[Token](this.rules)(this.evidence$1))
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DASPSimulation: it.unibo.dap.api.DASPSimulation =
[info]     new it.unibo.dap.api.DASPSimulation()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DASPSimulation() extends Object() {
[info]     this: it.unibo.dap.api.DASPSimulation.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.DASPSimulation.type])
[info]     def withStaticNeighbors[Token >: Nothing <: Any](
[info]       s0: it.unibo.dap.model.DAP.State[Token],
[info]       rules: Set[it.unibo.dap.model.DAP.Rule[Token]], neighbors: Set[String])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[Token],
[info]       evidence$2: it.unibo.dap.controller.Serializable[Token],
[info]       x$4: scala.concurrent.ExecutionContext):
[info]       it.unibo.dap.api.DASPSimulation[Token] =
[info]       {
[info]         final class $anon() extends Object(),
[info]           
[info]             it.unibo.dap.controller.Simulation[it.unibo.dap.model.CTMC, Token,
[info]               it.unibo.dap.model.DAP.State[Token]]
[info]           (it.unibo.dap.model.CTMC.given_Simulatable_CTMC,
[info]             it.unibo.dap.controller.DistributableInstances.
[info]               given_Distributable_State_T[Token](evidence$2)
[info]           )(),
[info]           it.unibo.dap.controller.DAPSimulation[Token](evidence$1, evidence$2)()
[info]             ,
[info]           it.unibo.dap.boundary.sockets.SocketExchangeComponent[Token](
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.Networking[Token, Token](evidence$2,
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.SocketNetworking[Token](evidence$2, x$4)
[info]             (),
[info]         it.unibo.dap.api.DASPSimulation[Token](s0, rules)(evidence$1, evidence$2
[info]           ) {
[info]           override val neighborhoodResolver: NeighborhoodResolver =
[info]             this.NeighborhoodResolver.static(
[info]               neighbors.map[(Address, Port)]((x$1: String) =>
[info]                 x$1 match 
[info]                   {
[info]                     case 
[info]                       _root_.scala.StringContext.apply(["",":","" : String]*).s(
[info]                         address @ _, port @ _)
[info]                      =>
[info]                       Tuple2.apply[String, Int](address,
[info]                         augmentString(port).toInt)
[info]                     case _ =>
[info]                       throw 
[info]                         new IllegalArgumentException(
[info]                           "Invalid address:port format")
[info]                   }
[info]               )
[info]             )
[info]         }
[info]         new $anon():it.unibo.dap.api.DASPSimulation[Token]
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala
[info] package it.unibo.dap.api {
[info]   import it.unibo.dap.model.DAP
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ProductApi() extends Object, it.unibo.dap.api.Api {
[info]     trait ProductInterface() extends Object, ProductApi.this.Interface {
[info]       ctx: ProductApi.this.ADTs =>
[info]       import scala.concurrent.ExecutionContext
[info]       export this.ProductADTsConversions.{*, given}
[info]       final def Iso:
[info]         
[info]           (ProductInterface.this.ProductADTsConversions.Iso :
[info]             => it.unibo.dap.utils.Iso.type)
[info]         
[info]        = this.ProductADTsConversions.Iso
[info]       final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]       final given def given_Conversion_Function_Function[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Function_Function[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Function_Function[Token]
[info]       final given def given_Conversion_Rule_Rule[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Rule_Rule[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Rule_Rule[Token]
[info]       final given def fromT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]         this.ProductADTsConversions.fromT[Token]
[info]       final inline given def from[T]:
[info]         ProductInterface.this.ProductADTsConversions.from[T] =
[info]         this.ProductADTsConversions.from[T]
[info]       extension [B](b: B) final def back[A](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]         this.ProductADTsConversions.back[B](b)[A](iso)
[info]       final given def to[T]: ProductInterface.this.ProductADTsConversions.to[T]
[info]          = this.ProductADTsConversions.to[T]
[info]       final given def toT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]         this.ProductADTsConversions.toT[Token]
[info]       extension [A](a: A) final def as[B](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]         this.ProductADTsConversions.as[A](a)[B](iso)
[info]       lazy given val given_ExecutionContext: scala.concurrent.ExecutionContext
[info]       override inline def simulation[Token >: Nothing <: Any](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(this.given_Conversion_Rule_Rule[Token].apply(r)))
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             this.fromT[Token].apply(initialState),
[info]             realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       private def simulation$retainedBody[Token](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(
[info]               {
[info]                 val given_Conversion_Rule_Rule_this:
[info]                   
[info]                     ProductInterface.this.ProductADTsConversions.
[info]                       given_Conversion_Rule_Rule[Token]
[info]                   
[info]                  = this.given_Conversion_Rule_Rule[Token]
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 {
[info]                   scribe.package.info("Inside conversion")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val rules: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rules: ","" : String]*).s
[info]                       ([rules : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                       [r.rate : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val eff: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                       [eff : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val msg: Option[Token] =
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                       [msg : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                     it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.pre.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]                       },
[info]                     (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.eff.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]                       },
[info]                       ProductADTsConversions$_this.as[
[info]                         ProductInterface_this.IOption[Token]](r.msg)[
[info]                         Option[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     )
[info]                   scribe.package.info("Conversion ok")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   res:it.unibo.dap.model.DAP.Rule[Token]
[info]                 }:it.unibo.dap.model.DAP.Rule[Token]
[info]               }
[info]             )
[info]           )
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             {
[info]               val fromT_this:
[info]                 ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]                 this.fromT[Token]
[info]               val ProductADTsConversions$_this:
[info]                 ProductInterface.this.ProductADTsConversions.type =
[info]                 this.ProductADTsConversions
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         ProductInterface.this.ProductADTsConversions.type)
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             initialState.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](initialState.msg)[
[info]                   Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[Token]
[info]             },
[info]           realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       override inline def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.State[Token],
[info]             Unit]
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(this.toT[Token].apply(s))
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       private def launch$retainedBody[Token](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           
[info]             ProductInterface.this.IFunction1[
[info]               ProductInterface.this.State[Token], Unit]
[info]           
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(
[info]               {
[info]                 val toT_this:
[info]                   ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]                   this.toT[Token]
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 ProductInterface_this.State.apply[Token](
[info]                   {
[info]                     val to_this: ProductADTsConversions$_this.to[Token] =
[info]                       ProductADTsConversions$_this.to[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                     ProductInterface_this.MSet.apply[Token](
[info]                       ProductInterface_this.iseqcc[Token].apply(
[info]                         s.tokens.asList.toSeq)
[info]                     ):ProductInterface_this.MSet[Token]
[info]                   },
[info]                   ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                     ProductInterface_this.IOption[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 ):ProductInterface_this.State[Token]
[info]               }
[info]             )
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       override def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit =
[info]         {
[info]           simulation.stop()
[info]           ()
[info]         }
[info]       final lazy module val ProductADTsConversions:
[info]         ProductInterface.this.ProductADTsConversions =
[info]         new ProductInterface.this.ProductADTsConversions()
[info]       final module class ProductADTsConversions() extends Object() {
[info]         this: ProductApi.this.ProductInterface.this.ProductADTsConversions.type
[info]            =>
[info]         export it.unibo.dap.utils.{as, back, Iso}
[info]         extension [A](a: A) final def as[B](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]           it.unibo.dap.utils.Iso$package.as[A](a)[B](iso)
[info]         extension [B](b: B) final def back[A](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]           it.unibo.dap.utils.Iso$package.back[B](b)[A](iso)
[info]         final def Iso: it.unibo.dap.utils.Iso.type = it.unibo.dap.utils.Iso
[info]         final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]         import it.unibo.dap.model
[info]         given class from[T >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.MSet[from.this.T],
[info]             it.unibo.dap.model.MSet[from.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: ProductInterface.this.MSet[from.this.T]):
[info]             it.unibo.dap.model.MSet[from.this.T] =
[info]             {
[info]               scribe.package.info("=======>")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.MSet[T] =
[info]                 it.unibo.dap.model.MSet.ofList[T](
[info]                   ProductApi.this.ProductInterface.this.iseqc[T].apply(m.elems).
[info]                     toList
[info]                 )
[info]               scribe.package.info("<=======")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.MSet[T]
[info]             }:it.unibo.dap.model.MSet[from.this.T]
[info]           private def apply$retainedBody(m: ProductInterface.this.MSet[T]):
[info]             it.unibo.dap.model.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .from[T]
[info]                   
[info]                 ).2_<outer>
[info]               {
[info]                 scribe.package.info("=======>")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.MSet[T] =
[info]                   it.unibo.dap.model.MSet.ofList[T](
[info]                     ProductInterface_this.iseqc[T].apply(m.elems).toList)
[info]                 scribe.package.info("<=======")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.MSet[T]
[info]               }:it.unibo.dap.model.MSet[from.this.T]
[info]             }
[info]         }
[info]         final inline given def from[T >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               from
[info]           [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             
[info]           [T]():
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             [T]
[info]         given class to[T >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.MSet[to.this.T],
[info]             ProductInterface.this.MSet[to.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: it.unibo.dap.model.MSet[to.this.T]):
[info]             ProductInterface.this.MSet[to.this.T] =
[info]             ProductApi.this.ProductInterface.this.MSet.apply[T](
[info]               ProductApi.this.ProductInterface.this.iseqcc[T].apply(
[info]                 m.asList.toSeq)
[info]             ):ProductInterface.this.MSet[to.this.T]
[info]           private def apply$retainedBody(m: it.unibo.dap.model.MSet[T]):
[info]             ProductInterface.this.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .to[T]
[info]                   
[info]                 ).2_<outer>
[info]               ProductInterface_this.MSet.apply[T](
[info]                 ProductInterface_this.iseqcc[T].apply(m.asList.toSeq)):
[info]                 ProductInterface_this.MSet[to.this.T]
[info]             }
[info]         }
[info]         final given def to[T >: Nothing <: Any]:
[info]           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.to
[info]             [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .to
[info]             
[info]           [T]()
[info]         given class fromT[Token >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.State[fromT.this.Token],
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: ProductInterface.this.State[fromT.this.Token]):
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token] =
[info]             it.unibo.dap.model.DAP.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                 apply(s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.as[
[info]                 ProductInterface.this.IOption[Token]](s.msg)[Option[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]           private def apply$retainedBody(s: ProductInterface.this.State[Token])
[info]             : it.unibo.dap.model.DAP.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .fromT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         (
[info]                           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                            : ProductInterface.this.ProductADTsConversions.type)
[info]                       )
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             s.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](s.msg)[Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]             }
[info]         }
[info]         final given def fromT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               fromT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .fromT
[info]             
[info]           [Token]()
[info]         given class toT[Token >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.DAP.State[toT.this.Token],
[info]             ProductInterface.this.State[toT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: it.unibo.dap.model.DAP.State[toT.this.Token]):
[info]             ProductInterface.this.State[toT.this.Token] =
[info]             ProductApi.this.ProductInterface.this.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.to[Token].apply(
[info]                 s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.back[
[info]                 Option[Token]](s.msg)[ProductInterface.this.IOption[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):ProductInterface.this.State[toT.this.Token]
[info]           private def apply$retainedBody(s: it.unibo.dap.model.DAP.State[Token])
[info]             : ProductInterface.this.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .toT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               ProductInterface_this.State.apply[Token](
[info]                 {
[info]                   val to_this: ProductADTsConversions$_this.to[Token] =
[info]                     ProductADTsConversions$_this.to[Token]
[info]                   val ProductInterface_this:
[info]                     
[info]                       (ProductInterface.this : ProductApi.this.ADTs &
[info]                         ProductApi.this.ProductInterface)
[info]                     
[info]                    = (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                   ProductInterface_this.MSet.apply[Token](
[info]                     ProductInterface_this.iseqcc[Token].apply(
[info]                       s.tokens.asList.toSeq)
[info]                   ):ProductInterface_this.MSet[Token]
[info]                 },
[info]                 ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                   ProductInterface_this.IOption[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):ProductInterface_this.State[toT.this.Token]
[info]             }
[info]         }
[info]         final given def toT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               toT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .toT
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Function_Function[Token >: Nothing <: Any]
[info]           () extends
[info]           Conversion[ProductInterface.this.State[Token] => Unit,
[info]             it.unibo.dap.model.DAP.State[Token] => Unit]
[info]         () {
[info]           Token
[info]           inline def apply(f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]               f.apply(
[info]                 ProductInterface.this.ProductADTsConversions.this.toT[Token].
[info]                   apply(s)
[info]               )
[info]             :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]           private def apply$retainedBody(
[info]             f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Function_Function[Token]
[info]                   
[info]                 ).1_<outer>
[info]               (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]                 f.apply(
[info]                   {
[info]                     val toT_this: ProductADTsConversions$_this.toT[Token] =
[info]                       ProductADTsConversions$_this.toT[Token]
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (ProductADTsConversions$_this:
[info]                         ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                     ProductInterface_this.State.apply[Token](
[info]                       {
[info]                         val to_this: ProductADTsConversions$_this.to[Token] =
[info]                           ProductADTsConversions$_this.to[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (to_this:ProductADTsConversions$_this.to[Token]).
[info]                             2_<outer>
[info]                         ProductInterface_this.MSet.apply[Token](
[info]                           ProductInterface_this.iseqcc[Token].apply(
[info]                             s.tokens.asList.toSeq)
[info]                         ):ProductInterface_this.MSet[Token]
[info]                       },
[info]                       ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                         ProductInterface_this.IOption[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     ):ProductInterface_this.State[Token]
[info]                   }
[info]                 )
[info]               :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]             }
[info]         }
[info]         final given def given_Conversion_Function_Function[
[info]           Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Function_Function
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Function_Function
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Rule_Rule[Token >: Nothing <: Any]()
[info]            extends
[info]           Conversion[
[info]             ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token],
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(
[info]             r: ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token]
[info]             ):
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]              =
[info]             {
[info]               scribe.package.info("Inside conversion")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val rules:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.pre)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                   [rules : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                   [r.rate : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val eff:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.eff)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                   [eff : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                 ProductInterface.this.ProductADTsConversions.this.as[
[info]                   ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                   ProductApi.this.ProductInterface.this.given_Iso_IOption_Option
[info]                     [Token]
[info]                 )
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                   [msg : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                 it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.pre),
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.eff),
[info]                   ProductInterface.this.ProductADTsConversions.this.as[
[info]                     ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductApi.this.ProductInterface.this.
[info]                       given_Iso_IOption_Option[Token]
[info]                   )
[info]                 )
[info]               scribe.package.info("Conversion ok")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.DAP.Rule[Token]
[info]             }:it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]           private def apply$retainedBody(r: ProductInterface.this.Rule[Token]):
[info]             it.unibo.dap.model.DAP.Rule[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Rule_Rule[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               {
[info]                 scribe.package.info("Inside conversion")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val rules:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.pre.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                     [rules : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                     [r.rate : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val eff:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.eff.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                     [eff : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                   ProductADTsConversions$_this.as[
[info]                     ProductInterface_this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                     [msg : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                   it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   )
[info]                 scribe.package.info("Conversion ok")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.DAP.Rule[Token]
[info]               }:
[info]                 it.unibo.dap.model.DAP.Rule[
[info]                   given_Conversion_Rule_Rule.this.Token]
[info]             }
[info]         }
[info]         final given def given_Conversion_Rule_Rule[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Rule_Rule
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Rule_Rule
[info]             
[info]           [Token]()
[info]       }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import it.unibo.dap.controller.NeighborhoodResolverComponent
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetTypes() extends Object {
[info]     type Address = String
[info]     type Port = Int
[info]     type Endpoint = Tuple2[InetTypes.this.Address, InetTypes.this.Port]
[info]   }
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetNeighborhoodResolver() extends Object,
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent, 
[info]     it.unibo.dap.boundary.sockets.InetTypes {
[info]     override type Neighbor = InetNeighborhoodResolver.this.Endpoint
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.Future
[info]   import it.unibo.dap.controller.Serializable
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Networking[MessageIn >: Nothing <: Any, MessageOut >: Nothing <: Any](
[info]     using evidence$1: it.unibo.dap.controller.Serializable[MessageIn],
[info]     evidence$2: it.unibo.dap.controller.Serializable[MessageOut]) extends Object
[info]      { self: it.unibo.dap.boundary.sockets.InetTypes =>
[info]     +MessageIn
[info]     -MessageOut
[info]     private[this] given val evidence$1:
[info]       it.unibo.dap.controller.Serializable[MessageIn]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[MessageOut]
[info]     def out(endpoint: Networking.this.Endpoint):
[info]       scala.concurrent.Future[Networking.this.Connection]
[info]     def in(port: Networking.this.Port)(onReceive: MessageIn => Unit):
[info]       scala.concurrent.Future[Networking.this.ConnectionListener]
[info]     trait Connection() extends Object, AutoCloseable {
[info]       def send(msg: Networking.this.MessageOut): scala.concurrent.Future[Unit]
[info]       def isOpen: Boolean
[info]     }
[info]     trait ConnectionListener() extends Object, AutoCloseable {
[info]       def isOpen: Boolean
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import it.unibo.dap.utils.*
[info]   import it.unibo.dap.controller.{ExchangeComponent, Serializable}
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketExchangeComponent[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T]) extends Object, 
[info]     it.unibo.dap.controller.ExchangeComponent[SocketExchangeComponent.this.T] {
[info]     ctx:
[info]       it.unibo.dap.boundary.sockets.InetNeighborhoodResolver &
[info]         it.unibo.dap.boundary.sockets.Networking[
[info]           SocketExchangeComponent.this.T, SocketExchangeComponent.this.T]
[info]      =>
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     override type Configuration = SocketExchangeComponent.this.Port
[info]     override val exchange: SocketExchangeComponent.this.Exchange =
[info]       new this.SocketExchange()
[info]     private[this] class SocketExchange() extends Object(),
[info]       SocketExchangeComponent.this.Exchange, AutoCloseable {
[info]       private[this] var connectionListener:
[info]         Option[SocketExchangeComponent.this.ConnectionListener] =
[info]         Option.empty[SocketExchangeComponent.this.ConnectionListener]
[info]       private[this] val inChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       private[this] val outChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       override def inputs:
[info]         it.unibo.dap.utils.ReadableChannel[SocketExchangeComponent.this.T] =
[info]         this.inChannel.asReadable
[info]       override def outputs:
[info]         it.unibo.dap.utils.SendableChannel[SocketExchangeComponent.this.T] =
[info]         this.outChannel.asSendable
[info]       override def spawn(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.utils.unit[List[Unit]](
[info]           scala.concurrent.Future.sequence[Unit, List, List[Unit]](
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.client(this.client$default$1)(x$2)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.serveClients(configuration)(x$2)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           )(
[info]             scala.collection.BuildFrom.buildFromIterableOps[List,
[info]               scala.concurrent.Future[Unit], Unit],
[info]           x$2)
[info]         )(x$2)
[info]       private[this] def client(
[info]         connections:
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection]
[info]       )(using x$2: scala.concurrent.ExecutionContext):
[info]         scala.concurrent.Future[Unit] =
[info]         this.outChannel.pop().flatMap[Unit]((msg: T) =>
[info]           scala.concurrent.Future.successful[
[info]             Set[SocketExchangeComponent.this.Neighbor]](
[info]             it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.
[info]               neighborhoodResolver.apply()
[info]           ).flatMap[Unit]((neighbors: Set[SocketExchangeComponent.this.Neighbor]
[info]             ) =>
[info]             scala.concurrent.Future.traverse[
[info]               (SocketExchangeComponent.this.Address,
[info]                 SocketExchangeComponent.this.Port),
[info]               
[info]                 Either[Throwable, (
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection)]
[info]               ,
[info]             Set](neighbors)((
[info]               n:
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port)
[info]             ) =>
[info]               connections.get(n).filter((
[info]                 _$1: SocketExchangeComponent.this.Connection) => _$1.isOpen).
[info]                 fold[
[info]                 scala.concurrent.Future[SocketExchangeComponent.this.Connection]
[info]                 ](this.establishConnection(n))((
[info]                 result: SocketExchangeComponent.this.Connection) =>
[info]                 scala.concurrent.Future.successful[
[info]                   SocketExchangeComponent.this.Connection](result)
[info]               ).flatMap[
[info]                 
[info]                   Right[Nothing, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((c: SocketExchangeComponent.this.Connection) =>
[info]                 c.send(msg).map[
[info]                   
[info]                     Right[Nothing, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   
[info]                 ]((_$2: Unit) =>
[info]                   Right.apply[Nothing,
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ](
[info]                     ArrowAssoc[
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port)
[info]                     ](n).->[SocketExchangeComponent.this.Connection](c)
[info]                   )
[info]                 )(x$2)
[info]               )(x$2).recover[
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((x$1: Throwable) =>
[info]                 x$1 match 
[info]                   {
[info]                     case e @ _ =>
[info]                       Left.apply[Throwable, Nothing](e)
[info]                   }
[info]               )(x$2)
[info]             )(
[info]               scala.collection.BuildFrom.buildFromIterableOps[Set,
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port),
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ],
[info]             x$2).flatMap[Unit]((
[info]               newConnections:
[info]                 
[info]                   Set[
[info]                     Either[Throwable, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   ]
[info]                 
[info]             ) =>
[info]               this.client(
[info]                 newConnections.collect[
[info]                   (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)
[info]                 ]((
[info]                   x$1:
[info]                     
[info]                       Either[Throwable, (
[info]                         (SocketExchangeComponent.this.Address,
[info]                           SocketExchangeComponent.this.Port),
[info]                         SocketExchangeComponent.this.Connection)]
[info]                     
[info]                 ) =>
[info]                   x$1 match 
[info]                     {
[info]                       case 
[info]                         Right.unapply[Throwable,
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                         ](nc @ _):
[info]                           
[info]                             Right[Throwable, (
[info]                               (SocketExchangeComponent.this.Address,
[info]                                 SocketExchangeComponent.this.Port),
[info]                               SocketExchangeComponent.this.Connection)]
[info]                           
[info]                        =>
[info]                         nc:
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                     }
[info]                 ).toMap[
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection](
[info]                   <:<.refl[
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ]
[info]                 )
[info]               )(x$2).map[Unit]((x$1: Unit) =>
[info]                 x$1:Unit @unchecked match 
[info]                   {
[info]                     case _ => ()
[info]                   }
[info]               )(x$2)
[info]             )(x$2)
[info]           )(x$2)
[info]         )(x$2)
[info]       private[this] def client$default$1:
[info]         
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection] @uncheckedVariance
[info]         
[info]        =
[info]         Map.empty[
[info]           (SocketExchangeComponent.this.Address,
[info]             SocketExchangeComponent.this.Port),
[info]           SocketExchangeComponent.this.Connection]
[info]       private[this] def establishConnection(
[info]         endpoint: SocketExchangeComponent.this.Endpoint):
[info]         scala.concurrent.Future[SocketExchangeComponent.this.Connection] =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.out(endpoint)
[info]       private[this] def serveClients(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.in(
[info]           configuration)((item: T) =>
[info]           {
[info]             this.inChannel.push(item)
[info]             ()
[info]           }
[info]         ).map[Unit]((c: SocketExchangeComponent.this.ConnectionListener) =>
[info]           {
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(
[info]                 ["Socket server listening on port ","" : String]*).f[Any](
[info]                 [configuration : Any]*)
[info]             )(
[info]               sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                 sourcecode.Pkg,
[info]               sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                 sourcecode.FileName,
[info]               sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]               sourcecode.Line.apply(48):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]             this.connectionListener =
[info]               Some.apply[SocketExchangeComponent.this.ConnectionListener](c)
[info]           }
[info]         )(x$2).recoverWith[Unit]((x$1: Throwable) =>
[info]           x$1 match 
[info]             {
[info]               case e @ _ =>
[info]                 scribe.package.error(
[info]                   _root_.scala.StringContext.apply(
[info]                     ["Socket server error: ","" : String]*).s(
[info]                     [e.getMessage() : Any]*)
[info]                 )(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                     sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]                   sourcecode.Line.apply(50):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 this.serveClients(configuration)(x$2)
[info]             }
[info]         )(x$2)
[info]       override def close(): Unit =
[info]         {
[info]           this.inChannel.close()
[info]           this.outChannel.close()
[info]           this.connectionListener.foreach[Unit]((
[info]             _$3: SocketExchangeComponent.this.ConnectionListener) => _$3.close()
[info]             )
[info]         }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.model.DAP.State
[info]   import it.unibo.dap.model.{CTMC, Equatable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DAPSimulation[Token >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.Simulation[CTMC, DAPSimulation.this.Token,
[info]       it.unibo.dap.model.DAP.State[DAPSimulation.this.Token]],
[info]     it.unibo.dap.controller.ExchangeComponent[DAPSimulation.this.Token], 
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent {
[info]     Token
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Distributable[State >: Nothing <: Any, Message >: Nothing <: Any]()
[info]      extends Object {
[info]     State
[info]     Message
[info]     extension (s: Distributable.this.State) def msg:
[info]       Option[Distributable.this.Message]
[info]     extension (s: Distributable.this.State) def updated(
[info]       msg: Distributable.this.Message): Distributable.this.State
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DistributableInstances:
[info]     it.unibo.dap.controller.DistributableInstances =
[info]     new it.unibo.dap.controller.DistributableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DistributableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.DistributableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.DistributableInstances.type])
[info]     import it.unibo.dap.model.{DAP, MSet}
[info]     final given def given_Distributable_State_T[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.controller.Serializable[T]):
[info]       it.unibo.dap.controller.Distributable[it.unibo.dap.model.DAP.State[T], T]
[info]        =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Distributable[it.unibo.dap.model.DAP.State[T], T] {
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def msg:
[info]             Option[T] = s.msg
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def updated(
[info]             msg: T): it.unibo.dap.model.DAP.State[T] =
[info]             s.copy[T](
[info]               tokens =
[info]                 s.tokens.union(it.unibo.dap.model.MSet.apply[T]([msg : T]*)),
[info]               s.copy$default$2[T])
[info]         }
[info]         new $anon():
[info]           
[info]             it.unibo.dap.controller.Distributable[
[info]               it.unibo.dap.model.DAP.State[T], T]
[info]           
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Distributable$package:
[info]     it.unibo.dap.controller.Distributable$package =
[info]     new it.unibo.dap.controller.Distributable$package()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     final module class Distributable$package() extends Object() {
[info]     this: it.unibo.dap.controller.Distributable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Distributable$package.type])
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type DistributableState[Message >: Nothing <: Any] =
[info]       [State >: Nothing <: Any] =>>
[info]         it.unibo.dap.controller.Distributable[State, Message]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.utils.{ReadableChannel, SendableChannel, Spawnable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala")
[info]      @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ExchangeComponent[T >: Nothing <: Any]() extends Object {
[info]     ctx: it.unibo.dap.controller.NeighborhoodResolverComponent =>
[info]     T
[info]     type Configuration >: Nothing <: Any
[info]     val exchange: ExchangeComponent.this.Exchange
[info]     trait Exchange() extends Object,
[info]       it.unibo.dap.utils.Spawnable[ExchangeComponent.this.Configuration], 
[info]       AutoCloseable {
[info]       def inputs: it.unibo.dap.utils.ReadableChannel[ExchangeComponent.this.T]
[info]       def outputs: it.unibo.dap.utils.SendableChannel[ExchangeComponent.this.T]
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait NeighborhoodResolverComponent() extends Object {
[info]     type Neighbor >: Nothing <: Any
[info]     type Neighborhood = Set[NeighborhoodResolverComponent.this.Neighbor]
[info]     val neighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver
[info]     trait NeighborhoodResolver() extends Object, (() =>
[info]       NeighborhoodResolverComponent.this.Neighborhood) {}
[info]     final lazy module val NeighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver =
[info]       new NeighborhoodResolverComponent.this.NeighborhoodResolver()
[info]     final module class NeighborhoodResolver() extends Object() {
[info]       this:
[info]         it.unibo.dap.controller.NeighborhoodResolverComponent.this.
[info]           NeighborhoodResolver.type
[info]        =>
[info]       def static(neighborhood: NeighborhoodResolverComponent.this.Neighborhood)
[info]         : NeighborhoodResolverComponent.this.NeighborhoodResolver = () =>
[info]         neighborhood
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala
[info] package it.unibo.dap.api {
[info]   import it.unibo.dap.model.DAP
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ProductApi() extends Object, it.unibo.dap.api.Api {
[info]     trait ProductInterface() extends Object, ProductApi.this.Interface {
[info]       ctx: ProductApi.this.ADTs =>
[info]       import scala.concurrent.ExecutionContext
[info]       export this.ProductADTsConversions.{*, given}
[info]       final def Iso:
[info]         
[info]           (ProductInterface.this.ProductADTsConversions.Iso :
[info]             => it.unibo.dap.utils.Iso.type)
[info]         
[info]        = this.ProductADTsConversions.Iso
[info]       final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]       final given def given_Conversion_Function_Function[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Function_Function[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Function_Function[Token]
[info]       final given def given_Conversion_Rule_Rule[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Rule_Rule[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Rule_Rule[Token]
[info]       final given def fromT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]         this.ProductADTsConversions.fromT[Token]
[info]       final inline given def from[T]:
[info]         ProductInterface.this.ProductADTsConversions.from[T] =
[info]         this.ProductADTsConversions.from[T]
[info]       extension [B](b: B) final def back[A](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]         this.ProductADTsConversions.back[B](b)[A](iso)
[info]       final given def to[T]: ProductInterface.this.ProductADTsConversions.to[T]
[info]          = this.ProductADTsConversions.to[T]
[info]       final given def toT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]         this.ProductADTsConversions.toT[Token]
[info]       extension [A](a: A) final def as[B](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]         this.ProductADTsConversions.as[A](a)[B](iso)
[info]       lazy given val given_ExecutionContext: scala.concurrent.ExecutionContext
[info]       override inline def simulation[Token >: Nothing <: Any](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(this.given_Conversion_Rule_Rule[Token].apply(r)))
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             this.fromT[Token].apply(initialState),
[info]             realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       private def simulation$retainedBody[Token](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(
[info]               {
[info]                 val given_Conversion_Rule_Rule_this:
[info]                   
[info]                     ProductInterface.this.ProductADTsConversions.
[info]                       given_Conversion_Rule_Rule[Token]
[info]                   
[info]                  = this.given_Conversion_Rule_Rule[Token]
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 {
[info]                   scribe.package.info("Inside conversion")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val rules: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rules: ","" : String]*).s
[info]                       ([rules : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                       [r.rate : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val eff: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala
[info]                           res:it.unibo.dap.model.MSet[Token]
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     case class SerDe[T >: Nothing <: Any](serialize: T => Array[Byte],
[info]     deserialize: Array[Byte] => T) extends Object(), _root_.scala.Product,
[info]     _root_.scala.Serializable {
[info]     override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                       [eff : Any]*)
[info]     override def equals(x$0: Any): Boolean =
[info]       this.eq(x$0.$asInstanceOf[Object]).||(
[info]         x$0 match 
[info]           {
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]             case x$0 @ _:it.unibo.dap.controller.SerDe[T] @unchecked =>
[info]               this.serialize.==(x$0.serialize).&&(
[info]                 this.deserialize.==(x$0.deserialize)).&&(x$0.canEqual(this))
[info]             case _ => false
[info]           }
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val msg: Option[Token] =
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                       [msg : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                     it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]       )
[info]     override def toString(): String = scala.runtime.ScalaRunTime._toString(this)
[info]     override def canEqual(that: Any): Boolean =
[info]       that.isInstanceOf[it.unibo.dap.controller.SerDe[T] @unchecked]
[info]     override def productArity: Int = 2
[info]     override def productPrefix: String = "SerDe"
[info]     override def productElement(n: Int): Any =
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.pre.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]       n match 
[info]         {
[info]           case 0 => this._1
[info]           case 1 => this._2
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]     override def productElementName(n: Int): String =
[info]                       },
[info]                     (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]       n match 
[info]         {
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]           case 0 => "serialize"
[info]           case 1 => "deserialize"
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     T
[info]     val serialize: T => Array[Byte]
[info]     val deserialize: Array[Byte] => T
[info]     def copy[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def copy$default$1[T]: T => Array[Byte] = SerDe.this.serialize
[info]     def copy$default$2[T]: Array[Byte] => T = SerDe.this.deserialize
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]     def _1: T => Array[Byte] = this.serialize
[info]     def _2: Array[Byte] => T = this.deserialize
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.eff.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]                       },
[info]                       ProductADTsConversions$_this.as[
[info]                         ProductInterface_this.IOption[Token]](r.msg)[
[info]                         Option[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     )
[info]                   scribe.package.info("Conversion ok")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   res:it.unibo.dap.model.DAP.Rule[Token]
[info]                 }:it.unibo.dap.model.DAP.Rule[Token]
[info]               }
[info]             )
[info]           )
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerDe: it.unibo.dap.controller.SerDe =
[info]     new it.unibo.dap.controller.SerDe()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerDe() extends AnyRef(), scala.deriving.Mirror.Product {
[info]      this: it.unibo.dap.controller.SerDe.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerDe.type])
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             {
[info]               val fromT_this:
[info]                 ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]                 this.fromT[Token]
[info]               val ProductADTsConversions$_this:
[info]                 ProductInterface.this.ProductADTsConversions.type =
[info]                 this.ProductADTsConversions
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         ProductInterface.this.ProductADTsConversions.type)
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]     def apply[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             initialState.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def unapply[T](x$1: it.unibo.dap.controller.SerDe[T]):
[info]       it.unibo.dap.controller.SerDe[T] = x$1
[info]     override def toString: String = "SerDe"
[info]     type MirroredMonoType = it.unibo.dap.controller.SerDe[? <: AnyKind]
[info]     def fromProduct(x$0: Product):
[info]       it.unibo.dap.controller.SerDe.MirroredMonoType =
[info]       new it.unibo.dap.controller.SerDe[Any](
[info]         x$0.productElement(0).$asInstanceOf[Any => Array[Byte]],
[info]         x$0.productElement(1).$asInstanceOf[Array[Byte] => Any])
[info]   }
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Serializable[T >: Nothing <: Any]() extends Object {
[info]     T
[info]     def serialize(t: Serializable.this.T): Array[Byte]
[info]     def deserialize(bytes: Array[Byte]): Serializable.this.T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Serializable: it.unibo.dap.controller.Serializable =
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](initialState.msg)[
[info]                   Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[Token]
[info]             },
[info]           realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       override inline def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.State[Token],
[info]             Unit]
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(this.toT[Token].apply(s))
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       private def launch$retainedBody[Token](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           
[info]             ProductInterface.this.IFunction1[
[info]               ProductInterface.this.State[Token], Unit]
[info]           
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(
[info]               {
[info]                 val toT_this:
[info]                   ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]     new it.unibo.dap.controller.Serializable()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]                   this.toT[Token]
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Serializable() extends Object() {
[info]     this: it.unibo.dap.controller.Serializable.type =>
[info]     private def writeReplace(): AnyRef =
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Serializable.type])
[info]     def serialize[T >: Nothing <: Any](t: T)(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): Array[Byte] = s.serialize(t)
[info]     def deserialize[T >: Nothing <: Any](t: Array[Byte])(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): T = s.deserialize(t)
[info]     def from[T >: Nothing <: Any](serializer: T => Array[Byte],
[info]       deserializer: Array[Byte] => T): it.unibo.dap.controller.Serializable[T]
[info]        =
[info]       it.unibo.dap.controller.Serializable.asSerializable[T](
[info]         it.unibo.dap.controller.SerDe.apply[T](serializer, deserializer))
[info]     extension [T >: Nothing <: Any](serde: it.unibo.dap.controller.SerDe[T])
[info]       def asSerializable: it.unibo.dap.controller.Serializable[T] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Serializable[T] {
[info]           override def serialize(t: T): Array[Byte] = serde.serialize.apply(t)
[info]           override def deserialize(bytes: Array[Byte]): T =
[info]             serde.deserialize.apply(bytes)
[info]         }
[info]         new $anon():it.unibo.dap.controller.Serializable[T]
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerializableInstances:
[info]     it.unibo.dap.controller.SerializableInstances =
[info]     new it.unibo.dap.controller.SerializableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerializableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.SerializableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerializableInstances.type])
[info]     final lazy module given val given_Serializable_String:
[info]       it.unibo.dap.controller.SerializableInstances.given_Serializable_String =
[info]       new 
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String(
[info]         )
[info]     final module class given_Serializable_String() extends Object(), 
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]       it.unibo.dap.controller.Serializable[String] {
[info]       this:
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String.
[info]           type
[info]        =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[
[info]             it.unibo.dap.controller.SerializableInstances.
[info]               given_Serializable_String.type
[info]           ]
[info]         )
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 ProductInterface_this.State.apply[Token](
[info]                   {
[info]                     val to_this: ProductADTsConversions$_this.to[Token] =
[info]                       ProductADTsConversions$_this.to[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                     ProductInterface_this.MSet.apply[Token](
[info]                       ProductInterface_this.iseqcc[Token].apply(
[info]                         s.tokens.asList.toSeq)
[info]                     ):ProductInterface_this.MSet[Token]
[info]                   },
[info]                   ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                     ProductInterface_this.IOption[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 ):ProductInterface_this.State[Token]
[info]               }
[info]             )
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       override def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit =
[info]         {
[info]       override def serialize(t: String): Array[Byte] = t.getBytes()
[info]           simulation.stop()
[info]           ()
[info]         }
[info]       final lazy module val ProductADTsConversions:
[info]         ProductInterface.this.ProductADTsConversions =
[info]         new ProductInterface.this.ProductADTsConversions()
[info]       final module class ProductADTsConversions() extends Object() {
[info]         this: ProductApi.this.ProductInterface.this.ProductADTsConversions.type
[info]            =>
[info]         export it.unibo.dap.utils.{as, back, Iso}
[info]       override def deserialize(bytes: Array[Byte]): String = new String(bytes)
[info]     }
[info]   }
[info] }
[info]         extension [A](a: A) final def as[B](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]           it.unibo.dap.utils.Iso$package.as[A](a)[B](iso)
[info]         extension [B](b: B) final def back[A](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]           it.unibo.dap.utils.Iso$package.back[B](b)[A](iso)
[info]         final def Iso: it.unibo.dap.utils.Iso.type = it.unibo.dap.utils.Iso
[info]         final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]         import it.unibo.dap.model
[info]         given class from[T >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.MSet[from.this.T],
[info]             it.unibo.dap.model.MSet[from.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: ProductInterface.this.MSet[from.this.T]):
[info]             it.unibo.dap.model.MSet[from.this.T] =
[info]             {
[info]               scribe.package.info("=======>")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.MSet[T] =
[info]                 it.unibo.dap.model.MSet.ofList[T](
[info]                   ProductApi.this.ProductInterface.this.iseqc[T].apply(m.elems).
[info]                     toList
[info]                 )
[info]               scribe.package.info("<=======")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.MSet[T]
[info]             }:it.unibo.dap.model.MSet[from.this.T]
[info]           private def apply$retainedBody(m: ProductInterface.this.MSet[T]):
[info]             it.unibo.dap.model.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .from[T]
[info]                   
[info]                 ).2_<outer>
[info]               {
[info]                 scribe.package.info("=======>")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.MSet[T] =
[info]                   it.unibo.dap.model.MSet.ofList[T](
[info]                     ProductInterface_this.iseqc[T].apply(m.elems).toList)
[info]                 scribe.package.info("<=======")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.MSet[T]
[info]               }:it.unibo.dap.model.MSet[from.this.T]
[info]             }
[info]         }
[info]         final inline given def from[T >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               from
[info]           [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             
[info]           [T]():
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             [T]
[info]         given class to[T >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.MSet[to.this.T],
[info]             ProductInterface.this.MSet[to.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: it.unibo.dap.model.MSet[to.this.T]):
[info]             ProductInterface.this.MSet[to.this.T] =
[info]             ProductApi.this.ProductInterface.this.MSet.apply[T](
[info]               ProductApi.this.ProductInterface.this.iseqcc[T].apply(
[info]                 m.asList.toSeq)
[info]             ):ProductInterface.this.MSet[to.this.T]
[info]           private def apply$retainedBody(m: it.unibo.dap.model.MSet[T]):
[info]             ProductInterface.this.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .to[T]
[info]                   
[info]                 ).2_<outer>
[info]               ProductInterface_this.MSet.apply[T](
[info]                 ProductInterface_this.iseqcc[T].apply(m.asList.toSeq)):
[info]                 ProductInterface_this.MSet[to.this.T]
[info]             }
[info]         }
[info]         final given def to[T >: Nothing <: Any]:
[info]           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.to
[info]             [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .to
[info]             
[info]           [T]()
[info]         given class fromT[Token >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.State[fromT.this.Token],
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: ProductInterface.this.State[fromT.this.Token]):
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token] =
[info]             it.unibo.dap.model.DAP.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                 apply(s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.as[
[info]                 ProductInterface.this.IOption[Token]](s.msg)[Option[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]           private def apply$retainedBody(s: ProductInterface.this.State[Token])
[info]             : it.unibo.dap.model.DAP.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .fromT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         (
[info]                           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                            : ProductInterface.this.ProductADTsConversions.type)
[info]                       )
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             s.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](s.msg)[Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]             }
[info]         }
[info]         final given def fromT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               fromT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .fromT
[info]             
[info]           [Token]()
[info]         given class toT[Token >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.DAP.State[toT.this.Token],
[info]             ProductInterface.this.State[toT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: it.unibo.dap.model.DAP.State[toT.this.Token]):
[info]             ProductInterface.this.State[toT.this.Token] =
[info]             ProductApi.this.ProductInterface.this.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.to[Token].apply(
[info]                 s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.back[
[info]                 Option[Token]](s.msg)[ProductInterface.this.IOption[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):ProductInterface.this.State[toT.this.Token]
[info]           private def apply$retainedBody(s: it.unibo.dap.model.DAP.State[Token])
[info]             : ProductInterface.this.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .toT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               ProductInterface_this.State.apply[Token](
[info]                 {
[info]                   val to_this: ProductADTsConversions$_this.to[Token] =
[info]                     ProductADTsConversions$_this.to[Token]
[info]                   val ProductInterface_this:
[info]                     
[info]                       (ProductInterface.this : ProductApi.this.ADTs &
[info]                         ProductApi.this.ProductInterface)
[info]                     
[info]                    = (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                   ProductInterface_this.MSet.apply[Token](
[info]                     ProductInterface_this.iseqcc[Token].apply(
[info]                       s.tokens.asList.toSeq)
[info]                   ):ProductInterface_this.MSet[Token]
[info]                 },
[info]                 ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                   ProductInterface_this.IOption[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):ProductInterface_this.State[toT.this.Token]
[info]             }
[info]         }
[info]         final given def toT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               toT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .toT
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Function_Function[Token >: Nothing <: Any]
[info]           () extends
[info]           Conversion[ProductInterface.this.State[Token] => Unit,
[info]             it.unibo.dap.model.DAP.State[Token] => Unit]
[info]         () {
[info]           Token
[info]           inline def apply(f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]               f.apply(
[info]                 ProductInterface.this.ProductADTsConversions.this.toT[Token].
[info]                   apply(s)
[info]               )
[info]             :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]           private def apply$retainedBody(
[info]             f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Function_Function[Token]
[info]                   
[info]                 ).1_<outer>
[info]               (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]                 f.apply(
[info]                   {
[info]                     val toT_this: ProductADTsConversions$_this.toT[Token] =
[info]                       ProductADTsConversions$_this.toT[Token]
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (ProductADTsConversions$_this:
[info]                         ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                     ProductInterface_this.State.apply[Token](
[info]                       {
[info]                         val to_this: ProductADTsConversions$_this.to[Token] =
[info]                           ProductADTsConversions$_this.to[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (to_this:ProductADTsConversions$_this.to[Token]).
[info]                             2_<outer>
[info]                         ProductInterface_this.MSet.apply[Token](
[info]                           ProductInterface_this.iseqcc[Token].apply(
[info]                             s.tokens.asList.toSeq)
[info]                         ):ProductInterface_this.MSet[Token]
[info]                       },
[info]                       ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                         ProductInterface_this.IOption[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     ):ProductInterface_this.State[Token]
[info]                   }
[info]                 )
[info]               :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]             }
[info]         }
[info]         final given def given_Conversion_Function_Function[
[info]           Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Function_Function
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Function_Function
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Rule_Rule[Token >: Nothing <: Any]()
[info]            extends
[info]           Conversion[
[info]             ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token],
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(
[info]             r: ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token]
[info]             ):
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]              =
[info]             {
[info]               scribe.package.info("Inside conversion")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val rules:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.pre)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                   [rules : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                   [r.rate : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val eff:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.eff)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                   [eff : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                 ProductInterface.this.ProductADTsConversions.this.as[
[info]                   ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                   ProductApi.this.ProductInterface.this.given_Iso_IOption_Option
[info]                     [Token]
[info]                 )
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                   [msg : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                 it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.pre),
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.eff),
[info]                   ProductInterface.this.ProductADTsConversions.this.as[
[info]                     ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductApi.this.ProductInterface.this.
[info]                       given_Iso_IOption_Option[Token]
[info]                   )
[info]                 )
[info]               scribe.package.info("Conversion ok")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.DAP.Rule[Token]
[info]             }:it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]           private def apply$retainedBody(r: ProductInterface.this.Rule[Token]):
[info]             it.unibo.dap.model.DAP.Rule[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Rule_Rule[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               {
[info]                 scribe.package.info("Inside conversion")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val rules:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.pre.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                     [rules : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                     [r.rate : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val eff:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.eff.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                     [eff : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                   ProductADTsConversions$_this.as[
[info]                     ProductInterface_this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                     [msg : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                   it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   )
[info]                 scribe.package.info("Conversion ok")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.DAP.Rule[Token]
[info]               }:
[info]                 it.unibo.dap.model.DAP.Rule[
[info]                   given_Conversion_Rule_Rule.this.Token]
[info]             }
[info]         }
[info]         final given def given_Conversion_Rule_Rule[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Rule_Rule
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Rule_Rule
[info]             
[info]           [Token]()
[info]       }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala
[info] package it.unibo.dap.controller {
[info]   import java.util.Random
[info]   import java.util.concurrent.atomic.AtomicBoolean
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import scala.language.experimental.betterFors
[info]   import scala.concurrent.duration.DurationDouble
[info]   import it.unibo.dap.utils.{unit, Async}
[info]   import it.unibo.dap.model.Simulatable.Event
[info]   import it.unibo.dap.model.Simulatable
[info]   import scala.util.Failure
[info]   import scala.util.Success
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala")
[info]     @experimental(
[info]     
[info]       "Added by top level \u001b[33mimport \u001b[0mscala.language.experimental.betterFors"
[info]       
[info]   ) trait Simulation[B[_ >: Nothing <: Any] >: Nothing <: Any,
[info]     T >: Nothing <: Any, S >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Simulatable[B],
[info]     evidence$2: it.unibo.dap.controller.DistributableState[T][S]) extends Object
[info]      { ctx: it.unibo.dap.controller.ExchangeComponent[Simulation.this.T] =>
[info]     B[_$1]
[info]     T
[info]     S
[info]     private[this] given val evidence$1: it.unibo.dap.model.Simulatable[B]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.DistributableState[T][S]
[info]     type SimulationError = String
[info]     def initial: Simulation.this.S
[info]     def behavior: Simulation.this.B[Simulation.this.S]
[info]     private[this] val isRunning: java.util.concurrent.atomic.AtomicBoolean =
[info]       new java.util.concurrent.atomic.AtomicBoolean(false)
[info]     def stop(): Either[Simulation.this.SimulationError, Unit] =
[info]       Either.cond[String, Unit](this.isRunning.compareAndSet(true, false), (),
[info]         "Simulation is not running.").map[Unit]((_$2: Unit) =>
[info]         this.exchange.close())
[info]     def launch(conf: this.Configuration)(updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       if this.isRunning.compareAndSet(false, true) then
[info]         {
[info]           val tasks: List[scala.concurrent.Future[Unit]] =
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.loop(this.initial, updateFn)(x$3)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.exchange.spawn(conf)(x$3)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           it.unibo.dap.utils.unit[List[Unit]](
[info]             scala.concurrent.Future.sequence[Unit, List, List[Unit]](tasks)(
[info]               scala.collection.BuildFrom.buildFromIterableOps[List,
[info]                 scala.concurrent.Future[Unit], Unit],
[info]             x$3).andThen[Unit]((x$1: scala.util.Try[List[Unit]]) =>
[info]               x$1 match 
[info]                 {
[info]                   case 
[info]                     scala.util.Failure.unapply[List[Unit]](e @ _):
[info]                       scala.util.Failure[List[Unit]]
[info]                    =>
[info]                     scribe.package.error(
[info]                       [scribe.LogFeature.throwable2LoggableMessage(e) :
[info]                         scribe.LogFeature]*
[info]                     )(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                   case 
[info]                     scala.util.Success.unapply[List[Unit]](_):
[info]                       scala.util.Success[List[Unit]]
[info]                    =>
[info]                     scribe.package.info("sim ended")(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                 }
[info]             )(x$3)
[info]           )(x$3)
[info]         }
[info]        else 
[info]         scala.concurrent.Future.failed[Nothing](
[info]           new IllegalStateException("Simulation is already running."))
[info]     private[this] def loop(state: Simulation.this.S, updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       {
[info]         val event: it.unibo.dap.model.Simulatable.Event[S] =
[info]           this.evidence$1.simulateStep[S](this.behavior)(state)(using
[info]             new java.util.Random())
[info]         it.unibo.dap.utils.Async.operations.sleep(
[info]           scala.concurrent.duration.DurationDouble(event.time).seconds).
[info]           withFilter((x$1: Unit) =>
[info]           x$1:Unit @unchecked match 
[info]             {
[info]               case _ => this.isRunning.get()
[info]             }
[info]         )(x$3).flatMap[Unit]((x$1: Unit) =>
[info]           x$1:(x$1 : Unit) @unchecked match 
[info]             {
[info]               case _ =>
[info]                 this.updateLogic(event, updateFn)(x$3).map[Unit]((x$1: Unit) =>
[info]                   x$1:Unit @unchecked match 
[info]                     {
[info]                       case _ => ()
[info]                     }
[info]                 )(x$3)
[info]             }
[info]         )(x$3)
[info]       }
[info]     private[this] def updateLogic(
[info]       event: it.unibo.dap.model.Simulatable.Event[Simulation.this.S],
[info]       updateFn: S => Unit)(using x$3: scala.concurrent.ExecutionContext):
[info]       scala.concurrent.Future[Unit] =
[info]       {
[info]         updateFn.apply(event.state)
[info]         this.evidence$2.msg(event.state).foreach[
[info]           Either[it.unibo.dap.utils.Channel.Error, Unit]](
[info]           {
[info]             val $1$: it.unibo.dap.utils.SendableChannel[T] =
[info]               this.exchange.outputs
[info]             (item: T) => $1$.push(item)
[info]           }
[info]         )
[info]         val in: Option[T] = this.exchange.inputs.poll()
[info]         val newState: S =
[info]           in.fold[S](event.state)((msg: T) =>
[info]             this.evidence$2.updated(event.state)(msg))
[info]         this.loop(newState, updateFn)(x$3)
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import it.unibo.dap.controller.NeighborhoodResolverComponent
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetTypes() extends Object {
[info]     type Address = String
[info]     type Port = Int
[info]     type Endpoint = Tuple2[InetTypes.this.Address, InetTypes.this.Port]
[info]   }
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetNeighborhoodResolver() extends Object,
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent, 
[info]     it.unibo.dap.boundary.sockets.InetTypes {
[info]     override type Neighbor = InetNeighborhoodResolver.this.Endpoint
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.Future
[info]   import it.unibo.dap.controller.Serializable
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Networking[MessageIn >: Nothing <: Any, MessageOut >: Nothing <: Any](
[info]     using evidence$1: it.unibo.dap.controller.Serializable[MessageIn],
[info]     evidence$2: it.unibo.dap.controller.Serializable[MessageOut]) extends Object
[info]      { self: it.unibo.dap.boundary.sockets.InetTypes =>
[info]     +MessageIn
[info]     -MessageOut
[info]     private[this] given val evidence$1:
[info]       it.unibo.dap.controller.Serializable[MessageIn]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[MessageOut]
[info]     def out(endpoint: Networking.this.Endpoint):
[info]       scala.concurrent.Future[Networking.this.Connection]
[info]     def in(port: Networking.this.Port)(onReceive: MessageIn => Unit):
[info]       scala.concurrent.Future[Networking.this.ConnectionListener]
[info]     trait Connection() extends Object, AutoCloseable {
[info]       def send(msg: Networking.this.MessageOut): scala.concurrent.Future[Unit]
[info]       def isOpen: Boolean
[info]     }
[info]     trait ConnectionListener() extends Object, AutoCloseable {
[info]       def isOpen: Boolean
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import it.unibo.dap.utils.*
[info]   import it.unibo.dap.controller.{ExchangeComponent, Serializable}
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketExchangeComponent[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T]) extends Object, 
[info]     it.unibo.dap.controller.ExchangeComponent[SocketExchangeComponent.this.T] {
[info]     ctx:
[info]       it.unibo.dap.boundary.sockets.InetNeighborhoodResolver &
[info]         it.unibo.dap.boundary.sockets.Networking[
[info]           SocketExchangeComponent.this.T, SocketExchangeComponent.this.T]
[info]      =>
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     override type Configuration = SocketExchangeComponent.this.Port
[info]     override val exchange: SocketExchangeComponent.this.Exchange =
[info]       new this.SocketExchange()
[info]     private[this] class SocketExchange() extends Object(),
[info]       SocketExchangeComponent.this.Exchange, AutoCloseable {
[info]       private[this] var connectionListener:
[info]         Option[SocketExchangeComponent.this.ConnectionListener] =
[info]         Option.empty[SocketExchangeComponent.this.ConnectionListener]
[info]       private[this] val inChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       private[this] val outChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       override def inputs:
[info]         it.unibo.dap.utils.ReadableChannel[SocketExchangeComponent.this.T] =
[info]         this.inChannel.asReadable
[info]       override def outputs:
[info]         it.unibo.dap.utils.SendableChannel[SocketExchangeComponent.this.T] =
[info]         this.outChannel.asSendable
[info]       override def spawn(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.utils.unit[List[Unit]](
[info]           scala.concurrent.Future.sequence[Unit, List, List[Unit]](
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.client(this.client$default$1)(x$2)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.serveClients(configuration)(x$2)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           )(
[info]             scala.collection.BuildFrom.buildFromIterableOps[List,
[info]               scala.concurrent.Future[Unit], Unit],
[info]           x$2)
[info]         )(x$2)
[info]       private[this] def client(
[info]         connections:
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection]
[info]       )(using x$2: scala.concurrent.ExecutionContext):
[info]         scala.concurrent.Future[Unit] =
[info]         this.outChannel.pop().flatMap[Unit]((msg: T) =>
[info]           scala.concurrent.Future.successful[
[info]             Set[SocketExchangeComponent.this.Neighbor]](
[info]             it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.
[info]               neighborhoodResolver.apply()
[info]           ).flatMap[Unit]((neighbors: Set[SocketExchangeComponent.this.Neighbor]
[info]             ) =>
[info]             scala.concurrent.Future.traverse[
[info]               (SocketExchangeComponent.this.Address,
[info]                 SocketExchangeComponent.this.Port),
[info]               
[info]                 Either[Throwable, (
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection)]
[info]               ,
[info]             Set](neighbors)((
[info]               n:
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port)
[info]             ) =>
[info]               connections.get(n).filter((
[info]                 _$1: SocketExchangeComponent.this.Connection) => _$1.isOpen).
[info]                 fold[
[info]                 scala.concurrent.Future[SocketExchangeComponent.this.Connection]
[info]                 ](this.establishConnection(n))((
[info]                 result: SocketExchangeComponent.this.Connection) =>
[info]                 scala.concurrent.Future.successful[
[info]                   SocketExchangeComponent.this.Connection](result)
[info]               ).flatMap[
[info]                 
[info]                   Right[Nothing, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((c: SocketExchangeComponent.this.Connection) =>
[info]                 c.send(msg).map[
[info]                   
[info]                     Right[Nothing, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   
[info]                 ]((_$2: Unit) =>
[info]                   Right.apply[Nothing,
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ](
[info]                     ArrowAssoc[
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port)
[info]                     ](n).->[SocketExchangeComponent.this.Connection](c)
[info]                   )
[info]                 )(x$2)
[info]               )(x$2).recover[
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((x$1: Throwable) =>
[info]                 x$1 match 
[info]                   {
[info]                     case e @ _ =>
[info]                       Left.apply[Throwable, Nothing](e)
[info]                   }
[info]               )(x$2)
[info]             )(
[info]               scala.collection.BuildFrom.buildFromIterableOps[Set,
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port),
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ],
[info]             x$2).flatMap[Unit]((
[info]               newConnections:
[info]                 
[info]                   Set[
[info]                     Either[Throwable, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   ]
[info]                 
[info]             ) =>
[info]               this.client(
[info]                 newConnections.collect[
[info]                   (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)
[info]                 ]((
[info]                   x$1:
[info]                     
[info]                       Either[Throwable, (
[info]                         (SocketExchangeComponent.this.Address,
[info]                           SocketExchangeComponent.this.Port),
[info]                         SocketExchangeComponent.this.Connection)]
[info]                     
[info]                 ) =>
[info]                   x$1 match 
[info]                     {
[info]                       case 
[info]                         Right.unapply[Throwable,
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                         ](nc @ _):
[info]                           
[info]                             Right[Throwable, (
[info]                               (SocketExchangeComponent.this.Address,
[info]                                 SocketExchangeComponent.this.Port),
[info]                               SocketExchangeComponent.this.Connection)]
[info]                           
[info]                        =>
[info]                         nc:
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                     }
[info]                 ).toMap[
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection](
[info]                   <:<.refl[
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ]
[info]                 )
[info]               )(x$2).map[Unit]((x$1: Unit) =>
[info]                 x$1:Unit @unchecked match 
[info]                   {
[info]                     case _ => ()
[info]                   }
[info]               )(x$2)
[info]             )(x$2)
[info]           )(x$2)
[info]         )(x$2)
[info]       private[this] def client$default$1:
[info]         
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection] @uncheckedVariance
[info]         
[info]        =
[info]         Map.empty[
[info]           (SocketExchangeComponent.this.Address,
[info]             SocketExchangeComponent.this.Port),
[info]           SocketExchangeComponent.this.Connection]
[info]       private[this] def establishConnection(
[info]         endpoint: SocketExchangeComponent.this.Endpoint):
[info]         scala.concurrent.Future[SocketExchangeComponent.this.Connection] =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.out(endpoint)
[info]       private[this] def serveClients(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.in(
[info]           configuration)((item: T) =>
[info]           {
[info]             this.inChannel.push(item)
[info]             ()
[info]           }
[info]         ).map[Unit]((c: SocketExchangeComponent.this.ConnectionListener) =>
[info]           {
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(
[info]                 ["Socket server listening on port ","" : String]*).f[Any](
[info]                 [configuration : Any]*)
[info]             )(
[info]               sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                 sourcecode.Pkg,
[info]               sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                 sourcecode.FileName,
[info]               sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]               sourcecode.Line.apply(48):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]             this.connectionListener =
[info]               Some.apply[SocketExchangeComponent.this.ConnectionListener](c)
[info]           }
[info]         )(x$2).recoverWith[Unit]((x$1: Throwable) =>
[info]           x$1 match 
[info]             {
[info]               case e @ _ =>
[info]                 scribe.package.error(
[info]                   _root_.scala.StringContext.apply(
[info]                     ["Socket server error: ","" : String]*).s(
[info]                     [e.getMessage() : Any]*)
[info]                 )(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                     sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]                   sourcecode.Line.apply(50):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 this.serveClients(configuration)(x$2)
[info]             }
[info]         )(x$2)
[info]       override def close(): Unit =
[info]         {
[info]           this.inChannel.close()
[info]           this.outChannel.close()
[info]           this.connectionListener.foreach[Unit]((
[info]             _$3: SocketExchangeComponent.this.ConnectionListener) => _$3.close()
[info]             )
[info]         }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.model.DAP.State
[info]   import it.unibo.dap.model.{CTMC, Equatable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DAPSimulation[Token >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.Simulation[CTMC, DAPSimulation.this.Token,
[info]       it.unibo.dap.model.DAP.State[DAPSimulation.this.Token]],
[info]     it.unibo.dap.controller.ExchangeComponent[DAPSimulation.this.Token], 
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent {
[info]     Token
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Distributable[State >: Nothing <: Any, Message >: Nothing <: Any]()
[info]      extends Object {
[info]     State
[info]     Message
[info]     extension (s: Distributable.this.State) def msg:
[info]       Option[Distributable.this.Message]
[info]     extension (s: Distributable.this.State) def updated(
[info]       msg: Distributable.this.Message): Distributable.this.State
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DistributableInstances:
[info]     it.unibo.dap.controller.DistributableInstances =
[info]     new it.unibo.dap.controller.DistributableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DistributableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.DistributableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.DistributableInstances.type])
[info]     import it.unibo.dap.model.{DAP, MSet}
[info]     final given def given_Distributable_State_T[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.controller.Serializable[T]):
[info]       it.unibo.dap.controller.Distributable[it.unibo.dap.model.DAP.State[T], T]
[info]        =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Distributable[it.unibo.dap.model.DAP.State[T], T] {
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def msg:
[info]             Option[T] = s.msg
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def updated(
[info]             msg: T): it.unibo.dap.model.DAP.State[T] =
[info]             s.copy[T](
[info]               tokens =
[info]                 s.tokens.union(it.unibo.dap.model.MSet.apply[T]([msg : T]*)),
[info]               s.copy$default$2[T])
[info]         }
[info]         new $anon():
[info]           
[info]             it.unibo.dap.controller.Distributable[
[info]               it.unibo.dap.model.DAP.State[T], T]
[info]           
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Distributable$package:
[info]     it.unibo.dap.controller.Distributable$package =
[info]     new it.unibo.dap.controller.Distributable$package()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     final module class Distributable$package() extends Object() {
[info]     this: it.unibo.dap.controller.Distributable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Distributable$package.type])
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type DistributableState[Message >: Nothing <: Any] =
[info]       [State >: Nothing <: Any] =>>
[info]         it.unibo.dap.controller.Distributable[State, Message]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.utils.{ReadableChannel, SendableChannel, Spawnable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala")
[info]      @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ExchangeComponent[T >: Nothing <: Any]() extends Object {
[info]     ctx: it.unibo.dap.controller.NeighborhoodResolverComponent =>
[info]     T
[info]     type Configuration >: Nothing <: Any
[info]     val exchange: ExchangeComponent.this.Exchange
[info]     trait Exchange() extends Object,
[info]       it.unibo.dap.utils.Spawnable[ExchangeComponent.this.Configuration], 
[info]       AutoCloseable {
[info]       def inputs: it.unibo.dap.utils.ReadableChannel[ExchangeComponent.this.T]
[info]       def outputs: it.unibo.dap.utils.SendableChannel[ExchangeComponent.this.T]
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait NeighborhoodResolverComponent() extends Object {
[info]     type Neighbor >: Nothing <: Any
[info]     type Neighborhood = Set[NeighborhoodResolverComponent.this.Neighbor]
[info]     val neighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver
[info]     trait NeighborhoodResolver() extends Object, (() =>
[info]       NeighborhoodResolverComponent.this.Neighborhood) {}
[info]     final lazy module val NeighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver =
[info]       new NeighborhoodResolverComponent.this.NeighborhoodResolver()
[info]     final module class NeighborhoodResolver() extends Object() {
[info]       this:
[info]         it.unibo.dap.controller.NeighborhoodResolverComponent.this.
[info]           NeighborhoodResolver.type
[info]        =>
[info]       def static(neighborhood: NeighborhoodResolverComponent.this.Neighborhood)
[info]         : NeighborhoodResolverComponent.this.NeighborhoodResolver = () =>
[info]         neighborhood
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     case class SerDe[T >: Nothing <: Any](serialize: T => Array[Byte],
[info]     deserialize: Array[Byte] => T) extends Object(), _root_.scala.Product,
[info]     _root_.scala.Serializable {
[info]     override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]     override def equals(x$0: Any): Boolean =
[info]       this.eq(x$0.$asInstanceOf[Object]).||(
[info]         x$0 match 
[info]           {
[info]             case x$0 @ _:it.unibo.dap.controller.SerDe[T] @unchecked =>
[info]               this.serialize.==(x$0.serialize).&&(
[info]                 this.deserialize.==(x$0.deserialize)).&&(x$0.canEqual(this))
[info]             case _ => false
[info]           }
[info]       )
[info]     override def toString(): String = scala.runtime.ScalaRunTime._toString(this)
[info]     override def canEqual(that: Any): Boolean =
[info]       that.isInstanceOf[it.unibo.dap.controller.SerDe[T] @unchecked]
[info]     override def productArity: Int = 2
[info]     override def productPrefix: String = "SerDe"
[info]     override def productElement(n: Int): Any =
[info]       n match 
[info]         {
[info]           case 0 => this._1
[info]           case 1 => this._2
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     override def productElementName(n: Int): String =
[info]       n match 
[info]         {
[info]           case 0 => "serialize"
[info]           case 1 => "deserialize"
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     T
[info]     val serialize: T => Array[Byte]
[info]     val deserialize: Array[Byte] => T
[info]     def copy[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def copy$default$1[T]: T => Array[Byte] = SerDe.this.serialize
[info]     def copy$default$2[T]: Array[Byte] => T = SerDe.this.deserialize
[info]     def _1: T => Array[Byte] = this.serialize
[info]     def _2: Array[Byte] => T = this.deserialize
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerDe: it.unibo.dap.controller.SerDe =
[info]     new it.unibo.dap.controller.SerDe()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerDe() extends AnyRef(), scala.deriving.Mirror.Product {
[info]      this: it.unibo.dap.controller.SerDe.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerDe.type])
[info]     def apply[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def unapply[T](x$1: it.unibo.dap.controller.SerDe[T]):
[info]       it.unibo.dap.controller.SerDe[T] = x$1
[info]     override def toString: String = "SerDe"
[info]     type MirroredMonoType = it.unibo.dap.controller.SerDe[? <: AnyKind]
[info]     def fromProduct(x$0: Product):
[info]       it.unibo.dap.controller.SerDe.MirroredMonoType =
[info]       new it.unibo.dap.controller.SerDe[Any](
[info]         x$0.productElement(0).$asInstanceOf[Any => Array[Byte]],
[info]         x$0.productElement(1).$asInstanceOf[Array[Byte] => Any])
[info]   }
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Serializable[T >: Nothing <: Any]() extends Object {
[info]     T
[info]     def serialize(t: Serializable.this.T): Array[Byte]
[info]     def deserialize(bytes: Array[Byte]): Serializable.this.T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Serializable: it.unibo.dap.controller.Serializable =
[info]     new it.unibo.dap.controller.Serializable()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Serializable() extends Object() {
[info]     this: it.unibo.dap.controller.Serializable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Serializable.type])
[info]     def serialize[T >: Nothing <: Any](t: T)(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): Array[Byte] = s.serialize(t)
[info]     def deserialize[T >: Nothing <: Any](t: Array[Byte])(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): T = s.deserialize(t)
[info]     def from[T >: Nothing <: Any](serializer: T => Array[Byte],
[info]       deserializer: Array[Byte] => T): it.unibo.dap.controller.Serializable[T]
[info]        =
[info]       it.unibo.dap.controller.Serializable.asSerializable[T](
[info]         it.unibo.dap.controller.SerDe.apply[T](serializer, deserializer))
[info]     extension [T >: Nothing <: Any](serde: it.unibo.dap.controller.SerDe[T])
[info]       def asSerializable: it.unibo.dap.controller.Serializable[T] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Serializable[T] {
[info]           override def serialize(t: T): Array[Byte] = serde.serialize.apply(t)
[info]           override def deserialize(bytes: Array[Byte]): T =
[info]             serde.deserialize.apply(bytes)
[info]         }
[info]         new $anon():it.unibo.dap.controller.Serializable[T]
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerializableInstances:
[info]     it.unibo.dap.controller.SerializableInstances =
[info]     new it.unibo.dap.controller.SerializableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerializableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.SerializableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerializableInstances.type])
[info]     final lazy module given val given_Serializable_String:
[info]       it.unibo.dap.controller.SerializableInstances.given_Serializable_String =
[info]       new 
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String(
[info]         )
[info]     final module class given_Serializable_String() extends Object(), 
[info]       it.unibo.dap.controller.Serializable[String] {
[info]       this:
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String.
[info]           type
[info]        =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[
[info]             it.unibo.dap.controller.SerializableInstances.
[info]               given_Serializable_String.type
[info]           ]
[info]         )
[info]       override def serialize(t: String): Array[Byte] = t.getBytes()
[info]       override def deserialize(bytes: Array[Byte]): String = new String(bytes)
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait CTMC[S >: Nothing <: Any]() extends Object {
[info]     S
[info]     import it.unibo.dap.model.CTMC.Action
[info]     def transitions(a: CTMC.this.S):
[info]       Set[it.unibo.dap.model.CTMC.Action[CTMC.this.S]]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMC: it.unibo.dap.model.CTMC =
[info]     new it.unibo.dap.model.CTMC()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMC() extends Object() {
[info]     this: it.unibo.dap.model.CTMC.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.CTMC.type])
[info]     case class Transition[S >: Nothing <: Any](state: S,
[info]       action: it.unibo.dap.model.CTMC.Action[S]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Transition[S] @unchecked =>
[info]                 this.state.==(x$0.state).&&(this.action.==(x$0.action)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Transition[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Transition"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "state"
[info]             case 1 => "action"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val state: S
[info]       val action: it.unibo.dap.model.CTMC.Action[S]
[info]       def copy[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def copy$default$1[S]: S = Transition.this.state
[info]       def copy$default$2[S]: it.unibo.dap.model.CTMC.Action[S] =
[info]         Transition.this.action
[info]       def _1: S = this.state
[info]       def _2: it.unibo.dap.model.CTMC.Action[S] = this.action
[info]     }
[info]     final lazy module val Transition: it.unibo.dap.model.CTMC.Transition =
[info]       new it.unibo.dap.model.CTMC.Transition()
[info]     final module class Transition() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.CTMC.Transition.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Transition.type])
[info]       def apply[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Transition[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] = x$1
[info]       override def toString: String = "Transition"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Transition[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Transition.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Transition[Any](x$0.productElement(0),
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.CTMC.Action[Any]]
[info]         )
[info]     }
[info]     case class Action[S >: Nothing <: Any](rate: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Action.this.rate))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Action.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Action[S] @unchecked =>
[info]                 this.rate.==(x$0.rate).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Action[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Action"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "rate"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val rate: Double
[info]       val state: S
[info]       def copy[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Action.this.rate
[info]       def copy$default$2[S]: S = Action.this.state
[info]       def _1: Double = this.rate
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Action: it.unibo.dap.model.CTMC.Action =
[info]       new it.unibo.dap.model.CTMC.Action()
[info]     final module class Action() extends AnyRef(), scala.deriving.Mirror.Product
[info]        { this: it.unibo.dap.model.CTMC.Action.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Action.type])
[info]       def apply[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Action[S] = x$1
[info]       override def toString: String = "Action"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Action[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Action.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Action[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Seq[it.unibo.dap.model.CTMC.Transition[S]] @Repeated):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofTransitions[S](
[info]         rels.toSet[it.unibo.dap.model.CTMC.Transition[S]])
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Set[it.unibo.dap.model.CTMC.Transition[S]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofFunction[S]((s: S) =>
[info]         rels.filter((_$1: it.unibo.dap.model.CTMC.Transition[S]) =>
[info]           _$1.state.==(s)).map[it.unibo.dap.model.CTMC.Action[S]]((
[info]           _$2: it.unibo.dap.model.CTMC.Transition[S]) => _$2.action)
[info]       )
[info]     def ofFunction[S >: Nothing <: Any](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] = (s: S) =>
[info]       {
[info]         f.applyOrElse[S, Set[it.unibo.dap.model.CTMC.Action[S]]](s, (_$3: S) =>
[info]           Set.apply[it.unibo.dap.model.CTMC.Action[S]](
[info]             [ : it.unibo.dap.model.CTMC.Action[S]]*)
[info]         )
[info]       }
[info]     final lazy module given val given_Simulatable_CTMC:
[info]       it.unibo.dap.model.CTMC.given_Simulatable_CTMC =
[info]       new it.unibo.dap.model.CTMC.given_Simulatable_CTMC()
[info]     final module class given_Simulatable_CTMC() extends Object(), 
[info]       it.unibo.dap.model.Simulatable[CTMC] {
[info]       this: it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type])
[info]       import java.util.Random
[info]       extension [S >: Nothing <: Any](self: it.unibo.dap.model.CTMC[S])
[info]         override def simulate(initialState: S)(using rnd: java.util.Random):
[info]         it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Trace[S] =
[info]         LazyList.iterate[it.unibo.dap.model.Simulatable.Event[S]](
[info]           it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](0.0d,
[info]             initialState)
[info]         )((x$1: it.unibo.dap.model.Simulatable.Event[S]) =>
[info]           x$1 match 
[info]             {
[info]               case 
[info]                 it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.unapply[S](
[info]                   t @ _, s @ _)
[info]                =>
[info]                 if self.transitions(s).isEmpty then
[info]                   it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](
[info]                     t, s)
[info]                  else 
[info]                   {
[info]                     val choices: Set[(Double, S)] =
[info]                       self.transitions(s).map[(Double, S)]((
[info]                         t: it.unibo.dap.model.CTMC.Action[S]) =>
[info]                         Tuple2.apply[Double, S](t.rate, t.state))
[info]                     val next: List[(Double, S)] =
[info]                       it.unibo.dap.model.Stochastics.cumulative[S](
[info]                         choices.toList)
[info]                     val sumR: Double = next.last._1
[info]                     val choice: S =
[info]                       it.unibo.dap.model.Stochastics.draw[S](next)(using
[info]                         it.unibo.dap.model.Stochastics.draw$default$2[S](next))
[info]                     it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S
[info]                       ](t.+(Math.log(1./(rnd.nextDouble()))./(sumR)), choice)
[info]                   }
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala
[info] package it.unibo.dap.controller {
[info]   import java.util.Random
[info]   import java.util.concurrent.atomic.AtomicBoolean
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import scala.language.experimental.betterFors
[info]   import scala.concurrent.duration.DurationDouble
[info]   import it.unibo.dap.utils.{unit, Async}
[info]   import it.unibo.dap.model.Simulatable.Event
[info]   import it.unibo.dap.model.Simulatable
[info]   import scala.util.Failure
[info]   import scala.util.Success
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala")
[info]     @experimental(
[info]     
[info]       "Added by top level \u001b[33mimport \u001b[0mscala.language.experimental.betterFors"
[info]       
[info]   ) trait Simulation[B[_ >: Nothing <: Any] >: Nothing <: Any,
[info]     T >: Nothing <: Any, S >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Simulatable[B],
[info]     evidence$2: it.unibo.dap.controller.DistributableState[T][S]) extends Object
[info]      { ctx: it.unibo.dap.controller.ExchangeComponent[Simulation.this.T] =>
[info]     B[_$1]
[info]     T
[info]     S
[info]     private[this] given val evidence$1: it.unibo.dap.model.Simulatable[B]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.DistributableState[T][S]
[info]     type SimulationError = String
[info]     def initial: Simulation.this.S
[info]     def behavior: Simulation.this.B[Simulation.this.S]
[info]     private[this] val isRunning: java.util.concurrent.atomic.AtomicBoolean =
[info]       new java.util.concurrent.atomic.AtomicBoolean(false)
[info]     def stop(): Either[Simulation.this.SimulationError, Unit] =
[info]       Either.cond[String, Unit](this.isRunning.compareAndSet(true, false), (),
[info]         "Simulation is not running.").map[Unit]((_$2: Unit) =>
[info]         this.exchange.close())
[info]     def launch(conf: this.Configuration)(updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       if this.isRunning.compareAndSet(false, true) then
[info]         {
[info]           val tasks: List[scala.concurrent.Future[Unit]] =
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.loop(this.initial, updateFn)(x$3)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.exchange.spawn(conf)(x$3)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           it.unibo.dap.utils.unit[List[Unit]](
[info]             scala.concurrent.Future.sequence[Unit, List, List[Unit]](tasks)(
[info]               scala.collection.BuildFrom.buildFromIterableOps[List,
[info]                 scala.concurrent.Future[Unit], Unit],
[info]             x$3).andThen[Unit]((x$1: scala.util.Try[List[Unit]]) =>
[info]               x$1 match 
[info]                 {
[info]                   case 
[info]                     scala.util.Failure.unapply[List[Unit]](e @ _):
[info]                       scala.util.Failure[List[Unit]]
[info]                    =>
[info]                     scribe.package.error(
[info]                       [scribe.LogFeature.throwable2LoggableMessage(e) :
[info]                         scribe.LogFeature]*
[info]                     )(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                   case 
[info]                     scala.util.Success.unapply[List[Unit]](_):
[info]                       scala.util.Success[List[Unit]]
[info]                    =>
[info]                     scribe.package.info("sim ended")(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                 }
[info]             )(x$3)
[info]           )(x$3)
[info]         }
[info]        else 
[info]         scala.concurrent.Future.failed[Nothing](
[info]           new IllegalStateException("Simulation is already running."))
[info]     private[this] def loop(state: Simulation.this.S, updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       {
[info]         val event: it.unibo.dap.model.Simulatable.Event[S] =
[info]           this.evidence$1.simulateStep[S](this.behavior)(state)(using
[info]             new java.util.Random())
[info]         it.unibo.dap.utils.Async.operations.sleep(
[info]           scala.concurrent.duration.DurationDouble(event.time).seconds).
[info]           withFilter((x$1: Unit) =>
[info]           x$1:Unit @unchecked match 
[info]             {
[info]               case _ => this.isRunning.get()
[info]             }
[info]         )(x$3).flatMap[Unit]((x$1: Unit) =>
[info]           x$1:(x$1 : Unit) @unchecked match 
[info]             {
[info]               case _ =>
[info]                 this.updateLogic(event, updateFn)(x$3).map[Unit]((x$1: Unit) =>
[info]                   x$1:Unit @unchecked match 
[info]                     {
[info]                       case _ => ()
[info]                     }
[info]                 )(x$3)
[info]             }
[info]         )(x$3)
[info]       }
[info]     private[this] def updateLogic(
[info]       event: it.unibo.dap.model.Simulatable.Event[Simulation.this.S],
[info]       updateFn: S => Unit)(using x$3: scala.concurrent.ExecutionContext):
[info]       scala.concurrent.Future[Unit] =
[info]       {
[info]         updateFn.apply(event.state)
[info]         this.evidence$2.msg(event.state).foreach[
[info]           Either[it.unibo.dap.utils.Channel.Error, Unit]](
[info]           {
[info]             val $1$: it.unibo.dap.utils.SendableChannel[T] =
[info]               this.exchange.outputs
[info]             (item: T) => $1$.push(item)
[info]           }
[info]         )
[info]         val in: Option[T] = this.exchange.inputs.poll()
[info]         val newState: S =
[info]           in.fold[S](event.state)((msg: T) =>
[info]             this.evidence$2.updated(event.state)(msg))
[info]         this.loop(newState, updateFn)(x$3)
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait CTMC[S >: Nothing <: Any]() extends Object {
[info]     S
[info]     import it.unibo.dap.model.CTMC.Action
[info]     def transitions(a: CTMC.this.S):
[info]       Set[it.unibo.dap.model.CTMC.Action[CTMC.this.S]]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMC: it.unibo.dap.model.CTMC =
[info]     new it.unibo.dap.model.CTMC()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMC() extends Object() {
[info]     this: it.unibo.dap.model.CTMC.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.CTMC.type])
[info]     case class Transition[S >: Nothing <: Any](state: S,
[info]       action: it.unibo.dap.model.CTMC.Action[S]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Transition[S] @unchecked =>
[info]                 this.state.==(x$0.state).&&(this.action.==(x$0.action)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Transition[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Transition"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "state"
[info]             case 1 => "action"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val state: S
[info]       val action: it.unibo.dap.model.CTMC.Action[S]
[info]       def copy[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def copy$default$1[S]: S = Transition.this.state
[info]       def copy$default$2[S]: it.unibo.dap.model.CTMC.Action[S] =
[info]         Transition.this.action
[info]       def _1: S = this.state
[info]       def _2: it.unibo.dap.model.CTMC.Action[S] = this.action
[info]     }
[info]     final lazy module val Transition: it.unibo.dap.model.CTMC.Transition =
[info]       new it.unibo.dap.model.CTMC.Transition()
[info]     final module class Transition() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.CTMC.Transition.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Transition.type])
[info]       def apply[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Transition[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] = x$1
[info]       override def toString: String = "Transition"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Transition[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Transition.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Transition[Any](x$0.productElement(0),
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.CTMC.Action[Any]]
[info]         )
[info]     }
[info]     case class Action[S >: Nothing <: Any](rate: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Action.this.rate))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Action.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Action[S] @unchecked =>
[info]                 this.rate.==(x$0.rate).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Action[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Action"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "rate"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val rate: Double
[info]       val state: S
[info]       def copy[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Action.this.rate
[info]       def copy$default$2[S]: S = Action.this.state
[info]       def _1: Double = this.rate
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Action: it.unibo.dap.model.CTMC.Action =
[info]       new it.unibo.dap.model.CTMC.Action()
[info]     final module class Action() extends AnyRef(), scala.deriving.Mirror.Product
[info]        { this: it.unibo.dap.model.CTMC.Action.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Action.type])
[info]       def apply[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Action[S] = x$1
[info]       override def toString: String = "Action"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Action[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Action.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Action[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Seq[it.unibo.dap.model.CTMC.Transition[S]] @Repeated):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofTransitions[S](
[info]         rels.toSet[it.unibo.dap.model.CTMC.Transition[S]])
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Set[it.unibo.dap.model.CTMC.Transition[S]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofFunction[S]((s: S) =>
[info]         rels.filter((_$1: it.unibo.dap.model.CTMC.Transition[S]) =>
[info]           _$1.state.==(s)).map[it.unibo.dap.model.CTMC.Action[S]]((
[info]           _$2: it.unibo.dap.model.CTMC.Transition[S]) => _$2.action)
[info]       )
[info]     def ofFunction[S >: Nothing <: Any](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] = (s: S) =>
[info]       {
[info]         f.applyOrElse[S, Set[it.unibo.dap.model.CTMC.Action[S]]](s, (_$3: S) =>
[info]           Set.apply[it.unibo.dap.model.CTMC.Action[S]](
[info]             [ : it.unibo.dap.model.CTMC.Action[S]]*)
[info]         )
[info]       }
[info]     final lazy module given val given_Simulatable_CTMC:
[info]       it.unibo.dap.model.CTMC.given_Simulatable_CTMC =
[info]       new it.unibo.dap.model.CTMC.given_Simulatable_CTMC()
[info]     final module class given_Simulatable_CTMC() extends Object(), 
[info]       it.unibo.dap.model.Simulatable[CTMC] {
[info]       this: it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type])
[info]       import java.util.Random
[info]       extension [S >: Nothing <: Any](self: it.unibo.dap.model.CTMC[S])
[info]         override def simulate(initialState: S)(using rnd: java.util.Random):
[info]         it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Trace[S] =
[info]         LazyList.iterate[it.unibo.dap.model.Simulatable.Event[S]](
[info]           it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](0.0d,
[info]             initialState)
[info]         )((x$1: it.unibo.dap.model.Simulatable.Event[S]) =>
[info]           x$1 match 
[info]             {
[info]               case 
[info]                 it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.unapply[S](
[info]                   t @ _, s @ _)
[info]                =>
[info]                 if self.transitions(s).isEmpty then
[info]                   it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](
[info]                     t, s)
[info]                  else 
[info]                   {
[info]                     val choices: Set[(Double, S)] =
[info]                       self.transitions(s).map[(Double, S)]((
[info]                         t: it.unibo.dap.model.CTMC.Action[S]) =>
[info]                         Tuple2.apply[Double, S](t.rate, t.state))
[info]                     val next: List[(Double, S)] =
[info]                       it.unibo.dap.model.Stochastics.cumulative[S](
[info]                         choices.toList)
[info]                     val sumR: Double = next.last._1
[info]                     val choice: S =
[info]                       it.unibo.dap.model.Stochastics.draw[S](next)(using
[info]                         it.unibo.dap.model.Stochastics.draw$default$2[S](next))
[info]                     it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S
[info]                       ](t.+(Math.log(1./(rnd.nextDouble()))./(sumR)), choice)
[info]                   }
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala
[info] package it.unibo.dap.model {
[info]   import it.unibo.dap.model.CTMC.*
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DAP: it.unibo.dap.model.DAP =
[info]     new it.unibo.dap.model.DAP()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DAP() extends Object() {
[info]     this: it.unibo.dap.model.DAP.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.DAP.type])
[info]     case class Rule[T >: Nothing <: Any](pre: it.unibo.dap.model.MSet[T],
[info]       rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]       eff: it.unibo.dap.model.MSet[T], msg: Option[T]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.Rule[T] @unchecked =>
[info]                 this.pre.==(x$0.pre).&&(this.rateExp.==(x$0.rateExp)).&&(
[info]                   this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.Rule[T] @unchecked]
[info]       override def productArity: Int = 4
[info]       override def productPrefix: String = "Rule"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case 2 => this._3
[info]             case 3 => this._4
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "pre"
[info]             case 1 => "rateExp"
[info]             case 2 => "eff"
[info]             case 3 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val pre: it.unibo.dap.model.MSet[T]
[info]       val rateExp: it.unibo.dap.model.MSet[T] => Double
[info]       val eff: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = Rule.this.pre
[info]       def copy$default$2[T]: it.unibo.dap.model.MSet[T] => Double =
[info]         Rule.this.rateExp
[info]       def copy$default$3[T]: it.unibo.dap.model.MSet[T] = Rule.this.eff
[info]       def copy$default$4[T]: Option[T] = Rule.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.pre
[info]       def _2: it.unibo.dap.model.MSet[T] => Double = this.rateExp
[info]       def _3: it.unibo.dap.model.MSet[T] = this.eff
[info]       def _4: Option[T] = this.msg
[info]     }
[info]     final lazy module val Rule: it.unibo.dap.model.DAP.Rule =
[info]       new it.unibo.dap.model.DAP.Rule()
[info]     final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.DAP.Rule.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.Rule.type])
[info]       def apply[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.Rule[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] = x$1
[info]       override def toString: String = "Rule"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.Rule[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.Rule.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.Rule[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.MSet[Any] => Double],
[info]           x$0.productElement(2).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(3).$asInstanceOf[Option[Any]])
[info]     }
[info]     type DAP[T >: Nothing <: Any] = Set[it.unibo.dap.model.DAP.Rule[T]]
[info]     case class State[T >: Nothing <: Any](tokens: it.unibo.dap.model.MSet[T],
[info]       msg: Option[T]) extends Object(), _root_.scala.Product, _root_.scala.
[info]       Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.State[T] @unchecked =>
[info]                 this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.State[T] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "State"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "tokens"
[info]             case 1 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val tokens: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = State.this.tokens
[info]       def copy$default$2[T]: Option[T] = State.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.tokens
[info]       def _2: Option[T] = this.msg
[info]     }
[info]     final lazy module val State: it.unibo.dap.model.DAP.State =
[info]       new it.unibo.dap.model.DAP.State()
[info]     final module class State() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.DAP.State.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.State.type])
[info]       def apply[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.State[T]):
[info]         it.unibo.dap.model.DAP.State[T] = x$1
[info]       override def toString: String = "State"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.State[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.State.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.State[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[Option[Any]])
[info]     }
[info]     def apply[T >: Nothing <: Any](
[info]       rules: Seq[it.unibo.dap.model.DAP.Rule[T]] @Repeated)(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] =
[info]       rules.toSet[it.unibo.dap.model.DAP.Rule[T]]
[info]     def apply[T >: Nothing <: Any](rules: Set[it.unibo.dap.model.DAP.Rule[T]])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] = rules
[info]     def toCTMC[T >: Nothing <: Any](spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]] =
[info]       it.unibo.dap.model.CTMC.ofFunction[it.unibo.dap.model.DAP.State[T]](
[info]         it.unibo.dap.model.DAP.toPartialFunction[T](spn)(evidence$1))
[info]     private[this] def toPartialFunction[T >: Nothing <: Any](
[info]       spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       PartialFunction[it.unibo.dap.model.DAP.State[T],
[info]         Set[it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]]
[info]      = (x$1: it.unibo.dap.model.DAP.State[T]) =>
[info]       x$1 match 
[info]         {
[info]           case it.unibo.dap.model.DAP.State.unapply[T](tokens @ _, _) =>
[info]             spn.flatMap[
[info]               it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]((
[info]               x$1: it.unibo.dap.model.DAP.Rule[T]) =>
[info]               x$1:it.unibo.dap.model.DAP.Rule[T] @unchecked match 
[info]                 {
[info]                   case 
[info]                     it.unibo.dap.model.DAP.Rule.unapply[T](pre @ _,
[info]                       rateExp @ _, eff @ _, msg @ _)
[info]                    =>
[info]                     tokens.extract(pre)(evidence$1).map[
[info]                       
[info]                         it.unibo.dap.model.CTMC.Action[
[info]                           it.unibo.dap.model.DAP.State[T]]
[info]                       
[info]                     ]((out: it.unibo.dap.model.MSet[T]) =>
[info]                       {
[info]                         val newtokens: it.unibo.dap.model.MSet[T] =
[info]                           out.union(eff)
[info]                         val rate: Double = rateExp.apply(tokens)
[info]                         it.unibo.dap.model.CTMC.Action.apply[
[info]                           it.unibo.dap.model.DAP.State[T]](rate,
[info]                           it.unibo.dap.model.DAP.State.apply[T](newtokens, msg))
[info]                         }
[info]                     )
[info]                 }
[info]             )
[info]         }
[info]     final given def given_Conversion_DAP_CTMC[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       Conversion[it.unibo.dap.model.DAP.DAP[T],
[info]         it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]]]
[info]      = (spn: it.unibo.dap.model.DAP.DAP[T]) =>
[info]       it.unibo.dap.model.DAP.toCTMC[T](spn)(evidence$1)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Equatable[T >: Nothing <: Any]() extends Object, ((T, T) => Boolean) {
[info]     T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable: it.unibo.dap.model.Equatable =
[info]     new it.unibo.dap.model.Equatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Equatable() extends Object() {
[info]     this: it.unibo.dap.model.Equatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable.type])
[info]     def apply[T >: Nothing <: Any](using x$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.Equatable[T] = x$1
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable$package:
[info]     it.unibo.dap.model.Equatable$package =
[info]     new it.unibo.dap.model.Equatable$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     final module class Equatable$package() extends Object() {
[info]     this: it.unibo.dap.model.Equatable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable$package.type])
[info]     extension [T >: Nothing <: Any](t1: T)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def ===
[info]     (t2: T)(using eq: it.unibo.dap.model.Equatable[T]): Boolean =
[info]       eq.apply(t1, t2)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait MSet[A >: Nothing <: Any]() extends Object, (A => Int) {
[info]     A
[info]     def union(m: it.unibo.dap.model.MSet[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def diff(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def matches(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]): Boolean
[info]     def extract(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       Option[it.unibo.dap.model.MSet[MSet.this.A]]
[info]     def map[B >: Nothing <: Any](f: A => B): it.unibo.dap.model.MSet[B]
[info]     def flatMap[B >: Nothing <: Any](f: A => it.unibo.dap.model.MSet[B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def filter(f: A => Boolean): it.unibo.dap.model.MSet[MSet.this.A]
[info]     def collect[B >: Nothing <: Any](f: PartialFunction[MSet.this.A, B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def size: Int
[info]     def asList: List[MSet.this.A]
[info]     def asMap: Map[MSet.this.A, Int]
[info]     def iterator: Iterator[MSet.this.A]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSet: it.unibo.dap.model.MSet =
[info]     new it.unibo.dap.model.MSet()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSet() extends Object() {
[info]     this: it.unibo.dap.model.MSet.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.MSet.type])
[info]     def apply[A >: Nothing <: Any](l: Seq[A] @Repeated):
[info]       it.unibo.dap.model.MSet[A] = new MSetImpl[A](l.toList)
[info]     def ofList[A >: Nothing <: Any](l: List[A]): it.unibo.dap.model.MSet[A] =
[info]       new MSetImpl[A](l)
[info]     def ofMap[A >: Nothing <: Any](m: Map[A, Int]): it.unibo.dap.model.MSet[A]
[info]        = it.unibo.dap.model.MSet.MSetImpl.apply[A](m)
[info]     import scala.collection.immutable
[info]     private[this] case class MSetImpl[A >: Nothing <: Any](asMap: Map[A, Int])
[info]        extends Object(), it.unibo.dap.model.MSet[MSetImpl.this.A],
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.MSet.MSetImpl[A] @unchecked =>
[info]                 this.asMap.==(x$0.asMap).&&(x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.MSet.MSetImpl[A] @unchecked]
[info]       override def productArity: Int = 1
[info]       override def productPrefix: String = "MSetImpl"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "asMap"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       A
[info]       val asMap: Map[A, Int]
[info]       def <init>[A >: Nothing <: Any](list: List[A]): Unit =
[info]         {
[info]           this[A](
[info]             list.groupBy[A]((a: A) => a).map[A, Int]((x$1: (A, List[A])) =>
[info]               x$1 match 
[info]                 {
[info]                   case Tuple2.unapply[A, List[A]](a @ _, n @ _) =>
[info]                     Tuple2.apply[A, Int](a, n.size)
[info]                 }
[info]             )
[info]           )
[info]           ()
[info]         }
[info]       override val asList: List[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.toList.flatMap[A]((x$1: (A, Int)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[A, Int](a @ _, n @ _) =>
[info]                 scala.collection.immutable.List.fill[A](n)(a)
[info]             }
[info]         )
[info]       override def apply(v1: MSetImpl.this.A): Int =
[info]         MSetImpl.this.asMap.getOrElse[Int](v1, 0)
[info]       override def union(m: it.unibo.dap.model.MSet[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.++[A](m.asList))
[info]       override def diff(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           m.asList.foldLeft[List[A]](this.asList)((acc: List[A], elem: A) =>
[info]             {
[info]               val index: Int =
[info]                 acc.indexWhere((_$1: A) =>
[info]                   it.unibo.dap.model.===[A](_$1)(elem)(x$2))
[info]               if index.>=(0) then acc.patch[A](index, Nil, 1) else acc
[info]             }
[info]           )
[info]         )
[info]       override def matches(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]): Boolean =
[info]         this.extract(m)(x$2).isDefined
[info]       override def extract(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         Option[it.unibo.dap.model.MSet[MSetImpl.this.A]] =
[info]         Some.apply[it.unibo.dap.model.MSet[A]](this.diff(m)(x$2)).filter((
[info]           _$2: it.unibo.dap.model.MSet[A]) => _$2.size.==(this.size.-(m.size)))
[info]       override def iterator: Iterator[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.keysIterator
[info]       override def map[B >: Nothing <: Any](f: A => B):
[info]         it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.map[B](f))
[info]       override def flatMap[B >: Nothing <: Any](
[info]         f: A => it.unibo.dap.model.MSet[B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](
[info]           this.asList.flatMap[B]((_$3: A) => f.apply(_$3).asList))
[info]       override def filter(f: A => Boolean): it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.filter(f))
[info]       override def collect[B >: Nothing <: Any](
[info]         f: PartialFunction[MSetImpl.this.A, B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.collect[B](f))
[info]       override def size: Int = this.asList.size
[info]       override def toString: String =
[info]         _root_.scala.StringContext.apply(["{","}" : String]*).s(
[info]           [this.asList.mkString("|") : Any]*)
[info]       def copy[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def copy$default$1[A]: Map[A, Int] = MSetImpl.this.asMap
[info]       def _1: Map[A, Int] = this.asMap
[info]     }
[info]     private[this] final lazy module val MSetImpl:
[info]       it.unibo.dap.model.MSet.MSetImpl = new it.unibo.dap.model.MSet.MSetImpl()
[info]     private[this] final module class MSetImpl() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.MSet.MSetImpl.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.MSet.MSetImpl.type])
[info]       def apply[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def unapply[A](x$1: it.unibo.dap.model.MSet.MSetImpl[A]):
[info]         it.unibo.dap.model.MSet.MSetImpl[A] = x$1
[info]       override def toString: String = "MSetImpl"
[info]       type MirroredMonoType = it.unibo.dap.model.MSet.MSetImpl[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.MSet.MSetImpl.MirroredMonoType =
[info]         new it.unibo.dap.model.MSet.MSetImpl[Any](
[info]           x$0.productElement(0).$asInstanceOf[Map[Any, Int]])
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala
[info] package it.unibo.dap.model {
[info]   import it.unibo.dap.model.CTMC.*
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DAP: it.unibo.dap.model.DAP =
[info]     new it.unibo.dap.model.DAP()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DAP() extends Object() {
[info]     this: it.unibo.dap.model.DAP.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.DAP.type])
[info]     case class Rule[T >: Nothing <: Any](pre: it.unibo.dap.model.MSet[T],
[info]       rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]       eff: it.unibo.dap.model.MSet[T], msg: Option[T]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.Rule[T] @unchecked =>
[info]                 this.pre.==(x$0.pre).&&(this.rateExp.==(x$0.rateExp)).&&(
[info]                   this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.Rule[T] @unchecked]
[info]       override def productArity: Int = 4
[info]       override def productPrefix: String = "Rule"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case 2 => this._3
[info]             case 3 => this._4
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "pre"
[info]             case 1 => "rateExp"
[info]             case 2 => "eff"
[info]             case 3 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val pre: it.unibo.dap.model.MSet[T]
[info]       val rateExp: it.unibo.dap.model.MSet[T] => Double
[info]       val eff: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = Rule.this.pre
[info]       def copy$default$2[T]: it.unibo.dap.model.MSet[T] => Double =
[info]         Rule.this.rateExp
[info]       def copy$default$3[T]: it.unibo.dap.model.MSet[T] = Rule.this.eff
[info]       def copy$default$4[T]: Option[T] = Rule.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.pre
[info]       def _2: it.unibo.dap.model.MSet[T] => Double = this.rateExp
[info]       def _3: it.unibo.dap.model.MSet[T] = this.eff
[info]       def _4: Option[T] = this.msg
[info]     }
[info]     final lazy module val Rule: it.unibo.dap.model.DAP.Rule =
[info]       new it.unibo.dap.model.DAP.Rule()
[info]     final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.DAP.Rule.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.Rule.type])
[info]       def apply[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.Rule[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] = x$1
[info]       override def toString: String = "Rule"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.Rule[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.Rule.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.Rule[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.MSet[Any] => Double],
[info]           x$0.productElement(2).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(3).$asInstanceOf[Option[Any]])
[info]     }
[info]     type DAP[T >: Nothing <: Any] = Set[it.unibo.dap.model.DAP.Rule[T]]
[info]     case class State[T >: Nothing <: Any](tokens: it.unibo.dap.model.MSet[T],
[info]       msg: Option[T]) extends Object(), _root_.scala.Product, _root_.scala.
[info]       Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.State[T] @unchecked =>
[info]                 this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.State[T] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "State"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "tokens"
[info]             case 1 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val tokens: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = State.this.tokens
[info]       def copy$default$2[T]: Option[T] = State.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.tokens
[info]       def _2: Option[T] = this.msg
[info]     }
[info]     final lazy module val State: it.unibo.dap.model.DAP.State =
[info]       new it.unibo.dap.model.DAP.State()
[info]     final module class State() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.DAP.State.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.State.type])
[info]       def apply[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.State[T]):
[info]         it.unibo.dap.model.DAP.State[T] = x$1
[info]       override def toString: String = "State"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.State[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.State.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.State[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[Option[Any]])
[info]     }
[info]     def apply[T >: Nothing <: Any](
[info]       rules: Seq[it.unibo.dap.model.DAP.Rule[T]] @Repeated)(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] =
[info]       rules.toSet[it.unibo.dap.model.DAP.Rule[T]]
[info]     def apply[T >: Nothing <: Any](rules: Set[it.unibo.dap.model.DAP.Rule[T]])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] = rules
[info]     def toCTMC[T >: Nothing <: Any](spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]] =
[info]       it.unibo.dap.model.CTMC.ofFunction[it.unibo.dap.model.DAP.State[T]](
[info]         it.unibo.dap.model.DAP.toPartialFunction[T](spn)(evidence$1))
[info]     private[this] def toPartialFunction[T >: Nothing <: Any](
[info]       spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       PartialFunction[it.unibo.dap.model.DAP.State[T],
[info]         Set[it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]]
[info]      = (x$1: it.unibo.dap.model.DAP.State[T]) =>
[info]       x$1 match 
[info]         {
[info]           case it.unibo.dap.model.DAP.State.unapply[T](tokens @ _, _) =>
[info]             spn.flatMap[
[info]               it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]((
[info]               x$1: it.unibo.dap.model.DAP.Rule[T]) =>
[info]               x$1:it.unibo.dap.model.DAP.Rule[T] @unchecked match 
[info]                 {
[info]                   case 
[info]                     it.unibo.dap.model.DAP.Rule.unapply[T](pre @ _,
[info]                       rateExp @ _, eff @ _, msg @ _)
[info]                    =>
[info]                     tokens.extract(pre)(evidence$1).map[
[info]                       
[info]                         it.unibo.dap.model.CTMC.Action[
[info]                           it.unibo.dap.model.DAP.State[T]]
[info]                       
[info]                     ]((out: it.unibo.dap.model.MSet[T]) =>
[info]                       {
[info]                         val newtokens: it.unibo.dap.model.MSet[T] =
[info]                           out.union(eff)
[info]                         val rate: Double = rateExp.apply(tokens)
[info]                         it.unibo.dap.model.CTMC.Action.apply[
[info]                           it.unibo.dap.model.DAP.State[T]](rate,
[info]                           it.unibo.dap.model.DAP.State.apply[T](newtokens, msg))
[info]                         }
[info]                     )
[info]                 }
[info]             )
[info]         }
[info]     final given def given_Conversion_DAP_CTMC[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       Conversion[it.unibo.dap.model.DAP.DAP[T],
[info]         it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]]]
[info]      = (spn: it.unibo.dap.model.DAP.DAP[T]) =>
[info]       it.unibo.dap.model.DAP.toCTMC[T](spn)(evidence$1)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Simulatable[M[_ >: Nothing <: Any] >: Nothing <: Any]() extends Object
[info]      {
[info]     M[_$1]
[info]     export it.unibo.dap.model.Simulatable.*
[info]     final def Event: it.unibo.dap.model.Simulatable.Event.type =
[info]       it.unibo.dap.model.Simulatable.Event
[info]     final type Event[S] = it.unibo.dap.model.Simulatable.Event[S]
[info]     final type Trace[S] = it.unibo.dap.model.Simulatable.Trace[S]
[info]     import java.util.Random
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S]) def simulate(
[info]       initialState: S)(using x$3: java.util.Random): Simulatable.this.Trace[S]
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S])
[info]       def simulateStep(s: S)(using x$3: java.util.Random):
[info]       Simulatable.this.Event[S] = this.simulate[S](self)(s)(x$3).drop(1).head
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Simulatable: it.unibo.dap.model.Simulatable =
[info]     new it.unibo.dap.model.Simulatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Simulatable() extends Object() {
[info]     this: it.unibo.dap.model.Simulatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Simulatable.type])
[info]     type Trace[S >: Nothing <: Any] =
[info]       LazyList[it.unibo.dap.model.Simulatable.Event[S]]
[info]     case class Event[S >: Nothing <: Any](time: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Event.this.time))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Event.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.Simulatable.Event[S] @unchecked
[info]                  =>
[info]                 this.time.==(x$0.time).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.Simulatable.Event[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Event"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "time"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val time: Double
[info]       val state: S
[info]       def copy[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Event.this.time
[info]       def copy$default$2[S]: S = Event.this.state
[info]       def _1: Double = this.time
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Event: it.unibo.dap.model.Simulatable.Event =
[info]       new it.unibo.dap.model.Simulatable.Event()
[info]     final module class Event() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.Simulatable.Event.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.Simulatable.Event.type])
[info]       def apply[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.Simulatable.Event[S]):
[info]         it.unibo.dap.model.Simulatable.Event[S] = x$1
[info]       override def toString: String = "Event"
[info]       type MirroredMonoType = it.unibo.dap.model.Simulatable.Event[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.Simulatable.Event.MirroredMonoType =
[info]         new it.unibo.dap.model.Simulatable.Event[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala
[info] package it.unibo.dap.model {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Stochastics: it.unibo.dap.model.Stochastics =
[info]     new it.unibo.dap.model.Stochastics()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Stochastics() extends Object() {
[info]     this: it.unibo.dap.model.Stochastics.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Stochastics.type])
[info]     import scala.util.Random
[info]     def cumulative[A >: Nothing <: Any](l: List[Tuple2[Double, A]]):
[info]       List[Tuple2[Double, A]] =
[info]       l.tail.scanLeft[(Double, A)](l.head)((x$1: (Double, A),
[info]         x$2: (Double, A) @uncheckedVariance) =>
[info]         Tuple2.apply[(Double, A), (Double, A) @uncheckedVariance](x$1, x$2)
[info]            match 
[info]           {
[info]             case 
[info]               Tuple2.unapply[(Double, A), (Double, A)](
[info]                 Tuple2.unapply[Double, A](r @ _, _),
[info]                 Tuple2.unapply[Double, A](r2 @ _, a2 @ _))
[info]              =>
[info]               Tuple2.apply[Double, A](r.+(r2), a2)
[info]           }
[info]       )
[info]     def draw[A >: Nothing <: Any](cumulativeList: List[Tuple2[Double, A]])(
[info]       using rnd: scala.util.Random): A =
[info]       {
[info]         val rndVal: Double = rnd.nextDouble().*(cumulativeList.last._1)
[info]         cumulativeList.collectFirst[A]((x$1: (Double, A)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[Double, A](r @ _, a @ _) if r.>=(rndVal) =>
[info]                 a:A
[info]             }
[info]         ).get
[info]       }
[info]     def draw$default$2[A >: Nothing <: Any](
[info]       cumulativeList: List[Tuple2[Double, A]]):
[info]       scala.util.Random @uncheckedVariance = new scala.util.Random()
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Equatable[T >: Nothing <: Any]() extends Object, ((T, T) => Boolean) {
[info]     T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable: it.unibo.dap.model.Equatable =
[info]     new it.unibo.dap.model.Equatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Equatable() extends Object() {
[info]     this: it.unibo.dap.model.Equatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable.type])
[info]     def apply[T >: Nothing <: Any](using x$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.Equatable[T] = x$1
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable$package:
[info]     it.unibo.dap.model.Equatable$package =
[info]     new it.unibo.dap.model.Equatable$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     final module class Equatable$package() extends Object() {
[info]     this: it.unibo.dap.model.Equatable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable$package.type])
[info]     extension [T >: Nothing <: Any](t1: T)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def ===
[info]     (t2: T)(using eq: it.unibo.dap.model.Equatable[T]): Boolean =
[info]       eq.apply(t1, t2)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMCDsl: it.unibo.dap.model.dsl.CTMCDsl =
[info]     new it.unibo.dap.model.dsl.CTMCDsl()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMCDsl() extends Object() {
[info]     this: it.unibo.dap.model.dsl.CTMCDsl.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.CTMCDsl.type])
[info]     export it.unibo.dap.model.CTMC
[info]     final def CTMC: it.unibo.dap.model.CTMC.type = it.unibo.dap.model.CTMC
[info]     final type CTMC[S] = it.unibo.dap.model.CTMC[S]
[info]     export it.unibo.dap.model.dsl.CTMCDsl.CTMC.*
[info]     final def ofFunction[S](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofFunction[S](f)
[info]     final def Transition: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition
[info]     final type Transition[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition[S]
[info]     final def Action: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action
[info]     final type Action[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action[S]
[info]     final def ofTransitions[S](rels: Set[it.unibo.dap.model.CTMC.Transition[S]])
[info]       : it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels)
[info]     final def ofTransitions[S](rels: it.unibo.dap.model.CTMC.Transition[S]*):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels*)
[info]     extension [S >: Nothing <: Any](state: S) def --(rate: Double):
[info]       Tuple2[S, Double] = Tuple2.apply[S, Double](state, rate)
[info]     extension [S >: Nothing <: Any](self: Tuple2[S, Double]) def -->(
[info]       finalState: S): it.unibo.dap.model.dsl.CTMCDsl.Transition[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.Transition.apply[S](self._1,
[info]         it.unibo.dap.model.dsl.CTMCDsl.Action.apply[S](self._2, finalState))
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSetDSL: it.unibo.dap.model.dsl.MSetDSL =
[info]     new it.unibo.dap.model.dsl.MSetDSL()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSetDSL() extends Object() {
[info]     this: it.unibo.dap.model.dsl.MSetDSL.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.MSetDSL.type])
[info]     export it.unibo.dap.model.MSet
[info]     final def MSet: it.unibo.dap.model.MSet.type = it.unibo.dap.model.MSet
[info]     final type MSet[A] = it.unibo.dap.model.MSet[A]
[info]     export it.unibo.dap.model.dsl.MSetDSL.given
[info]     extension [T >: Nothing <: Any](a: T) def |(b: T): List[T] =
[info]       List.apply[T]([a,b : T]*)
[info]     extension [T >: Nothing <: Any](xs: List[T]) def |(x: T): List[T] =
[info]       xs.:+[T](x)
[info]     final given def listSetConversion[T >: Nothing <: Any]:
[info]       Conversion[List[T], it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (
[info]       _$1: List[T]) => it.unibo.dap.model.dsl.MSetDSL.MSet.ofList[T](_$1)
[info]     final given def elemSetConversion[T >: Nothing <: Any]:
[info]       Conversion[T, it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (_$2: T) =>
[info]       it.unibo.dap.model.dsl.MSetDSL.MSet.apply[T]([_$2 : T]*)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.duration.FiniteDuration
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait AsyncOperations() extends Object {
[info]     def sleep(duration: scala.concurrent.duration.FiniteDuration):
[info]       scala.concurrent.Future[Unit]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Async: it.unibo.dap.utils.Async =
[info]     new it.unibo.dap.utils.Async()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Async() extends Object() {
[info]     this: it.unibo.dap.utils.Async.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Async.type])
[info]     def operations: it.unibo.dap.utils.AsyncOperations =
[info]       it.unibo.dap.utils.Platform.asyncOps
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{Future, Promise}
[info]   import scala.util.Try
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ReadableChannel[T >: Nothing <: Any]() extends Object {
[info]     +T
[info]     def poll(): Option[ReadableChannel.this.T]
[info]     def pop(): scala.concurrent.Future[ReadableChannel.this.T]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SendableChannel[T >: Nothing <: Any]() extends Object {
[info]     -T
[info]     def push(item: SendableChannel.this.T):
[info]       Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Channel[T >: Nothing <: Any]() extends Object,
[info]     it.unibo.dap.utils.ReadableChannel[Channel.this.T], it.unibo.dap.utils.
[info]     SendableChannel[Channel.this.T] {
[info]     T
[info]     def asReadable: it.unibo.dap.utils.ReadableChannel[Channel.this.T] = this
[info]     def asSendable: it.unibo.dap.utils.SendableChannel[Channel.this.T] = this
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Channel: it.unibo.dap.utils.Channel =
[info]     new it.unibo.dap.utils.Channel()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Channel() extends Object() {
[info]     this: it.unibo.dap.utils.Channel.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Channel.type])
[info]     type Error = String
[info]     def apply[T >: Nothing <: Any](): it.unibo.dap.utils.Channel[T] =
[info]       new it.unibo.dap.utils.Channel.ChannelImpl[T]()
[info]     def readable[T >: Nothing <: Any](): it.unibo.dap.utils.ReadableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Nothing]().asReadable
[info]     def sendable[T >: Nothing <: Any](): it.unibo.dap.utils.SendableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Any]().asSendable
[info]     private[this] class ChannelImpl[T >: Nothing <: Any]() extends Object(), 
[info]       it.unibo.dap.utils.Channel[ChannelImpl.this.T] {
[info]       T
[info]       private[this] var closed: Boolean = false
[info]       private[this] val buffer: scala.collection.mutable.Queue[T] =
[info]         scala.collection.mutable.Queue.empty[ChannelImpl.this.T]
[info]       private[this] val waiters:
[info]         scala.collection.mutable.Queue[scala.concurrent.Promise[T]] =
[info]         scala.collection.mutable.Queue.empty[
[info]           scala.concurrent.Promise[ChannelImpl.this.T]]
[info]       override def push(item: ChannelImpl.this.T):
[info]         Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing](
[info]               "Channel is closed. No more items can be pushed.")
[info]            else 
[info]             if this.waiters.nonEmpty then
[info]               it.unibo.dap.utils.unit[String, scala.concurrent.Promise[T]](
[info]                 scala.util.Try.apply[scala.concurrent.Promise[T]](
[info]                   this.waiters.dequeue().success(item)).toEither.left.map[String
[info]                   ]((_$1: Throwable) => _$1.getMessage())
[info]               )
[info]              else 
[info]               Right.apply[Nothing, Unit](
[info]                 {
[info]                   this.buffer.enqueue(item)
[info]                   ()
[info]                 }
[info]               )
[info]         )
[info]       override def pop(): scala.concurrent.Future[ChannelImpl.this.T] =
[info]         this.synchronized[scala.concurrent.Future[T]](
[info]           this.poll() match 
[info]             {
[info]               case Some.unapply[T](item @ _):Some[T] =>
[info]                 scala.concurrent.Future.successful[T](item)
[info]               case _ if this.closed =>
[info]                 scala.concurrent.Future.failed[Nothing](
[info]                   new NoSuchElementException(
[info]                     "Channel is closed and no items are available.")
[info]                 )
[info]               case _ =>
[info]                 val promise: scala.concurrent.Promise[T] =
[info]                   scala.concurrent.Promise.apply[ChannelImpl.this.T]()
[info]                 this.waiters.enqueue(promise)
[info]                 promise.future:scala.concurrent.Future[T]
[info]             }
[info]         )
[info]       override def poll(): Option[ChannelImpl.this.T] =
[info]         this.synchronized[Option[T]](
[info]           Option.when[T](this.buffer.nonEmpty)(this.buffer.dequeue()))
[info]       override def close(): Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing]("Channel is already closed.") else 
[info]             {
[info]               this.closed = true
[info]               this.waiters.foreach[scala.concurrent.Promise[T]]((
[info]                 _$2: scala.concurrent.Promise[T]) =>
[info]                 _$2.failure(new NoSuchElementException("Channel is closed.")))
[info]               this.waiters.clear()
[info]               Right.apply[Nothing, Unit](())
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait MSet[A >: Nothing <: Any]() extends Object, (A => Int) {
[info]     A
[info]     def union(m: it.unibo.dap.model.MSet[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def diff(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def matches(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]): Boolean
[info]     def extract(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       Option[it.unibo.dap.model.MSet[MSet.this.A]]
[info]     def map[B >: Nothing <: Any](f: A => B): it.unibo.dap.model.MSet[B]
[info]     def flatMap[B >: Nothing <: Any](f: A => it.unibo.dap.model.MSet[B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def filter(f: A => Boolean): it.unibo.dap.model.MSet[MSet.this.A]
[info]     def collect[B >: Nothing <: Any](f: PartialFunction[MSet.this.A, B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def size: Int
[info]     def asList: List[MSet.this.A]
[info]     def asMap: Map[MSet.this.A, Int]
[info]     def iterator: Iterator[MSet.this.A]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSet: it.unibo.dap.model.MSet =
[info]     new it.unibo.dap.model.MSet()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSet() extends Object() {
[info]     this: it.unibo.dap.model.MSet.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.MSet.type])
[info]     def apply[A >: Nothing <: Any](l: Seq[A] @Repeated):
[info]       it.unibo.dap.model.MSet[A] = new MSetImpl[A](l.toList)
[info]     def ofList[A >: Nothing <: Any](l: List[A]): it.unibo.dap.model.MSet[A] =
[info]       new MSetImpl[A](l)
[info]     def ofMap[A >: Nothing <: Any](m: Map[A, Int]): it.unibo.dap.model.MSet[A]
[info]        = it.unibo.dap.model.MSet.MSetImpl.apply[A](m)
[info]     import scala.collection.immutable
[info]     private[this] case class MSetImpl[A >: Nothing <: Any](asMap: Map[A, Int])
[info]        extends Object(), it.unibo.dap.model.MSet[MSetImpl.this.A],
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.MSet.MSetImpl[A] @unchecked =>
[info]                 this.asMap.==(x$0.asMap).&&(x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.MSet.MSetImpl[A] @unchecked]
[info]       override def productArity: Int = 1
[info]       override def productPrefix: String = "MSetImpl"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "asMap"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       A
[info]       val asMap: Map[A, Int]
[info]       def <init>[A >: Nothing <: Any](list: List[A]): Unit =
[info]         {
[info]           this[A](
[info]             list.groupBy[A]((a: A) => a).map[A, Int]((x$1: (A, List[A])) =>
[info]               x$1 match 
[info]                 {
[info]                   case Tuple2.unapply[A, List[A]](a @ _, n @ _) =>
[info]                     Tuple2.apply[A, Int](a, n.size)
[info]                 }
[info]             )
[info]           )
[info]           ()
[info]         }
[info]       override val asList: List[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.toList.flatMap[A]((x$1: (A, Int)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[A, Int](a @ _, n @ _) =>
[info]                 scala.collection.immutable.List.fill[A](n)(a)
[info]             }
[info]         )
[info]       override def apply(v1: MSetImpl.this.A): Int =
[info]         MSetImpl.this.asMap.getOrElse[Int](v1, 0)
[info]       override def union(m: it.unibo.dap.model.MSet[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.++[A](m.asList))
[info]       override def diff(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           m.asList.foldLeft[List[A]](this.asList)((acc: List[A], elem: A) =>
[info]             {
[info]               val index: Int =
[info]                 acc.indexWhere((_$1: A) =>
[info]                   it.unibo.dap.model.===[A](_$1)(elem)(x$2))
[info]               if index.>=(0) then acc.patch[A](index, Nil, 1) else acc
[info]             }
[info]           )
[info]         )
[info]       override def matches(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]): Boolean =
[info]         this.extract(m)(x$2).isDefined
[info]       override def extract(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         Option[it.unibo.dap.model.MSet[MSetImpl.this.A]] =
[info]         Some.apply[it.unibo.dap.model.MSet[A]](this.diff(m)(x$2)).filter((
[info]           _$2: it.unibo.dap.model.MSet[A]) => _$2.size.==(this.size.-(m.size)))
[info]       override def iterator: Iterator[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.keysIterator
[info]       override def map[B >: Nothing <: Any](f: A => B):
[info]         it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.map[B](f))
[info]       override def flatMap[B >: Nothing <: Any](
[info]         f: A => it.unibo.dap.model.MSet[B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](
[info]           this.asList.flatMap[B]((_$3: A) => f.apply(_$3).asList))
[info]       override def filter(f: A => Boolean): it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.filter(f))
[info]       override def collect[B >: Nothing <: Any](
[info]         f: PartialFunction[MSetImpl.this.A, B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.collect[B](f))
[info]       override def size: Int = this.asList.size
[info]       override def toString: String =
[info]         _root_.scala.StringContext.apply(["{","}" : String]*).s(
[info]           [this.asList.mkString("|") : Any]*)
[info]       def copy[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def copy$default$1[A]: Map[A, Int] = MSetImpl.this.asMap
[info]       def _1: Map[A, Int] = this.asMap
[info]     }
[info]     private[this] final lazy module val MSetImpl:
[info]       it.unibo.dap.model.MSet.MSetImpl = new it.unibo.dap.model.MSet.MSetImpl()
[info]     private[this] final module class MSetImpl() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.MSet.MSetImpl.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.MSet.MSetImpl.type])
[info]       def apply[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def unapply[A](x$1: it.unibo.dap.model.MSet.MSetImpl[A]):
[info]         it.unibo.dap.model.MSet.MSetImpl[A] = x$1
[info]       override def toString: String = "MSetImpl"
[info]       type MirroredMonoType = it.unibo.dap.model.MSet.MSetImpl[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.MSet.MSetImpl.MirroredMonoType =
[info]         new it.unibo.dap.model.MSet.MSetImpl[Any](
[info]           x$0.productElement(0).$asInstanceOf[Map[Any, Int]])
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala
[info] package it.unibo.dap.utils {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Iso[A >: Nothing <: Any, B >: Nothing <: Any]() extends Object {
[info]     A
[info]     B
[info]     def to(a: Iso.this.A): Iso.this.B
[info]     def from(b: Iso.this.B): Iso.this.A
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso: it.unibo.dap.utils.Iso =
[info]     new it.unibo.dap.utils.Iso()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Iso() extends Object() {
[info]     this: it.unibo.dap.utils.Iso.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso.type])
[info]     inline def apply[A >: Nothing <: Any, B >: Nothing <: Any](toFn: A => B,
[info]       fromFn: B => A): it.unibo.dap.utils.Iso[A, B] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.utils.Iso[A, B] {
[info]           def to(a: A): B = toFn.apply(a)
[info]           def from(b: B): A = fromFn.apply(b)
[info]         }
[info]         new $anon():it.unibo.dap.utils.Iso[A, B]
[info]       }:it.unibo.dap.utils.Iso[A, B]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso$package: it.unibo.dap.utils.Iso$package =
[info]     new it.unibo.dap.utils.Iso$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala") final
[info]     module class Iso$package() extends Object() {
[info]     this: it.unibo.dap.utils.Iso$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso$package.type])
[info]     extension [A >: Nothing <: Any](a: A)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def as
[info]     [B >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]       iso.to(a)
[info]     extension [B >: Nothing <: Any](b: B)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def back
[info]     [A >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]       iso.from(b)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Task[T >: Nothing <: Any]() extends Object, (() =>
[info]     scala.concurrent.Future[T]) {
[info]     T
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Spawnable[Configuration >: Nothing <: Any]() extends Object {
[info]     Configuration
[info]     def spawn(configuration: Spawnable.this.Configuration)(using 
[info]       x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait PlainSpawnable() extends Object, it.unibo.dap.utils.Spawnable[Unit] {}
[info]   }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala
[info] package it.unibo.dap.utils {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val TimeOps: it.unibo.dap.utils.TimeOps =
[info]     new it.unibo.dap.utils.TimeOps()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class TimeOps() extends Object() {
[info]     this: it.unibo.dap.utils.TimeOps.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.TimeOps.type])
[info]     def timed[A >: Nothing <: Any](input: => A): A =
[info]       {
[info]         val t0: Long = java.lang.System.nanoTime()
[info]         try input finally 
[info]           scribe.package.info(
[info]             "Timed op (msec): ".+(java.lang.System.nanoTime().-(t0)./(1000000)))
[info]             (sourcecode.Pkg.apply("it.unibo.dap.utils"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("TimeOps.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("timed"):sourcecode.Name,
[info]             sourcecode.Line.apply(9):sourcecode.Line, scribe.mdc.MDC.instance)
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.ExecutionContext
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Utils$package: it.unibo.dap.utils.Utils$package =
[info]     new it.unibo.dap.utils.Utils$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala") final
[info]     module class Utils$package() extends Object() {
[info]     this: it.unibo.dap.utils.Utils$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Utils$package.type])
[info]     extension [L >: Nothing <: Any, R >: Nothing <: Any](e: Either[L, R])
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : Either[L, Unit] = e.map[Unit]((_$1: R) => ())
[info]     extension [T >: Nothing <: Any](f: scala.concurrent.Future[T])(using 
[info]       x$2: scala.concurrent.ExecutionContext)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : scala.concurrent.Future[Unit] = f.map[Unit]((_$2: T) => ())(x$2)
[info]   }
[info] }
[warn] -- [E198] Unused Symbol Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:27:20 
[warn] 27 |        private val acceptLoop = Future:
[warn]    |                    ^^^^^^^^^^
[warn]    |                    unused private member
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Simulatable[M[_ >: Nothing <: Any] >: Nothing <: Any]() extends Object
[info]      {
[info]     M[_$1]
[info]     export it.unibo.dap.model.Simulatable.*
[info]     final def Event: it.unibo.dap.model.Simulatable.Event.type =
[info]       it.unibo.dap.model.Simulatable.Event
[info]     final type Event[S] = it.unibo.dap.model.Simulatable.Event[S]
[info]     final type Trace[S] = it.unibo.dap.model.Simulatable.Trace[S]
[info]     import java.util.Random
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S]) def simulate(
[info]       initialState: S)(using x$3: java.util.Random): Simulatable.this.Trace[S]
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S])
[info]       def simulateStep(s: S)(using x$3: java.util.Random):
[info]       Simulatable.this.Event[S] = this.simulate[S](self)(s)(x$3).drop(1).head
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Simulatable: it.unibo.dap.model.Simulatable =
[info]     new it.unibo.dap.model.Simulatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Simulatable() extends Object() {
[info]     this: it.unibo.dap.model.Simulatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Simulatable.type])
[info]     type Trace[S >: Nothing <: Any] =
[info]       LazyList[it.unibo.dap.model.Simulatable.Event[S]]
[info]     case class Event[S >: Nothing <: Any](time: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Event.this.time))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Event.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.Simulatable.Event[S] @unchecked
[info]                  =>
[info]                 this.time.==(x$0.time).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.Simulatable.Event[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Event"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "time"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val time: Double
[info]       val state: S
[info]       def copy[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Event.this.time
[info]       def copy$default$2[S]: S = Event.this.state
[info]       def _1: Double = this.time
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Event: it.unibo.dap.model.Simulatable.Event =
[info]       new it.unibo.dap.model.Simulatable.Event()
[info]     final module class Event() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.Simulatable.Event.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.Simulatable.Event.type])
[info]       def apply[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.Simulatable.Event[S]):
[info]         it.unibo.dap.model.Simulatable.Event[S] = x$1
[info]       override def toString: String = "Event"
[info]       type MirroredMonoType = it.unibo.dap.model.Simulatable.Event[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.Simulatable.Event.MirroredMonoType =
[info]         new it.unibo.dap.model.Simulatable.Event[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala
[info] package it.unibo.dap.model {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Stochastics: it.unibo.dap.model.Stochastics =
[info]     new it.unibo.dap.model.Stochastics()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Stochastics() extends Object() {
[info]     this: it.unibo.dap.model.Stochastics.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Stochastics.type])
[info]     import scala.util.Random
[info]     def cumulative[A >: Nothing <: Any](l: List[Tuple2[Double, A]]):
[info]       List[Tuple2[Double, A]] =
[info]       l.tail.scanLeft[(Double, A)](l.head)((x$1: (Double, A),
[info]         x$2: (Double, A) @uncheckedVariance) =>
[info]         Tuple2.apply[(Double, A), (Double, A) @uncheckedVariance](x$1, x$2)
[info]            match 
[info]           {
[info]             case 
[info]               Tuple2.unapply[(Double, A), (Double, A)](
[info]                 Tuple2.unapply[Double, A](r @ _, _),
[info]                 Tuple2.unapply[Double, A](r2 @ _, a2 @ _))
[info]              =>
[info]               Tuple2.apply[Double, A](r.+(r2), a2)
[info]           }
[info]       )
[info]     def draw[A >: Nothing <: Any](cumulativeList: List[Tuple2[Double, A]])(
[info]       using rnd: scala.util.Random): A =
[info]       {
[info]         val rndVal: Double = rnd.nextDouble().*(cumulativeList.last._1)
[info]         cumulativeList.collectFirst[A]((x$1: (Double, A)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[Double, A](r @ _, a @ _) if r.>=(rndVal) =>
[info]                 a:A
[info]             }
[info]         ).get
[info]       }
[info]     def draw$default$2[A >: Nothing <: Any](
[info]       cumulativeList: List[Tuple2[Double, A]]):
[info]       scala.util.Random @uncheckedVariance = new scala.util.Random()
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMCDsl: it.unibo.dap.model.dsl.CTMCDsl =
[info]     new it.unibo.dap.model.dsl.CTMCDsl()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMCDsl() extends Object() {
[info]     this: it.unibo.dap.model.dsl.CTMCDsl.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.CTMCDsl.type])
[info]     export it.unibo.dap.model.CTMC
[info]     final def CTMC: it.unibo.dap.model.CTMC.type = it.unibo.dap.model.CTMC
[info]     final type CTMC[S] = it.unibo.dap.model.CTMC[S]
[info]     export it.unibo.dap.model.dsl.CTMCDsl.CTMC.*
[info]     final def ofFunction[S](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofFunction[S](f)
[info]     final def Transition: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition
[info]     final type Transition[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition[S]
[info]     final def Action: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action
[info]     final type Action[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action[S]
[info]     final def ofTransitions[S](rels: Set[it.unibo.dap.model.CTMC.Transition[S]])
[info]       : it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels)
[info]     final def ofTransitions[S](rels: it.unibo.dap.model.CTMC.Transition[S]*):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels*)
[info]     extension [S >: Nothing <: Any](state: S) def --(rate: Double):
[info]       Tuple2[S, Double] = Tuple2.apply[S, Double](state, rate)
[info]     extension [S >: Nothing <: Any](self: Tuple2[S, Double]) def -->(
[info]       finalState: S): it.unibo.dap.model.dsl.CTMCDsl.Transition[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.Transition.apply[S](self._1,
[info]         it.unibo.dap.model.dsl.CTMCDsl.Action.apply[S](self._2, finalState))
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSetDSL: it.unibo.dap.model.dsl.MSetDSL =
[info]     new it.unibo.dap.model.dsl.MSetDSL()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSetDSL() extends Object() {
[info]     this: it.unibo.dap.model.dsl.MSetDSL.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.MSetDSL.type])
[info]     export it.unibo.dap.model.MSet
[info]     final def MSet: it.unibo.dap.model.MSet.type = it.unibo.dap.model.MSet
[info]     final type MSet[A] = it.unibo.dap.model.MSet[A]
[info]     export it.unibo.dap.model.dsl.MSetDSL.given
[info]     extension [T >: Nothing <: Any](a: T) def |(b: T): List[T] =
[info]       List.apply[T]([a,b : T]*)
[info]     extension [T >: Nothing <: Any](xs: List[T]) def |(x: T): List[T] =
[info]       xs.:+[T](x)
[info]     final given def listSetConversion[T >: Nothing <: Any]:
[info]       Conversion[List[T], it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (
[info]       _$1: List[T]) => it.unibo.dap.model.dsl.MSetDSL.MSet.ofList[T](_$1)
[info]     final given def elemSetConversion[T >: Nothing <: Any]:
[info]       Conversion[T, it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (_$2: T) =>
[info]       it.unibo.dap.model.dsl.MSetDSL.MSet.apply[T]([_$2 : T]*)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.duration.FiniteDuration
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait AsyncOperations() extends Object {
[info]     def sleep(duration: scala.concurrent.duration.FiniteDuration):
[info]       scala.concurrent.Future[Unit]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Async: it.unibo.dap.utils.Async =
[info]     new it.unibo.dap.utils.Async()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Async() extends Object() {
[info]     this: it.unibo.dap.utils.Async.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Async.type])
[info]     def operations: it.unibo.dap.utils.AsyncOperations =
[info]       it.unibo.dap.utils.Platform.asyncOps
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{Future, Promise}
[info]   import scala.util.Try
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ReadableChannel[T >: Nothing <: Any]() extends Object {
[info]     +T
[info]     def poll(): Option[ReadableChannel.this.T]
[info]     def pop(): scala.concurrent.Future[ReadableChannel.this.T]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SendableChannel[T >: Nothing <: Any]() extends Object {
[info]     -T
[info]     def push(item: SendableChannel.this.T):
[info]       Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Channel[T >: Nothing <: Any]() extends Object,
[info]     it.unibo.dap.utils.ReadableChannel[Channel.this.T], it.unibo.dap.utils.
[info]     SendableChannel[Channel.this.T] {
[info]     T
[info]     def asReadable: it.unibo.dap.utils.ReadableChannel[Channel.this.T] = this
[info]     def asSendable: it.unibo.dap.utils.SendableChannel[Channel.this.T] = this
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Channel: it.unibo.dap.utils.Channel =
[info]     new it.unibo.dap.utils.Channel()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Channel() extends Object() {
[info]     this: it.unibo.dap.utils.Channel.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Channel.type])
[info]     type Error = String
[info]     def apply[T >: Nothing <: Any](): it.unibo.dap.utils.Channel[T] =
[info]       new it.unibo.dap.utils.Channel.ChannelImpl[T]()
[info]     def readable[T >: Nothing <: Any](): it.unibo.dap.utils.ReadableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Nothing]().asReadable
[info]     def sendable[T >: Nothing <: Any](): it.unibo.dap.utils.SendableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Any]().asSendable
[info]     private[this] class ChannelImpl[T >: Nothing <: Any]() extends Object(), 
[info]       it.unibo.dap.utils.Channel[ChannelImpl.this.T] {
[info]       T
[info]       private[this] var closed: Boolean = false
[info]       private[this] val buffer: scala.collection.mutable.Queue[T] =
[info]         scala.collection.mutable.Queue.empty[ChannelImpl.this.T]
[info]       private[this] val waiters:
[info]         scala.collection.mutable.Queue[scala.concurrent.Promise[T]] =
[info]         scala.collection.mutable.Queue.empty[
[info]           scala.concurrent.Promise[ChannelImpl.this.T]]
[info]       override def push(item: ChannelImpl.this.T):
[info]         Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing](
[info]               "Channel is closed. No more items can be pushed.")
[info]            else 
[info]             if this.waiters.nonEmpty then
[info]               it.unibo.dap.utils.unit[String, scala.concurrent.Promise[T]](
[info]                 scala.util.Try.apply[scala.concurrent.Promise[T]](
[info]                   this.waiters.dequeue().success(item)).toEither.left.map[String
[info]                   ]((_$1: Throwable) => _$1.getMessage())
[info]               )
[info]              else 
[info]               Right.apply[Nothing, Unit](
[info]                 {
[info]                   this.buffer.enqueue(item)
[info]                   ()
[info]                 }
[info]               )
[info]         )
[info]       override def pop(): scala.concurrent.Future[ChannelImpl.this.T] =
[info]         this.synchronized[scala.concurrent.Future[T]](
[info]           this.poll() match 
[info]             {
[info]               case Some.unapply[T](item @ _):Some[T] =>
[info]                 scala.concurrent.Future.successful[T](item)
[info]               case _ if this.closed =>
[info]                 scala.concurrent.Future.failed[Nothing](
[info]                   new NoSuchElementException(
[info]                     "Channel is closed and no items are available.")
[info]                 )
[info]               case _ =>
[info]                 val promise: scala.concurrent.Promise[T] =
[info]                   scala.concurrent.Promise.apply[ChannelImpl.this.T]()
[info]                 this.waiters.enqueue(promise)
[info]                 promise.future:scala.concurrent.Future[T]
[info]             }
[info]         )
[info]       override def poll(): Option[ChannelImpl.this.T] =
[info]         this.synchronized[Option[T]](
[info]           Option.when[T](this.buffer.nonEmpty)(this.buffer.dequeue()))
[info]       override def close(): Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing]("Channel is already closed.") else 
[info]             {
[info]               this.closed = true
[info]               this.waiters.foreach[scala.concurrent.Promise[T]]((
[info]                 _$2: scala.concurrent.Promise[T]) =>
[info]                 _$2.failure(new NoSuchElementException("Channel is closed.")))
[info]               this.waiters.clear()
[info]               Right.apply[Nothing, Unit](())
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/native/src/main/scala/it/unibo/dap/api/NativeProductApi.scala
[info] package it.unibo.dap.api {
[info]   import java.util.concurrent.ForkJoinPool
[info]   import scala.scalanative.unsafe.*
[info]   import scala.scalanative.libc.stdlib
[info]   import scala.concurrent.ExecutionContext
[info]   import scala.scalanative.libc
[info]   import scala.language.postfixOps
[info]   import it.unibo.dap.utils.Iso
[info]   import it.unibo.dap.utils.CUtils
[info]   import scala.util.package.chaining.scalaUtilChainingOps
[info]   import it.unibo.dap.utils.CUtils.withLogging
[info]   import scala.reflect.ClassTag
[info]   import scala.compiletime.summonFrom
[info]   import scala.scalanative.unsigned.UnsignedRichInt
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val NativeProductApi: it.unibo.dap.api.NativeProductApi =
[info]     new it.unibo.dap.api.NativeProductApi()
[info]   @SourceFile(
[info]     "dap/native/src/main/scala/it/unibo/dap/api/NativeProductApi.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class NativeProductApi() extends Object(), it.unibo.dap.api.
[info]     ProductApi { this: it.unibo.dap.api.NativeProductApi.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.NativeProductApi.type])
[info]     override val interface:
[info]       it.unibo.dap.api.NativeProductApi.NativeInterface.type =
[info]       it.unibo.dap.api.NativeProductApi.NativeInterface
[info]     final lazy module val NativeInterface:
[info]       it.unibo.dap.api.NativeProductApi.NativeInterface =
[info]       new it.unibo.dap.api.NativeProductApi.NativeInterface()
[info]     final module class NativeInterface() extends Object(),
[info]       it.unibo.dap.api.NativeProductApi.ProductInterface, 
[info]       it.unibo.dap.api.NativeProductApi.NativeADTs {
[info]       this: it.unibo.dap.api.NativeProductApi.NativeInterface.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.api.NativeProductApi.NativeInterface.type])
[info]       override final lazy given val given_ExecutionContext:
[info]         scala.concurrent.ExecutionContext =
[info]         scala.concurrent.ExecutionContext.fromExecutor(
[info]           new java.util.concurrent.ForkJoinPool())
[info]       import it.unibo.dap.api.given
[info]       @exported def simulation(
[info]         rules:
[info]           it.unibo.dap.api.NativeProductApi.NativeInterface.ISeq[
[info]             it.unibo.dap.api.CRule]
[info]         ,
[info]       initialState: scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CState],
[info]         neighborhood:
[info]           it.unibo.dap.api.NativeProductApi.NativeInterface.ISeq[
[info]             it.unibo.dap.api.CNeighbor]
[info]         ,
[info]         serializer:
[info]           scala.scalanative.unsafe.CFuncPtr1[it.unibo.dap.api.CToken,
[info]             scala.scalanative.unsafe.CString]
[info]         ,
[info]         deserializer:
[info]           scala.scalanative.unsafe.CFuncPtr1[scala.scalanative.unsafe.CString,
[info]             it.unibo.dap.api.CToken]
[info]         ,
[info]         equalizer:
[info]           scala.scalanative.unsafe.CFuncPtr2[it.unibo.dap.api.CToken,
[info]             it.unibo.dap.api.CToken, scala.scalanative.unsafe.CBool]
[info]       ): it.unibo.dap.api.DASPSimulation[it.unibo.dap.api.CToken] =
[info]         {
[info]           def block$proxy1:
[info]             it.unibo.dap.api.DASPSimulation[scala.scalanative.unsafe.Ptr[Byte]]
[info]              =
[info]             {
[info]               scribe.package.info("Setting up simulation")(
[info]                 sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                 sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                   sourcecode.FileName,
[info]                 sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                 sourcecode.Line.apply(41):sourcecode.Line,
[info]                 scribe.mdc.MDC.instance)
[info]               val allRules:
[info]                 
[info]                   Seq[
[info]                     it.unibo.dap.api.NativeProductApi.NativeInterface.Rule[
[info]                       it.unibo.dap.api.CToken]
[info]                   ]
[info]                 
[info]                =
[info]                 scala.util.chaining.scalaUtilChainingOps[
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CRule]]
[info]                   
[info]                 ](rules).pipe[
[info]                   
[info]                     Seq[
[info]                       it.unibo.dap.api.NativeProductApi.NativeInterface.Rule[
[info]                         it.unibo.dap.api.CToken]
[info]                     ]
[info]                   
[info]                 ]((
[info]                   _$1:
[info]                     
[info]                       scala.scalanative.unsafe.Ptr[
[info]                         it.unibo.dap.api.CSeq[it.unibo.dap.api.CRule]]
[info]                     
[info]                 ) =>
[info]                   {
[info]                     val iseqc_this:
[info]                       
[info]                         it.unibo.dap.api.NativeProductApi.NativeInterface.iseqc[
[info]                           scala.scalanative.unsafe.CStruct4[
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             Double,
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             it.unibo.dap.api.CToken]
[info]                         ]
[info]                       
[info]                      =
[info]                       it.unibo.dap.api.NativeProductApi.NativeInterface.iseqc[
[info]                         
[info]                           scala.scalanative.unsafe.CStruct4[
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             Double,
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             it.unibo.dap.api.CToken]
[info]                         
[info]                       ]
[info]                     (
[info]                       {
[info]                         given val _$6:
[info]                           
[info]                             scala.scalanative.unsafe.Tag.CStruct4[
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                                 ,
[info]                             Double,
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                                 ,
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                          =
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct4Tag[
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                             ,
[info]                           Double,
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                             ,
[info]                           scala.scalanative.unsafe.Ptr[Byte]](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                               
[info]                                 scala.scalanative.unsafe.CStruct2[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CToken],
[info]                                   scala.scalanative.libc.stddef.size_t]
[info]                               
[info]                             ](
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CToken]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 it.unibo.dap.api.given_Tag_Ptr,
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                             scala.scalanative.unsafe.Tag.materializeDoubleTag,
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                               
[info]                                 scala.scalanative.unsafe.CStruct2[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CToken],
[info]                                   scala.scalanative.libc.stddef.size_t]
[info]                               
[info]                             ](
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CToken]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 it.unibo.dap.api.given_Tag_Ptr,
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                           it.unibo.dap.api.ctokenTag)
[info]                         {
[info]                           given val _$7:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 scala.scalanative.unsafe.CStruct4[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.CToken]
[info]                                   ],
[info]                                 Double,
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.CToken]
[info]                                   ],
[info]                                 it.unibo.dap.api.CToken]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 scala.scalanative.unsafe.CStruct4[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.CToken]
[info]                                   ],
[info]                                 Double,
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.CToken]
[info]                                   ],
[info]                                 it.unibo.dap.api.CToken]
[info]                               
[info]                             ](classOf[scala.scalanative.unsafe.CStruct4])
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["to -> [","]" : String]*).s(
[info]                               [_$7.runtimeClass : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("allRules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(42):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           it.unibo.dap.api.CArraySeq.apply[
[info]                             
[info]                               scala.scalanative.unsafe.CStruct4[
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]
[info]                                   ],
[info]                               Double,
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]
[info]                                   ],
[info]                               it.unibo.dap.api.CToken]
[info]                             
[info]                           ](
[info]                             _$1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                             _$1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala
[info] package it.unibo.dap.utils {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Iso[A >: Nothing <: Any, B >: Nothing <: Any]() extends Object {
[info]     A
[info]     B
[info]     def to(a: Iso.this.A): Iso.this.B
[info]     def from(b: Iso.this.B): Iso.this.A
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso: it.unibo.dap.utils.Iso =
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   
[info]     new it.unibo.dap.utils.Iso()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Iso() extends Object() {
[info]     this: it.unibo.dap.utils.Iso.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso.type])
[info]     inline def apply[A >: Nothing <: Any, B >: Nothing <: Any](toFn: A => B,
[info]       fromFn: B => A): it.unibo.dap.utils.Iso[A, B] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.utils.Iso[A, B] {
[info]           def to(a: A): B = toFn.apply(a)
[info]           def from(b: B): A = fromFn.apply(b)
[info]         }
[info]         new $anon():it.unibo.dap.utils.Iso[A, B]
[info]       }:it.unibo.dap.utils.Iso[A, B]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso$package: it.unibo.dap.utils.Iso$package =
[info]     new it.unibo.dap.utils.Iso$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala") final
[info]     module class Iso$package() extends Object() {
[info]     this: it.unibo.dap.utils.Iso$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso$package.type])
[info]     extension [A >: Nothing <: Any](a: A)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def as
[info]     [B >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]       iso.to(a)
[info]     extension [B >: Nothing <: Any](b: B)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def back
[info]     [A >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]       iso.from(b)
[info]   }
[info] }
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._2(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct4[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     Double,
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.CToken]
[info]                                       ],
[info]                                     it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).toInt
[info]                           )(_$6)
[info]                         }
[info]                       }
[info]                     :
[info]                       Seq[
[info]                         
[info]                           scala.scalanative.unsafe.CStruct4[
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             Double,
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]],
[info]                             it.unibo.dap.api.CToken]
[info]                         
[info]                       ]
[info]                     )
[info]                   }.map[
[info]                     
[info]                       it.unibo.dap.api.NativeProductApi.NativeInterface.Rule[
[info]                         it.unibo.dap.api.CToken]
[info]                     
[info]                   ](it.unibo.dap.api.NativeProductApi.NativeInterface.toRule)
[info]                 )
[info]               val allNeighbors:
[info]                 
[info]                   Seq[
[info]                     scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]
[info]                     ]
[info]                 
[info]                =
[info]                 scala.util.chaining.scalaUtilChainingOps[
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CNeighbor]]
[info]                   
[info]                 ](neighborhood).pipe[
[info]                   
[info]                     Seq[
[info]                       scala.scalanative.unsafe.Ptr[
[info]                         scala.scalanative.unsafe.CChar]
[info]                     ]
[info]                   
[info]                 ]((
[info]                   _$2:
[info]                     
[info]                       scala.scalanative.unsafe.Ptr[
[info]                         it.unibo.dap.api.CSeq[it.unibo.dap.api.CNeighbor]]
[info]                     
[info]                 ) =>
[info]                   {
[info]                     val iseqc_this:
[info]                       
[info]                         it.unibo.dap.api.NativeProductApi.NativeInterface.iseqc[
[info]                           scala.scalanative.unsafe.CStruct1[
[info]                             scala.scalanative.unsafe.CString]
[info]                         ]
[info]                       
[info]                      =
[info]                       it.unibo.dap.api.NativeProductApi.NativeInterface.iseqc[
[info]                         
[info]                           scala.scalanative.unsafe.CStruct1[
[info]                             scala.scalanative.unsafe.CString]
[info]                         
[info]                       ]
[info]                     (
[info]                       {
[info]                         given val _$6:
[info]                           
[info]                             scala.scalanative.unsafe.Tag.CStruct1[
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 scala.scalanative.unsafe.CChar]
[info]                             ]
[info]                           
[info]                          =
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct1Tag[
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 scala.scalanative.unsafe.CChar]
[info]                             
[info]                           ](it.unibo.dap.api.ctokenTag)
[info]                         {
[info]                           given val _$7:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 scala.scalanative.unsafe.CStruct1[
[info]                                   scala.scalanative.unsafe.CString]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 scala.scalanative.unsafe.CStruct1[
[info]                                   scala.scalanative.unsafe.CString]
[info]                               
[info]                             ](classOf[scala.scalanative.unsafe.CStruct1])
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["to -> [","]" : String]*).s(
[info]                               [_$7.runtimeClass : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("allNeighbors"):
[info]                               sourcecode.Name,
[info]                             sourcecode.Line.apply(43):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           it.unibo.dap.api.CArraySeq.apply[
[info]                             
[info]                               scala.scalanative.unsafe.CStruct1[
[info]                                 scala.scalanative.unsafe.CString]
[info]                             
[info]                           ](
[info]                             _$2.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Task[T >: Nothing <: Any]() extends Object, (() =>
[info]     scala.concurrent.Future[T]) {
[info]     T
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Spawnable[Configuration >: Nothing <: Any]() extends Object {
[info]     Configuration
[info]     def spawn(configuration: Spawnable.this.Configuration)(using 
[info]       x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait PlainSpawnable() extends Object, it.unibo.dap.utils.Spawnable[Unit] {}
[info]   }
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                             _$2.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._2(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.CStruct1[
[info]                                       scala.scalanative.unsafe.CString]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).toInt
[info]                           )(_$6)
[info]                         }
[info]                       }
[info]                     :
[info]                       Seq[
[info]                         
[info]                           scala.scalanative.unsafe.CStruct1[
[info]                             scala.scalanative.unsafe.CString]
[info]                         
[info]                       ]
[info]                     )
[info]                   }.map[
[info]                     scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]
[info]                     ](
[info]                     it.unibo.dap.api.NativeProductApi.NativeInterface.toNeighbor
[info]                     )
[info]                 )
[info]               {
[info]                 val ProductInterface_this:
[info]                   
[info]                     (it.unibo.dap.api.NativeProductApi.interface :
[info]                       it.unibo.dap.api.NativeProductApi.NativeInterface.type)
[info]                   
[info]                  = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                 val rules$proxy1:
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[
[info]                         it.unibo.dap.api.NativeProductApi.NativeInterface.Rule[
[info]                           it.unibo.dap.api.CToken]
[info]                       ]
[info]                     ]
[info]                   
[info]                  =
[info]                   {
[info]                     val NativeADTs_this:
[info]                       
[info]                         (it.unibo.dap.api.NativeProductApi.NativeInterface :
[info]                           it.unibo.dap.api.NativeProductApi.NativeInterface.type
[info]                           )
[info]                       
[info]                      = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                     {
[info]                       val iseqcc_this:
[info]                         
[info]                           it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                             iseqcc[
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                               Rule[it.unibo.dap.api.CToken]
[info]                           ]
[info]                         
[info]                        =
[info]                         new NativeADTs_this.iseqcc[
[info]                           
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                               Rule[it.unibo.dap.api.CToken]
[info]                           
[info]                         ]():
[info]                           NativeADTs_this.iseqcc[
[info]                             
[info]                               it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                                 Rule[it.unibo.dap.api.CToken]
[info]                             
[info]                           ]
[info]                       val NativeADTs_this:
[info]                         
[info]                           (it.unibo.dap.api.NativeProductApi.NativeInterface :
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                               .type
[info]                           )
[info]                         
[info]                        = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                       {
[info]                         given val _$8:
[info]                           
[info]                             scala.scalanative.unsafe.Tag[
[info]                               it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                                 Rule[it.unibo.dap.api.CToken]
[info]                             ]
[info]                           
[info]                          =
[info]                           scala.scalanative.unsafe.Tag.materializeClassTag[
[info]                             
[info]                               it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                                 Rule[it.unibo.dap.api.CToken]
[info]                             
[info]                           ](
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                   .Rule[it.unibo.dap.api.CToken]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           )
[info]                         {
[info]                           given val _$9:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                   .Rule[it.unibo.dap.api.CToken]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                   .Rule[it.unibo.dap.api.CToken]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           scribe.package.info("from <-")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val ptr:
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info] package it.unibo.dap.utils {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val TimeOps: it.unibo.dap.utils.TimeOps =
[info]     new it.unibo.dap.utils.TimeOps()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class TimeOps() extends Object() {
[info]     this: it.unibo.dap.utils.TimeOps.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.TimeOps.type])
[info]     def timed[A >: Nothing <: Any](input: => A): A =
[info]       {
[info]         val t0: Long = java.lang.System.nanoTime()
[info]         try input finally 
[info]           scribe.package.info(
[info]             "Timed op (msec): ".+(java.lang.System.nanoTime().-(t0)./(1000000)))
[info]             (sourcecode.Pkg.apply("it.unibo.dap.utils"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("TimeOps.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("timed"):sourcecode.Name,
[info]             sourcecode.Line.apply(9):sourcecode.Line, scribe.mdc.MDC.instance)
[info]       }
[info]   }
[info] }
[info]                                 it.unibo.dap.api.CSeq[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ]
[info]                             
[info]                            =
[info]                             {
[info]                               val factor$proxy1: Int =
[info]                                 it.unibo.dap.utils.CUtils.freshPointer$default$1
[info]                                   [
[info]                                   
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                         .Rule[it.unibo.dap.api.CToken]
[info]                                     ]
[info]                                   
[info]                                 ]
[info]                               {
[info]                                 val obj$proxy1:
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       it.unibo.dap.api.CSeq[
[info]                                         it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                           .Rule[it.unibo.dap.api.CToken]
[info]                                       ]
[info]                                     ]
[info]                                   
[info]                                  =
[info]                                   scala.scalanative.libc.stdlib.malloc(
[info]                                     (
[info]                                       scala.scalanative.runtime.Intrinsics.
[info]                                         castRawSizeToInt(
[info]                                         scala.scalanative.runtime.Intrinsics.
[info]                                           sizeOf[
[info]                                           
[info]                                             it.unibo.dap.api.CSeq[
[info]                                               it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                                 .Rule[it.unibo.dap.api.CToken]
[info]                                             ]
[info]                                           
[info]                                         ]
[info]                                       )
[info]                                     :Int).*(factor$proxy1)
[info]                                   ).asInstanceOf[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                             .Rule[it.unibo.dap.api.CToken]
[info]                                         ]
[info]                                       
[info]                                     ]
[info]                                   ]
[info]                                 (if obj$proxy1.==(null) then
[info]                                   throw 
[info]                                     new NullPointerException(
[info]                                       _root_.scala.StringContext.apply(
[info]                                         ["Object "," is null" : String]*).s(
[info]                                         [obj$proxy1 : Any]*)
[info]                                     )
[info]                                  else obj$proxy1):
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       it.unibo.dap.api.CSeq[
[info]                                         it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                           .Rule[it.unibo.dap.api.CToken]
[info]                                       ]
[info]                                     ]
[info]                                   
[info]                               }:
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                         .Rule[it.unibo.dap.api.CToken]
[info]                                     ]
[info]                                   
[info]                                 ]
[info]                             }
[info]                           ptr.unary_!(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )._1_=(
[info]                             {
[info]                               val factor$proxy2: Int = allRules.length
[info]                               {
[info]                                 val obj$proxy2:
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.ExecutionContext
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Utils$package: it.unibo.dap.utils.Utils$package =
[info]     new it.unibo.dap.utils.Utils$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala") final
[info]     module class Utils$package() extends Object() {
[info]     this: it.unibo.dap.utils.Utils$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Utils$package.type])
[info]     extension [L >: Nothing <: Any, R >: Nothing <: Any](e: Either[L, R])
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : Either[L, Unit] = e.map[Unit]((_$1: R) => ())
[info]     extension [T >: Nothing <: Any](f: scala.concurrent.Future[T])(using 
[info]       x$2: scala.concurrent.ExecutionContext)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : scala.concurrent.Future[Unit] = f.map[Unit]((_$2: T) => ())(x$2)
[info]   }
[info] }
[info]                                       it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                         .Rule[it.unibo.dap.api.CToken]
[info]                                     ]
[info]                                   
[info]                                  =
[info]                                   scala.scalanative.libc.stdlib.malloc(
[info]                                     (
[info]                                       scala.scalanative.runtime.Intrinsics.
[info]                                         castRawSizeToInt(
[info]                                         scala.scalanative.runtime.Intrinsics.
[info]                                           sizeOf[
[info]                                           
[info]                                             it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                               .Rule[it.unibo.dap.api.CToken]
[info]                                           
[info]                                         ]
[info]                                       )
[info]                                     :Int).*(factor$proxy2)
[info]                                   ).asInstanceOf[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       
[info]                                         it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                           .Rule[it.unibo.dap.api.CToken]
[info]                                       
[info]                                     ]
[info]                                   ]
[info]                                 (if obj$proxy2.==(null) then
[info]                                   throw 
[info]                                     new NullPointerException(
[info]                                       _root_.scala.StringContext.apply(
[info]                                         ["Object "," is null" : String]*).s(
[info]                                         [obj$proxy2 : Any]*)
[info]                                     )
[info]                                  else obj$proxy2):
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                         .Rule[it.unibo.dap.api.CToken]
[info]                                     ]
[info]                                   
[info]                               }:
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   
[info]                                     it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                       .Rule[it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ]
[info]                             }
[info]                           )(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )
[info]                           ptr.unary_!(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )._2_=(
[info]                             scala.scalanative.unsigned.UnsignedRichInt(
[info]                               allRules.length).toCSize
[info]                           )(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )
[info]                           intWrapper(0).until(allRules.length).foreach[Unit]((
[info]                             i: Int) =>
[info]                             ptr.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                       .Rule[it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                       .Rule[it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ](_$8),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                       .Rule[it.unibo.dap.api.CToken]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                       .Rule[it.unibo.dap.api.CToken]
[info]                                   
[info]                                 ](_$8),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).update(i, allRules.apply(i))(_$8)
[info]                           )
[info]                           ptr:
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[
[info]                                   it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                     .Rule[it.unibo.dap.api.CToken]
[info]                                 ]
[info]                               ]
[info]                             
[info]                         }
[info]                       }:
[info]                         NativeADTs_this.ISeq[
[info]                           
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                               Rule[it.unibo.dap.api.CToken]
[info]                           
[info]                         ]
[info]                     }
[info]                   }
[info]                 val initialState$proxy1:
[info]                   
[info]                     it.unibo.dap.api.NativeProductApi.NativeInterface.State[
[info]                       it.unibo.dap.api.CToken]
[info]                   
[info]                  =
[info]                   it.unibo.dap.api.NativeProductApi.NativeInterface.toState.
[info]                     apply(
[info]                     initialState.unary_!(
[info]                       scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                         
[info]                           scala.scalanative.unsafe.Ptr[
[info]                             it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                         ,
[info]                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                         scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                           
[info]                             scala.scalanative.unsafe.CStruct2[
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CToken],
[info]                               scala.scalanative.libc.stddef.size_t]
[info]                           
[info]                         ](
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CToken]
[info]                             ,
[info]                           scala.scalanative.unsigned.USize](
[info]                             it.unibo.dap.api.given_Tag_Ptr,
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         ),
[info]                       it.unibo.dap.api.ctokenTag)
[info]                     )
[info]                   )
[info]                 val neighborhood$proxy1:
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[
[info]                         scala.scalanative.unsafe.Ptr[
[info]                           scala.scalanative.unsafe.CChar]
[info]                       ]
[info]                     ]
[info]                   
[info]                  =
[info]                   {
[info]                     val NativeADTs_this:
[info]                       
[info]                         (it.unibo.dap.api.NativeProductApi.NativeInterface :
[info]                           it.unibo.dap.api.NativeProductApi.NativeInterface.type
[info]                           )
[info]                       
[info]                      = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                     {
[info]                       val iseqcc_this:
[info]                         
[info]                           it.unibo.dap.api.NativeProductApi.NativeInterface.
[info]                             iseqcc[
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               scala.scalanative.unsafe.CChar]
[info]                           ]
[info]                         
[info]                        =
[info]                         new NativeADTs_this.iseqcc[
[info]                           
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               scala.scalanative.unsafe.CChar]
[info]                           
[info]                         ]():
[info]                           NativeADTs_this.iseqcc[
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 scala.scalanative.unsafe.CChar]
[info]                             
[info]                           ]
[info]                       val NativeADTs_this:
[info]                         
[info]                           (it.unibo.dap.api.NativeProductApi.NativeInterface :
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                               .type
[info]                           )
[info]                         
[info]                        = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                       {
[info]                         given val _$8:
[info]                           scala.scalanative.unsafe.Tag[it.unibo.dap.api.CToken]
[info]                            = it.unibo.dap.api.ctokenTag
[info]                         {
[info]                           given val _$9:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.CChar]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.CChar]
[info]                               
[info]                             ](classOf[scala.scalanative.unsafe.Ptr])
[info]                           scribe.package.info("from <-")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val ptr:
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ]
[info]                             
[info]                            =
[info]                             {
[info]                               val factor$proxy3: Int =
[info]                                 it.unibo.dap.utils.CUtils.freshPointer$default$1
[info]                                   [
[info]                                   
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         scala.scalanative.unsafe.CChar]
[info]                                     ]
[info]                                   
[info]                                 ]
[info]                               {
[info]                                 val obj$proxy3:
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       it.unibo.dap.api.CSeq[
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.CChar]
[info]                                       ]
[info]                                     ]
[info]                                   
[info]                                  =
[info]                                   scala.scalanative.libc.stdlib.malloc(
[info]                                     (
[info]                                       scala.scalanative.runtime.Intrinsics.
[info]                                         castRawSizeToInt(
[info]                                         scala.scalanative.runtime.Intrinsics.
[info]                                           sizeOf[
[info]                                           
[info]                                             it.unibo.dap.api.CSeq[
[info]                                               scala.scalanative.unsafe.Ptr[
[info]                                                 scala.scalanative.unsafe.CChar]
[info]                                             ]
[info]                                           
[info]                                         ]
[info]                                       )
[info]                                     :Int).*(factor$proxy3)
[info]                                   ).asInstanceOf[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           scala.scalanative.unsafe.Ptr[
[info]                                             scala.scalanative.unsafe.CChar]
[info]                                         ]
[info]                                       
[info]                                     ]
[info]                                   ]
[info]                                 (if obj$proxy3.==(null) then
[info]                                   throw 
[info]                                     new NullPointerException(
[info]                                       _root_.scala.StringContext.apply(
[info]                                         ["Object "," is null" : String]*).s(
[info]                                         [obj$proxy3 : Any]*)
[info]                                     )
[info]                                  else obj$proxy3):
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       it.unibo.dap.api.CSeq[
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.CChar]
[info]                                       ]
[info]                                     ]
[info]                                   
[info]                               }:
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   
[info]                                     it.unibo.dap.api.CSeq[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         scala.scalanative.unsafe.CChar]
[info]                                     ]
[info]                                   
[info]                                 ]
[info]                             }
[info]                           ptr.unary_!(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )._1_=(
[info]                             {
[info]                               val factor$proxy4: Int = allNeighbors.length
[info]                               {
[info]                                 val obj$proxy4:
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         scala.scalanative.unsafe.CChar]
[info]                                     ]
[info]                                   
[info]                                  =
[info]                                   scala.scalanative.libc.stdlib.malloc(
[info]                                     (
[info]                                       scala.scalanative.runtime.Intrinsics.
[info]                                         castRawSizeToInt(
[info]                                         scala.scalanative.runtime.Intrinsics.
[info]                                           sizeOf[
[info]                                           
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               scala.scalanative.unsafe.CChar]
[info]                                           
[info]                                         ]
[info]                                       )
[info]                                     :Int).*(factor$proxy4)
[info]                                   ).asInstanceOf[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.CChar]
[info]                                       
[info]                                     ]
[info]                                   ]
[info]                                 (if obj$proxy4.==(null) then
[info]                                   throw 
[info]                                     new NullPointerException(
[info]                                       _root_.scala.StringContext.apply(
[info]                                         ["Object "," is null" : String]*).s(
[info]                                         [obj$proxy4 : Any]*)
[info]                                     )
[info]                                  else obj$proxy4):
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         scala.scalanative.unsafe.CChar]
[info]                                     ]
[info]                                   
[info]                               }:
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:23:40 
[warn] 23 |      given Equatable[Token] = (t1, t2) => equalizer(t1, t2)
[warn]    |                                        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.CChar]
[info]                                   
[info]                                 ]
[info]                             }
[info]                           )(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )
[info]                           ptr.unary_!(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )._2_=(
[info]                             scala.scalanative.unsigned.UnsignedRichInt(
[info]                               allNeighbors.length).toCSize
[info]                           )(
[info]                             scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                               
[info]                                 scala.scalanative.unsafe.Ptr[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ,
[info]                             scala.scalanative.unsigned.USize](
[info]                               scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 
[info]                               ](_$8),
[info]                               scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                           )
[info]                           intWrapper(0).until(allNeighbors.length).foreach[Unit]
[info]                             ((i: Int) =>
[info]                             ptr.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.CChar]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.CChar]
[info]                                   
[info]                                 ](_$8),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.CChar]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       scala.scalanative.unsafe.CChar]
[info]                                   
[info]                                 ](_$8),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).update(i, allNeighbors.apply(i))(_$8)
[info]                           )
[info]                           ptr:
[info]                             
[info]                               scala.scalanative.unsafe.Ptr[
[info]                                 it.unibo.dap.api.CSeq[
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     scala.scalanative.unsafe.CChar]
[info]                                 ]
[info]                               ]
[info]                             
[info]                         }
[info]                       }:
[info]                         NativeADTs_this.ISeq[
[info]                           
[info]                             scala.scalanative.unsafe.Ptr[
[info]                               scala.scalanative.unsafe.CChar]
[info]                           
[info]                         ]
[info]                     }
[info]                   }
[info]                 {
[info]                   final lazy given val given_Equatable_Token:
[info]                     ProductInterface_this.Equatable[
[info]                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                    = (t1: scala.scalanative.unsafe.Ptr[Byte],
[info]                     t2: scala.scalanative.unsafe.Ptr[Byte]) =>
[info]                     {
[info]                       val f2c_this:
[info]                         
[info]                           ProductInterface_this.f2c[
[info]                             scala.scalanative.unsafe.Ptr[Byte],
[info]                             scala.scalanative.unsafe.Ptr[Byte], Boolean]
[info]                         
[info]                        =
[info]                         ProductInterface_this.f2c[
[info]                           scala.scalanative.unsafe.Ptr[Byte],
[info]                           scala.scalanative.unsafe.Ptr[Byte], Boolean]
[info]                       ((arg1: scala.scalanative.unsafe.Ptr[Byte],
[info]                         arg2: scala.scalanative.unsafe.Ptr[Byte]) =>
[info]                         equalizer.apply(arg1, arg2):
[info]                         ((scala.scalanative.unsafe.Ptr[Byte],
[info]                           scala.scalanative.unsafe.Ptr[Byte]) => Boolean)
[info]                       )
[info]                     }.apply(t1, t2)
[info]                   final lazy given val given_Serializable_Token:
[info]                     ProductInterface_this.Serializable[
[info]                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                    =
[info]                     ProductInterface_this.Serializable.from[
[info]                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                       (_$1: scala.scalanative.unsafe.Ptr[Byte]) =>
[info]                         ProductInterface_this.as[ProductInterface_this.IString](
[info]                           {
[info]                             val f1c_this:
[info]                               
[info]                                 ProductInterface_this.f1c[
[info]                                   scala.scalanative.unsafe.Ptr[Byte],
[info]                                   ProductInterface_this.IString]
[info]                               
[info]                              =
[info]                               ProductInterface_this.f1c[
[info]                                 scala.scalanative.unsafe.Ptr[Byte],
[info]                                 ProductInterface_this.IString]
[info]                             ((arg1: scala.scalanative.unsafe.Ptr[Byte]) =>
[info]                               serializer.apply(arg1):
[info]                               (scala.scalanative.unsafe.Ptr[Byte] =>
[info]                                 ProductInterface_this.IString)
[info]                             )
[info]                           }.apply(_$1)
[info]                         )[String](ProductInterface_this.given_Iso_IString_String
[info]                           ).getBytes()
[info]                       ,
[info]                     (b: Array[Byte]) =>
[info]                       {
[info]                         val f1c_this:
[info]                           
[info]                             ProductInterface_this.f1c[
[info]                               ProductInterface_this.IString,
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                          =
[info]                           ProductInterface_this.f1c[
[info]                             ProductInterface_this.IString,
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         ((arg1: ProductInterface_this.IString) =>
[info]                           deserializer.apply(arg1):
[info]                           (ProductInterface_this.IString =>
[info]                             scala.scalanative.unsafe.Ptr[Byte])
[info]                         )
[info]                       }.apply(
[info]                         ProductInterface_this.back[String](new String(b))[
[info]                           ProductInterface_this.IString](
[info]                           ProductInterface_this.given_Iso_IString_String)
[info]                       )
[info]                     )
[info]                   scribe.package.info("[ProductApi] converting neighborhood")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val allNeighbors: Set[String] =
[info]                     {
[info]                       val iseqc_this:
[info]                         
[info]                           ProductInterface_this.iseqc[
[info]                             ProductInterface_this.IString]
[info]                         
[info]                        =
[info]                         ProductInterface_this.iseqc[
[info]                           ProductInterface_this.IString]
[info]                       (
[info]                         {
[info]                           given val _$6:
[info]                             
[info]                               scala.scalanative.unsafe.Tag[
[info]                                 it.unibo.dap.api.CToken]
[info]                             
[info]                            = it.unibo.dap.api.ctokenTag
[info]                           {
[info]                             given val _$7:
[info]                               
[info]                                 scala.reflect.ClassTag[
[info]                                   ProductInterface_this.IString]
[info]                               
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala:11:8 
[warn] 11 |    new Iso[A, B]:
[warn]    |        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[info]                              =
[info]                               scala.reflect.ClassTag.apply[
[info]                                 ProductInterface_this.IString](
[info]                                 classOf[scala.scalanative.unsafe.Ptr])
[info]                             scribe.package.info(
[info]                               _root_.scala.StringContext.apply(
[info]                                 ["to -> [","]" : String]*).s(
[info]                                 [_$7.runtimeClass : Any]*)
[info]                             )(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("NativeProductApi.scala"
[info]                                 ):sourcecode.FileName,
[info]                               sourcecode.Name.apply("allNeighbors"):
[info]                                 sourcecode.Name,
[info]                               sourcecode.Line.apply(44):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             it.unibo.dap.api.CArraySeq.apply[
[info]                               ProductInterface_this.IString](
[info]                               neighborhood$proxy1.unary_!(
[info]                                 scala.scalanative.unsafe.Tag.
[info]                                   materializeCStruct2Tag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       ProductInterface_this.IString]
[info]                                   ,
[info]                                 scala.scalanative.unsigned.USize](
[info]                                   scala.scalanative.unsafe.Tag.materializePtrTag
[info]                                     [ProductInterface_this.IString](_$6),
[info]                                   scala.scalanative.unsafe.Tag.
[info]                                     materializeUSizeTag
[info]                                 )
[info]                               )._1(
[info]                                 scala.scalanative.unsafe.Tag.
[info]                                   materializeCStruct2Tag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       ProductInterface_this.IString]
[info]                                   ,
[info]                                 scala.scalanative.unsigned.USize](
[info]                                   scala.scalanative.unsafe.Tag.materializePtrTag
[info]                                     [ProductInterface_this.IString](_$6),
[info]                                   scala.scalanative.unsafe.Tag.
[info]                                     materializeUSizeTag
[info]                                 )
[info]                               ),
[info]                               neighborhood$proxy1.unary_!(
[info]                                 scala.scalanative.unsafe.Tag.
[info]                                   materializeCStruct2Tag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       ProductInterface_this.IString]
[info]                                   ,
[info]                                 scala.scalanative.unsigned.USize](
[info]                                   scala.scalanative.unsafe.Tag.materializePtrTag
[info]                                     [ProductInterface_this.IString](_$6),
[info]                                   scala.scalanative.unsafe.Tag.
[info]                                     materializeUSizeTag
[info]                                 )
[info]                               )._2(
[info]                                 scala.scalanative.unsafe.Tag.
[info]                                   materializeCStruct2Tag[
[info]                                   
[info]                                     scala.scalanative.unsafe.Ptr[
[info]                                       ProductInterface_this.IString]
[info]                                   ,
[info]                                 scala.scalanative.unsigned.USize](
[info]                                   scala.scalanative.unsafe.Tag.materializePtrTag
[info]                                     [ProductInterface_this.IString](_$6),
[info]                                   scala.scalanative.unsafe.Tag.
[info]                                     materializeUSizeTag
[info]                                 )
[info]                               ).toInt
[info]                             )(_$6)
[info]                           }
[info]                         }
[info]                       :Seq[ProductInterface_this.IString])
[info]                     }.toSet[ProductInterface_this.IString].map[String]((
[info]                       _$2: ProductInterface_this.IString) =>
[info]                       ProductInterface_this.as[ProductInterface_this.IString](
[info]                         _$2)[String](
[info]                         ProductInterface_this.given_Iso_IString_String)
[info]                     )
[info]                   allNeighbors.foreach[Unit]((n: String) =>
[info]                     scribe.package.info(
[info]                       _root_.scala.StringContext.apply(
[info]                         ["Neighbors: ","" : String]*).s([n : Any]*)
[info]                     )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                       sourcecode.Line.apply(44):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                   )
[info]                   scribe.package.info("[=========SIM=========]")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val allRulesAsSeq:
[info]                     Seq[
[info]                       ProductInterface_this.Rule[
[info]                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                     ]
[info]                    =
[info]                     {
[info]                       val iseqc_this:
[info]                         
[info]                           ProductInterface_this.iseqc[
[info]                             ProductInterface_this.Rule[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           ]
[info]                         
[info]                        =
[info]                         ProductInterface_this.iseqc[
[info]                           
[info]                             ProductInterface_this.Rule[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                         ]
[info]                       {
[info]                         given val _$6:
[info]                           
[info]                             scala.scalanative.unsafe.Tag[
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             ]
[info]                           
[info]                          =
[info]                           scala.scalanative.unsafe.Tag.materializeClassTag[
[info]                             
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                           ](
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           )
[info]                         {
[info]                           given val _$7:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["to -> [","]" : String]*).s(
[info]                               [_$7.runtimeClass : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("allRulesAsSeq"):
[info]                               sourcecode.Name,
[info]                             sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           it.unibo.dap.api.CArraySeq.apply[
[info]                             
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                           ](
[info]                             rules$proxy1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                             rules$proxy1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._2(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).toInt
[info]                           )(_$6)
[info]                         }
[info]                       }:
[info]                         Seq[
[info]                           
[info]                             ProductInterface_this.Rule[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                         ]
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rules: ","" : String]*).s
[info]                       ([allRulesAsSeq.mkString(",") : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   scribe.package.info("[=====================]")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val realRules:
[info]                     
[info]                       scala.collection.mutable.Set[
[info]                         it.unibo.dap.model.DAP.Rule[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       ]
[info]                     
[info]                    =
[info]                     scala.collection.mutable.Set.apply[
[info]                       it.unibo.dap.model.DAP.Rule[
[info]                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                     ](
[info]                       [ :
[info]                         
[info]                           it.unibo.dap.model.DAP.Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         
[info]                       ]*
[info]                     )
[info]                   {
[info]                     val iseqc_this:
[info]                       
[info]                         ProductInterface_this.iseqc[
[info]                           ProductInterface_this.Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         ]
[info]                       
[info]                      =
[info]                       ProductInterface_this.iseqc[
[info]                         
[info]                           ProductInterface_this.Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         
[info]                       ]
[info]                     (
[info]                       {
[info]                         given val _$6:
[info]                           
[info]                             scala.scalanative.unsafe.Tag[
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             ]
[info]                           
[info]                          =
[info]                           scala.scalanative.unsafe.Tag.materializeClassTag[
[info]                             
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                           ](
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           )
[info]                         {
[info]                           given val _$7:
[info]                             
[info]                               scala.reflect.ClassTag[
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               ]
[info]                             
[info]                            =
[info]                             scala.reflect.ClassTag.apply[
[info]                               
[info]                                 ProductInterface_this.Rule[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                             ](classOf[ADTs.this.Rule])
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["to -> [","]" : String]*).s(
[info]                               [_$7.runtimeClass : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           it.unibo.dap.api.CArraySeq.apply[
[info]                             
[info]                               ProductInterface_this.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                           ](
[info]                             rules$proxy1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._1(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ),
[info]                             rules$proxy1.unary_!(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             )._2(
[info]                               scala.scalanative.unsafe.Tag.
[info]                                 materializeCStruct2Tag[
[info]                                 
[info]                                   scala.scalanative.unsafe.Ptr[
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   ]
[info]                                 ,
[info]                               scala.scalanative.unsigned.USize](
[info]                                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                                   
[info]                                     ProductInterface_this.Rule[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                 ](_$6),
[info]                                 scala.scalanative.unsafe.Tag.materializeUSizeTag
[info]                                 )
[info]                             ).toInt
[info]                           )(_$6)
[info]                         }
[info]                       }
[info]                     :
[info]                       Seq[
[info]                         
[info]                           ProductInterface_this.Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         
[info]                       ]
[info]                     )
[info]                   }.foreach[
[info]                     
[info]                       scala.collection.mutable.Set[
[info]                         it.unibo.dap.model.DAP.Rule[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       ]
[info]                     
[info]                   ]((
[info]                     r:
[info]                       
[info]                         ProductInterface_this.Rule[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       
[info]                   ) =>
[info]                     realRules.+=(
[info]                       {
[info]                         val given_Conversion_Rule_Rule_this:
[info]                           
[info]                             ProductInterface_this.ProductADTsConversions.
[info]                               given_Conversion_Rule_Rule[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                          =
[info]                           ProductInterface_this.given_Conversion_Rule_Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         val ProductADTsConversions$_this:
[info]                           ProductInterface_this.ProductADTsConversions.type =
[info]                           ProductInterface_this.ProductADTsConversions
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface_this :
[info]                               (it.unibo.dap.api.NativeProductApi.interface :
[info]                                 it.unibo.dap.api.NativeProductApi.
[info]                                   NativeInterface.type
[info]                               )
[info]                             )
[info]                           
[info]                          = ProductInterface_this
[info]                         {
[info]                           scribe.package.info("Inside conversion")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val rules:
[info]                             it.unibo.dap.model.MSet[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                            =
[info]                             {
[info]                               val ProductADTsConversions$_this:
[info]                                 
[info]                                   (ProductADTsConversions$_this :
[info]                                     ProductInterface_this.ProductADTsConversions
[info]                                       .type
[info]                                   )
[info]                                 
[info]                                = ProductADTsConversions$_this
[info]                               {
[info]                                 val from_this:
[info]                                   
[info]                                     ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                  =
[info]                                   new ProductADTsConversions$_this.from[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                     ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 val ProductInterface_this:
[info]                                   
[info]                                     (ProductInterface_this :
[info]                                       (it.unibo.dap.api.NativeProductApi.
[info]                                         interface :
[info]                                         it.unibo.dap.api.NativeProductApi.
[info]                                           NativeInterface.type
[info]                                       )
[info]                                     )
[info]                                   
[info]                                  = ProductInterface_this
[info]                                 {
[info]                                   scribe.package.info("=======>")(
[info]                                     sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                       sourcecode.Pkg,
[info]                                     sourcecode.FileName.apply(
[info]                                       "NativeProductApi.scala"):
[info]                                       sourcecode.FileName,
[info]                                     sourcecode.Name.apply("rules"):
[info]                                       sourcecode.Name,
[info]                                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                                     scribe.mdc.MDC.instance)
[info]                                   val res:
[info]                                     
[info]                                       it.unibo.dap.model.MSet[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                    =
[info]                                     it.unibo.dap.model.MSet.ofList[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                                       {
[info]                                         val iseqc_this:
[info]                                           
[info]                                             ProductInterface_this.iseqc[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                          =
[info]                                           ProductInterface_this.iseqc[
[info]                                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                                         (
[info]                                           {
[info]                                             given val _$6:
[info]                                               
[info]                                                 scala.scalanative.unsafe.Tag[
[info]                                                   it.unibo.dap.api.CToken]
[info]                                               
[info]                                              = it.unibo.dap.api.ctokenTag
[info]                                             {
[info]                                               given val _$7:
[info]                                                 
[info]                                                   scala.reflect.ClassTag[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 
[info]                                                =
[info]                                                 scala.reflect.ClassTag.apply[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](
[info]                                                   classOf[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                     ]
[info]                                                 )
[info]                                               scribe.package.info(
[info]                                                 _root_.scala.StringContext.apply
[info]                                                   (["to -> [","]" : String]*).s(
[info]                                                   [_$7.runtimeClass : Any]*)
[info]                                               )(
[info]                                                 sourcecode.Pkg.apply(
[info]                                                   "it.unibo.dap.api"):
[info]                                                   sourcecode.Pkg,
[info]                                                 sourcecode.FileName.apply(
[info]                                                   "NativeProductApi.scala"):
[info]                                                   sourcecode.FileName,
[info]                                                 sourcecode.Name.apply("res"):
[info]                                                   sourcecode.Name,
[info]                                                 sourcecode.Line.apply(44):
[info]                                                   sourcecode.Line,
[info]                                                 scribe.mdc.MDC.instance)
[info]                                               it.unibo.dap.api.CArraySeq.apply[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     Byte]
[info]                                                 
[info]                                               ](
[info]                                                 r.pre.elems.unary_!(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 )._1(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 ),
[info]                                                 r.pre.elems.unary_!(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 )._2(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 ).toInt
[info]                                               )(_$6)
[info]                                             }
[info]                                           }
[info]                                         :Seq[scala.scalanative.unsafe.Ptr[Byte]]
[info]                                           )
[info]                                       }.toList
[info]                                     )
[info]                                   scribe.package.info("<=======")(
[info]                                     sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                       sourcecode.Pkg,
[info]                                     sourcecode.FileName.apply(
[info]                                       "NativeProductApi.scala"):
[info]                                       sourcecode.FileName,
[info]                                     sourcecode.Name.apply("rules"):
[info]                                       sourcecode.Name,
[info]                                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                                     scribe.mdc.MDC.instance)
[info]                                   res:
[info]                                     
[info]                                       it.unibo.dap.model.MSet[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                 }:
[info]                                   it.unibo.dap.model.MSet[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                               }
[info]                             }
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["Rules: ","" : String]*).s([rules : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["Rate: ","" : String]*).s([r.rate : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val eff:
[info]                             it.unibo.dap.model.MSet[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                            =
[info]                             {
[info]                               val ProductADTsConversions$_this:
[info]                                 
[info]                                   (ProductADTsConversions$_this :
[info]                                     ProductInterface_this.ProductADTsConversions
[info]                                       .type
[info]                                   )
[info]                                 
[info]                                = ProductADTsConversions$_this
[info]                               {
[info]                                 val from_this:
[info]                                   
[info]                                     ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                                  =
[info]                                   new ProductADTsConversions$_this.from[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                     ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 val ProductInterface_this:
[info]                                   
[info]                                     (ProductInterface_this :
[info]                                       (it.unibo.dap.api.NativeProductApi.
[info]                                         interface :
[info]                                         it.unibo.dap.api.NativeProductApi.
[info]                                           NativeInterface.type
[info]                                       )
[info]                                     )
[info]                                   
[info]                                  = ProductInterface_this
[info]                                 {
[info]                                   scribe.package.info("=======>")(
[info]                                     sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                       sourcecode.Pkg,
[info]                                     sourcecode.FileName.apply(
[info]                                       "NativeProductApi.scala"):
[info]                                       sourcecode.FileName,
[info]                                     sourcecode.Name.apply("eff"):sourcecode.Name
[info]                                       ,
[info]                                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                                     scribe.mdc.MDC.instance)
[info]                                   val res:
[info]                                     
[info]                                       it.unibo.dap.model.MSet[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                    =
[info]                                     it.unibo.dap.model.MSet.ofList[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                                       {
[info]                                         val iseqc_this:
[info]                                           
[info]                                             ProductInterface_this.iseqc[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                          =
[info]                                           ProductInterface_this.iseqc[
[info]                                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                                         (
[info]                                           {
[info]                                             given val _$6:
[info]                                               
[info]                                                 scala.scalanative.unsafe.Tag[
[info]                                                   it.unibo.dap.api.CToken]
[info]                                               
[info]                                              = it.unibo.dap.api.ctokenTag
[info]                                             {
[info]                                               given val _$7:
[info]                                                 
[info]                                                   scala.reflect.ClassTag[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 
[info]                                                =
[info]                                                 scala.reflect.ClassTag.apply[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](
[info]                                                   classOf[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                     ]
[info]                                                 )
[info]                                               scribe.package.info(
[info]                                                 _root_.scala.StringContext.apply
[info]                                                   (["to -> [","]" : String]*).s(
[info]                                                   [_$7.runtimeClass : Any]*)
[info]                                               )(
[info]                                                 sourcecode.Pkg.apply(
[info]                                                   "it.unibo.dap.api"):
[info]                                                   sourcecode.Pkg,
[info]                                                 sourcecode.FileName.apply(
[info]                                                   "NativeProductApi.scala"):
[info]                                                   sourcecode.FileName,
[info]                                                 sourcecode.Name.apply("res"):
[info]                                                   sourcecode.Name,
[info]                                                 sourcecode.Line.apply(44):
[info]                                                   sourcecode.Line,
[info]                                                 scribe.mdc.MDC.instance)
[info]                                               it.unibo.dap.api.CArraySeq.apply[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     Byte]
[info]                                                 
[info]                                               ](
[info]                                                 r.eff.elems.unary_!(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 )._1(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 ),
[info]                                                 r.eff.elems.unary_!(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 )._2(
[info]                                                   scala.scalanative.unsafe.Tag.
[info]                                                     materializeCStruct2Tag[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       ]
[info]                                                     ,
[info]                                                     
[info]                                                       scala.scalanative.unsigned
[info]                                                         .USize
[info]                                                     
[info]                                                   ](
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializePtrTag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[Byte]
[info]                                                       
[info]                                                     ](_$6),
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeUSizeTag
[info]                                                   )
[info]                                                 ).toInt
[info]                                               )(_$6)
[info]                                             }
[info]                                           }
[info]                                         :Seq[scala.scalanative.unsafe.Ptr[Byte]]
[info]                                           )
[info]                                       }.toList
[info]                                     )
[info]                                   scribe.package.info("<=======")(
[info]                                     sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                       sourcecode.Pkg,
[info]                                     sourcecode.FileName.apply(
[info]                                       "NativeProductApi.scala"):
[info]                                       sourcecode.FileName,
[info]                                     sourcecode.Name.apply("eff"):sourcecode.Name
[info]                                       ,
[info]                                     sourcecode.Line.apply(44):sourcecode.Line,
[info]                                     scribe.mdc.MDC.instance)
[info]                                   res:
[info]                                     
[info]                                       it.unibo.dap.model.MSet[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                 }:
[info]                                   it.unibo.dap.model.MSet[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                               }
[info]                             }
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["Eff: ","" : String]*).s([eff : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val msg: Option[scala.scalanative.unsafe.Ptr[Byte]] =
[info]                             ProductADTsConversions$_this.as[
[info]                               
[info]                                 ProductInterface_this.IOption[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                             ](r.msg)[Option[scala.scalanative.unsafe.Ptr[Byte]]]
[info]                               (
[info]                               ProductInterface_this.given_Iso_IOption_Option[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             )
[info]                           scribe.package.info(
[info]                             _root_.scala.StringContext.apply(
[info]                               ["Msg: ","" : String]*).s([msg : Any]*)
[info]                           )(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res:
[info]                             
[info]                               it.unibo.dap.model.DAP.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                            =
[info]                             it.unibo.dap.model.DAP.Rule.apply[
[info]                               scala.scalanative.unsafe.Ptr[Byte]](
[info]                               {
[info]                                 val ProductADTsConversions$_this:
[info]                                   
[info]                                     (ProductADTsConversions$_this :
[info]                                       ProductInterface_this.
[info]                                         ProductADTsConversions.type
[info]                                     )
[info]                                   
[info]                                  = ProductADTsConversions$_this
[info]                                 {
[info]                                   val from_this:
[info]                                     
[info]                                       ProductADTsConversions$_this.from[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                    =
[info]                                     new ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                       ProductADTsConversions$_this.from[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   val ProductInterface_this:
[info]                                     
[info]                                       (ProductInterface_this :
[info]                                         (it.unibo.dap.api.NativeProductApi.
[info]                                           interface :
[info]                                           it.unibo.dap.api.NativeProductApi.
[info]                                             NativeInterface.type
[info]                                         )
[info]                                       )
[info]                                     
[info]                                    = ProductInterface_this
[info]                                   {
[info]                                     scribe.package.info("=======>")(
[info]                                       sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                         sourcecode.Pkg,
[info]                                       sourcecode.FileName.apply(
[info]                                         "NativeProductApi.scala"):
[info]                                         sourcecode.FileName,
[info]                                       sourcecode.Name.apply("res"):
[info]                                         sourcecode.Name,
[info]                                       sourcecode.Line.apply(44):sourcecode.Line
[info]                                         ,
[info]                                     scribe.mdc.MDC.instance)
[info]                                     val res:
[info]                                       
[info]                                         it.unibo.dap.model.MSet[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       
[info]                                      =
[info]                                       it.unibo.dap.model.MSet.ofList[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](
[info]                                         {
[info]                                           val iseqc_this:
[info]                                             
[info]                                               ProductInterface_this.iseqc[
[info]                                                 scala.scalanative.unsafe.Ptr[
[info]                                                   Byte]
[info]                                               ]
[info]                                             
[info]                                            =
[info]                                             ProductInterface_this.iseqc[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           (
[info]                                             {
[info]                                               given val _$6:
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Tag[
[info]                                                     it.unibo.dap.api.CToken]
[info]                                                 
[info]                                                = it.unibo.dap.api.ctokenTag
[info]                                               {
[info]                                                 given val _$7:
[info]                                                   
[info]                                                     scala.reflect.ClassTag[
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[Byte]
[info]                                                     ]
[info]                                                   
[info]                                                  =
[info]                                                   scala.reflect.ClassTag.apply[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[Byte]
[info]                                                     
[info]                                                   ](
[info]                                                     classOf[
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr
[info]                                                     ]
[info]                                                   )
[info]                                                 scribe.package.info(
[info]                                                   _root_.scala.StringContext.
[info]                                                     apply(
[info]                                                     ["to -> [","]" : String]*).s
[info]                                                     ([_$7.runtimeClass : Any]*)
[info]                                                 )(
[info]                                                   sourcecode.Pkg.apply(
[info]                                                     "it.unibo.dap.api"):
[info]                                                     sourcecode.Pkg,
[info]                                                   sourcecode.FileName.apply(
[info]                                                     "NativeProductApi.scala"):
[info]                                                     sourcecode.FileName,
[info]                                                   sourcecode.Name.apply("res"):
[info]                                                     sourcecode.Name,
[info]                                                   sourcecode.Line.apply(44):
[info]                                                     sourcecode.Line,
[info]                                                   scribe.mdc.MDC.instance)
[info]                                                 it.unibo.dap.api.CArraySeq.apply
[info]                                                   [
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](
[info]                                                   r.pre.elems.unary_!(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   )._1(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   ),
[info]                                                   r.pre.elems.unary_!(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:23:40 
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   )._2(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[warn] 23 |      given Equatable[Token] = (t1, t2) => equalizer(t1, t2)
[warn]    |                                        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[info]                                                         scala.scalanative.unsafe
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   ).toInt
[info]                                                 )(_$6)
[info]                                               }
[info]                                             }
[info]                                           :
[info]                                             Seq[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           )
[info]                                         }.toList
[info]                                       )
[info]                                     scribe.package.info("<=======")(
[info]                                       sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                         sourcecode.Pkg,
[info]                                       sourcecode.FileName.apply(
[info]                                         "NativeProductApi.scala"):
[info]                                         sourcecode.FileName,
[info]                                       sourcecode.Name.apply("res"):
[info]                                         sourcecode.Name,
[info]                                       sourcecode.Line.apply(44):sourcecode.Line
[info]                                         ,
[info]                                     scribe.mdc.MDC.instance)
[info]                                     res:
[info]                                       
[info]                                         it.unibo.dap.model.MSet[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       
[info]                                   }:
[info]                                     it.unibo.dap.model.MSet[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 }
[info]                               },
[info]                               (
[info]                                 _$3:
[info]                                   
[info]                                     it.unibo.dap.model.MSet[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   
[info]                               ) => r.rate,
[info]                               {
[info]                                 val ProductADTsConversions$_this:
[info]                                   
[info]                                     (ProductADTsConversions$_this :
[info]                                       ProductInterface_this.
[info]                                         ProductADTsConversions.type
[info]                                     )
[info]                                   
[info]                                  = ProductADTsConversions$_this
[info]                                 {
[info]                                   val from_this:
[info]                                     
[info]                                       ProductADTsConversions$_this.from[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala:11:8 
[warn] 11 |    new Iso[A, B]:
[warn]    |        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[info]                                    =
[info]                                     new ProductADTsConversions$_this.from[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                       ProductADTsConversions$_this.from[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                   val ProductInterface_this:
[info]                                     
[info]                                       (ProductInterface_this :
[info]                                         (it.unibo.dap.api.NativeProductApi.
[info]                                           interface :
[info]                                           it.unibo.dap.api.NativeProductApi.
[info]                                             NativeInterface.type
[info]                                         )
[info]                                       )
[info]                                     
[info]                                    = ProductInterface_this
[info]                                   {
[info]                                     scribe.package.info("=======>")(
[info]                                       sourcecode.Pkg.apply("it.unibo.dap.api"):
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[info]                                         sourcecode.Pkg,
[info]                                       sourcecode.FileName.apply(
[info]                                         "NativeProductApi.scala"):
[info]                                         sourcecode.FileName,
[info]                                       sourcecode.Name.apply("res"):
[info]                                         sourcecode.Name,
[info]                                       sourcecode.Line.apply(44):sourcecode.Line
[info]                                         ,
[info]                                     scribe.mdc.MDC.instance)
[info]                                     val res:
[info]                                       
[info]                                         it.unibo.dap.model.MSet[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       
[info]                                      =
[info]                                       it.unibo.dap.model.MSet.ofList[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](
[info]                                         {
[info]                                           val iseqc_this:
[info]                                             
[info]                                               ProductInterface_this.iseqc[
[info]                                                 scala.scalanative.unsafe.Ptr[
[info]                                                   Byte]
[info]                                               ]
[info]                                             
[info]                                            =
[info]                                             ProductInterface_this.iseqc[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           (
[info]                                             {
[info]                                               given val _$6:
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Tag[
[info]                                                     it.unibo.dap.api.CToken]
[info]                                                 
[info]                                                = it.unibo.dap.api.ctokenTag
[info]                                               {
[info]                                                 given val _$7:
[info]                                                   
[info]                                                     scala.reflect.ClassTag[
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[Byte]
[info]                                                     ]
[info]                                                   
[info]                                                  =
[info]                                                   scala.reflect.ClassTag.apply[
[info]                                                     
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[Byte]
[info]                                                     
[info]                                                   ](
[info]                                                     classOf[
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr
[info]                                                     ]
[info]                                                   )
[info]                                                 scribe.package.info(
[info]                                                   _root_.scala.StringContext.
[info]                                                     apply(
[info]                                                     ["to -> [","]" : String]*).s
[info]                                                     ([_$7.runtimeClass : Any]*)
[info]                                                 )(
[info]                                                   sourcecode.Pkg.apply(
[info]                                                     "it.unibo.dap.api"):
[info]                                                     sourcecode.Pkg,
[info]                                                   sourcecode.FileName.apply(
[info]                                                     "NativeProductApi.scala"):
[info]                                                     sourcecode.FileName,
[info]                                                   sourcecode.Name.apply("res"):
[info]                                                     sourcecode.Name,
[info]                                                   sourcecode.Line.apply(44):
[info]                                                     sourcecode.Line,
[info]                                                   scribe.mdc.MDC.instance)
[info]                                                 it.unibo.dap.api.CArraySeq.apply
[info]                                                   [
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](
[info]                                                   r.eff.elems.unary_!(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   )._1(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   ),
[info]                                                   r.eff.elems.unary_!(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   )._2(
[info]                                                     scala.scalanative.unsafe.Tag
[info]                                                       .materializeCStruct2Tag[
[info]                                                       
[info]                                                         scala.scalanative.unsafe
[info]                                                           .Ptr[
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         ]
[info]                                                       ,
[info]                                                       
[info]                                                         scala.scalanative.unsigned
[info]                                                           .USize
[info]                                                       
[info]                                                     ](
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializePtrTag[
[info]                                                         
[info]                                                           scala.scalanative.unsafe
[info]                                                             .Ptr[Byte]
[info]                                                         
[info]                                                       ](_$6),
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Tag.materializeUSizeTag
[info]                                                     )
[info]                                                   ).toInt
[info]                                                 )(_$6)
[info]                                               }
[info]                                             }
[info]                                           :
[info]                                             Seq[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           )
[info]                                         }.toList
[info]                                       )
[info]                                     scribe.package.info("<=======")(
[info]                                       sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                         sourcecode.Pkg,
[info]                                       sourcecode.FileName.apply(
[info]                                         "NativeProductApi.scala"):
[info]                                         sourcecode.FileName,
[info]                                       sourcecode.Name.apply("res"):
[info]                                         sourcecode.Name,
[info]                                       sourcecode.Line.apply(44):sourcecode.Line
[info]                                         ,
[info]                                     scribe.mdc.MDC.instance)
[info]                                     res:
[info]                                       
[info]                                         it.unibo.dap.model.MSet[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       
[info]                                   }:
[info]                                     it.unibo.dap.model.MSet[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 }
[info]                               },
[info]                               ProductADTsConversions$_this.as[
[info]                                 
[info]                                   ProductInterface_this.IOption[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 
[info]                               ](r.msg)[
[info]                                 Option[scala.scalanative.unsafe.Ptr[Byte]]](
[info]                                 ProductInterface_this.given_Iso_IOption_Option[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               )
[info]                             )
[info]                           scribe.package.info("Conversion ok")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("simulation"):sourcecode.Name
[info]                               ,
[info]                           sourcecode.Line.apply(44):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:
[info]                             
[info]                               it.unibo.dap.model.DAP.Rule[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                             
[info]                         }:
[info]                           it.unibo.dap.model.DAP.Rule[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                       }
[info]                     )
[info]                   )
[info]                   realRules.foreach[Unit]((
[info]                     r:
[info]                       
[info]                         it.unibo.dap.model.DAP.Rule[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       
[info]                   ) =>
[info]                     scribe.package.info(
[info]                       _root_.scala.StringContext.apply(["Rule: ","" : String]*).
[info]                         s([r : Any]*)
[info]                     )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                       sourcecode.Line.apply(44):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                   )
[info]                   it.unibo.dap.api.DASPSimulation.withStaticNeighbors[
[info]                     scala.scalanative.unsafe.Ptr[Byte]](
[info]                     {
[info]                       val fromT_this:
[info]                         
[info]                           ProductInterface_this.ProductADTsConversions.fromT[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         
[info]                        =
[info]                         ProductInterface_this.fromT[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       val ProductADTsConversions$_this:
[info]                         ProductInterface_this.ProductADTsConversions.type =
[info]                         ProductInterface_this.ProductADTsConversions
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface_this :
[info]                             (it.unibo.dap.api.NativeProductApi.interface :
[info]                               it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                                 .type
[info]                             )
[info]                           )
[info]                         
[info]                        = ProductInterface_this
[info]                       it.unibo.dap.model.DAP.State.apply[
[info]                         scala.scalanative.unsafe.Ptr[Byte]](
[info]                         {
[info]                           val ProductADTsConversions$_this:
[info]                             
[info]                               (ProductADTsConversions$_this :
[info]                                 ProductInterface_this.ProductADTsConversions
[info]                                   .type
[info]                               )
[info]                             
[info]                            = ProductADTsConversions$_this
[info]                           {
[info]                             val from_this:
[info]                               
[info]                                 ProductADTsConversions$_this.from[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                               
[info]                              =
[info]                               new ProductADTsConversions$_this.from[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                 ProductADTsConversions$_this.from[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                             val ProductInterface_this:
[info]                               
[info]                                 (ProductInterface_this :
[info]                                   (it.unibo.dap.api.NativeProductApi.interface
[info]                                      :
[info]                                     it.unibo.dap.api.NativeProductApi.
[info]                                       NativeInterface.type
[info]                                   )
[info]                                 )
[info]                               
[info]                              = ProductInterface_this
[info]                             {
[info]                               scribe.package.info("=======>")(
[info]                                 sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                   sourcecode.Pkg,
[info]                                 sourcecode.FileName.apply(
[info]                                   "NativeProductApi.scala"):sourcecode.FileName
[info]                                   ,
[info]                                 sourcecode.Name.apply("simulation"):
[info]                                   sourcecode.Name,
[info]                                 sourcecode.Line.apply(44):sourcecode.Line,
[info]                                 scribe.mdc.MDC.instance)
[info]                               val res:
[info]                                 
[info]                                   it.unibo.dap.model.MSet[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 
[info]                                =
[info]                                 it.unibo.dap.model.MSet.ofList[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]](
[info]                                   {
[info]                                     val iseqc_this:
[info]                                       
[info]                                         ProductInterface_this.iseqc[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       
[info]                                      =
[info]                                       ProductInterface_this.iseqc[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     (
[info]                                       {
[info]                                         given val _$6:
[info]                                           
[info]                                             scala.scalanative.unsafe.Tag[
[info]                                               it.unibo.dap.api.CToken]
[info]                                           
[info]                                          = it.unibo.dap.api.ctokenTag
[info]                                         {
[info]                                           given val _$7:
[info]                                             
[info]                                               scala.reflect.ClassTag[
[info]                                                 scala.scalanative.unsafe.Ptr[
[info]                                                   Byte]
[info]                                               ]
[info]                                             
[info]                                            =
[info]                                             scala.reflect.ClassTag.apply[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ](
[info]                                               classOf[
[info]                                                 scala.scalanative.unsafe.Ptr]
[info]                                             )
[info]                                           scribe.package.info(
[info]                                             _root_.scala.StringContext.apply(
[info]                                               ["to -> [","]" : String]*).s(
[info]                                               [_$7.runtimeClass : Any]*)
[info]                                           )(
[info]                                             sourcecode.Pkg.apply(
[info]                                               "it.unibo.dap.api"):sourcecode.Pkg
[info]                                               ,
[info]                                             sourcecode.FileName.apply(
[info]                                               "NativeProductApi.scala"):
[info]                                               sourcecode.FileName,
[info]                                             sourcecode.Name.apply("res"):
[info]                                               sourcecode.Name,
[info]                                             sourcecode.Line.apply(44):
[info]                                               sourcecode.Line,
[info]                                             scribe.mdc.MDC.instance)
[info]                                           it.unibo.dap.api.CArraySeq.apply[
[info]                                             scala.scalanative.unsafe.Ptr[Byte]](
[info]                                             initialState$proxy1.tokens.elems.
[info]                                               unary_!(
[info]                                               scala.scalanative.unsafe.Tag.
[info]                                                 materializeCStruct2Tag[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 ,
[info]                                                 scala.scalanative.unsigned.USize
[info]                                                 ](
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializePtrTag[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](_$6),
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializeUSizeTag
[info]                                               )
[info]                                             )._1(
[info]                                               scala.scalanative.unsafe.Tag.
[info]                                                 materializeCStruct2Tag[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 ,
[info]                                                 scala.scalanative.unsigned.USize
[info]                                                 ](
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializePtrTag[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](_$6),
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializeUSizeTag
[info]                                               )
[info]                                             ),
[info]                                             initialState$proxy1.tokens.elems.
[info]                                               unary_!(
[info]                                               scala.scalanative.unsafe.Tag.
[info]                                                 materializeCStruct2Tag[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 ,
[info]                                                 scala.scalanative.unsigned.USize
[info]                                                 ](
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializePtrTag[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](_$6),
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializeUSizeTag
[info]                                               )
[info]                                             )._2(
[info]                                               scala.scalanative.unsafe.Tag.
[info]                                                 materializeCStruct2Tag[
[info]                                                 
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   ]
[info]                                                 ,
[info]                                                 scala.scalanative.unsigned.USize
[info]                                                 ](
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializePtrTag[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ](_$6),
[info]                                                 scala.scalanative.unsafe.Tag.
[info]                                                   materializeUSizeTag
[info]                                               )
[info]                                             ).toInt
[info]                                           )(_$6)
[info]                                         }
[info]                                       }
[info]                                     :Seq[scala.scalanative.unsafe.Ptr[Byte]])
[info]                                   }.toList
[info]                                 )
[info]                               scribe.package.info("<=======")(
[info]                                 sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                   sourcecode.Pkg,
[info]                                 sourcecode.FileName.apply(
[info]                                   "NativeProductApi.scala"):sourcecode.FileName
[info]                                   ,
[info]                                 sourcecode.Name.apply("simulation"):
[info]                                   sourcecode.Name,
[info]                                 sourcecode.Line.apply(44):sourcecode.Line,
[info]                                 scribe.mdc.MDC.instance)
[info]                               res:
[info]                                 
[info]                                   it.unibo.dap.model.MSet[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 
[info]                             }:
[info]                               it.unibo.dap.model.MSet[
[info]                                 scala.scalanative.unsafe.Ptr[Byte]]
[info]                           }
[info]                         },
[info]                         ProductADTsConversions$_this.as[
[info]                           
[info]                             ProductInterface_this.IOption[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                         ](initialState$proxy1.msg)[
[info]                           Option[scala.scalanative.unsafe.Ptr[Byte]]](
[info]                           ProductInterface_this.given_Iso_IOption_Option[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         )
[info]                       ):
[info]                         it.unibo.dap.model.DAP.State[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                     },
[info]                     realRules.toSet[
[info]                       
[info]                         it.unibo.dap.model.DAP.Rule[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       
[info]                     ],
[info]                   allNeighbors)(given_Equatable_Token,
[info]                     given_Serializable_Token,
[info]                     ProductInterface_this.given_ExecutionContext)
[info]                 }:
[info]                   it.unibo.dap.api.DASPSimulation[
[info]                     scala.scalanative.unsafe.Ptr[Byte]]
[info]               }
[info]             }
[info]           (try block$proxy1 catch 
[info]             {
[info]               case e @ _ =>
[info]                 scribe.package.error(e.getMessage())(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("simulation"):sourcecode.Name,
[info]                   sourcecode.Line.apply(40):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 scala.scalanative.libc.stdlib.exit(1).asInstanceOf[
[info]                   
[info]                     it.unibo.dap.api.DASPSimulation[
[info]                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                   
[info]                 ]
[info]             }
[info]           ):it.unibo.dap.api.DASPSimulation[scala.scalanative.unsafe.Ptr[Byte]]
[info]         }
[info]       @exported("launch_sim") def launch(
[info]         simulation: it.unibo.dap.api.DASPSimulation[it.unibo.dap.api.CToken],
[info]         port: Int,
[info]         updateFn:
[info]           scala.scalanative.unsafe.CFuncPtr1[
[info]             scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CState], Unit]
[info]       ): Unit =
[info]         {
[info]           val f:
[info]             
[info]               scala.scalanative.unsafe.CFuncPtr1[
[info]                 it.unibo.dap.api.NativeProductApi.NativeInterface.State[
[info]                   it.unibo.dap.api.CToken],
[info]               Unit]
[info]             
[info]            =
[info]             scala.scalanative.unsafe.CFuncPtr1.fromScalaFunction[
[info]               it.unibo.dap.api.NativeProductApi.NativeInterface.State[
[info]                 it.unibo.dap.api.CToken],
[info]             Unit]((
[info]               s:
[info]                 
[info]                   it.unibo.dap.api.NativeProductApi.NativeInterface.State[
[info]                     it.unibo.dap.api.CToken]
[info]                 
[info]             ) =>
[info]               scribe.package.info("update :)")(
[info]                 sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                 sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                   sourcecode.FileName,
[info]                 sourcecode.Name.apply("f"):sourcecode.Name,
[info]                 sourcecode.Line.apply(48):sourcecode.Line,
[info]                 scribe.mdc.MDC.instance)
[info]             )
[info]           {
[info]             val ProductInterface_this:
[info]               
[info]                 (it.unibo.dap.api.NativeProductApi.interface :
[info]                   it.unibo.dap.api.NativeProductApi.NativeInterface.type)
[info]               
[info]              = it.unibo.dap.api.NativeProductApi.NativeInterface
[info]             {
[info]               simulation.launch(port)((
[info]                 s:
[info]                   
[info]                     it.unibo.dap.model.DAP.State[
[info]                       scala.scalanative.unsafe.Ptr[Byte]]
[info]                   
[info]               ) =>
[info]                 {
[info]                   val f1c_this:
[info]                     
[info]                       ProductInterface_this.f1c[
[info]                         ProductInterface_this.State[
[info]                           scala.scalanative.unsafe.Ptr[Byte]],
[info]                       Unit]
[info]                     
[info]                    =
[info]                     ProductInterface_this.f1c[
[info]                       
[info]                         ProductInterface_this.State[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       ,
[info]                     Unit]
[info]                   ((
[info]                     arg1:
[info]                       
[info]                         ProductInterface_this.State[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       
[info]                   ) => f.apply(arg1):
[info]                     (
[info]                       ProductInterface_this.State[
[info]                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                      => Unit)
[info]                   )
[info]                 }.apply(
[info]                   {
[info]                     val toT_this:
[info]                       
[info]                         ProductInterface_this.ProductADTsConversions.toT[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       
[info]                      =
[info]                       ProductInterface_this.toT[
[info]                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                     val ProductADTsConversions$_this:
[info]                       ProductInterface_this.ProductADTsConversions.type =
[info]                       ProductInterface_this.ProductADTsConversions
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface_this :
[info]                           (it.unibo.dap.api.NativeProductApi.interface :
[info]                             it.unibo.dap.api.NativeProductApi.NativeInterface
[info]                               .type
[info]                           )
[info]                         )
[info]                       
[info]                      = ProductInterface_this
[info]                     ProductInterface_this.State.apply[
[info]                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                       {
[info]                         val to_this:
[info]                           
[info]                             ProductADTsConversions$_this.to[
[info]                               scala.scalanative.unsafe.Ptr[Byte]]
[info]                           
[info]                          =
[info]                           ProductADTsConversions$_this.to[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface_this :
[info]                               (it.unibo.dap.api.NativeProductApi.interface :
[info]                                 it.unibo.dap.api.NativeProductApi.
[info]                                   NativeInterface.type
[info]                               )
[info]                             )
[info]                           
[info]                          = ProductInterface_this
[info]                         ProductInterface_this.MSet.apply[
[info]                           scala.scalanative.unsafe.Ptr[Byte]](
[info]                           {
[info]                             val NativeADTs_this:
[info]                               
[info]                                 (ProductInterface_this :
[info]                                   (ProductInterface_this :
[info]                                     (it.unibo.dap.api.NativeProductApi.interface
[info]                                        :
[info]                                       it.unibo.dap.api.NativeProductApi.
[info]                                         NativeInterface.type
[info]                                     )
[info]                                   )
[info]                                 )
[info]                               
[info]                              = ProductInterface_this
[info]                             {
[info]                               val iseqcc_this:
[info]                                 
[info]                                   ProductInterface_this.iseqcc[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                                 
[info]                                =
[info]                                 new NativeADTs_this.iseqcc[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]():
[info]                                   NativeADTs_this.iseqcc[
[info]                                     scala.scalanative.unsafe.Ptr[Byte]]
[info]                               val NativeADTs_this:
[info]                                 
[info]                                   (ProductInterface_this :
[info]                                     (ProductInterface_this :
[info]                                       (it.unibo.dap.api.NativeProductApi.
[info]                                         interface :
[info]                                         it.unibo.dap.api.NativeProductApi.
[info]                                           NativeInterface.type
[info]                                       )
[info]                                     )
[info]                                   )
[info]                                 
[info]                                = ProductInterface_this
[info]                               val s$proxy1:
[info]                                 List[scala.scalanative.unsafe.Ptr[Byte]] =
[info]                                 s.tokens.asList.toSeq
[info]                               {
[info]                                 given val _$8:
[info]                                   
[info]                                     scala.scalanative.unsafe.Tag[
[info]                                       it.unibo.dap.api.CToken]
[info]                                   
[info]                                  = it.unibo.dap.api.ctokenTag
[info]                                 {
[info]                                   given val _$9:
[info]                                     
[info]                                       scala.reflect.ClassTag[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     
[info]                                    =
[info]                                     scala.reflect.ClassTag.apply[
[info]                                       scala.scalanative.unsafe.Ptr[Byte]](
[info]                                       classOf[scala.scalanative.unsafe.Ptr])
[info]                                   scribe.package.info("from <-")(
[info]                                     sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                       sourcecode.Pkg,
[info]                                     sourcecode.FileName.apply(
[info]                                       "NativeProductApi.scala"):
[info]                                       sourcecode.FileName,
[info]                                     sourcecode.Name.apply("launch"):
[info]                                       sourcecode.Name,
[info]                                     sourcecode.Line.apply(49):sourcecode.Line,
[info]                                     scribe.mdc.MDC.instance)
[info]                                   val ptr:
[info]                                     
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ]
[info]                                     
[info]                                    =
[info]                                     {
[info]                                       val factor$proxy5: Int =
[info]                                         it.unibo.dap.utils.CUtils.
[info]                                           freshPointer$default$1[
[info]                                           
[info]                                             it.unibo.dap.api.CSeq[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                         ]
[info]                                       {
[info]                                         val obj$proxy5:
[info]                                           
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               it.unibo.dap.api.CSeq[
[info]                                                 scala.scalanative.unsafe.Ptr[
[info]                                                   Byte]
[info]                                               ]
[info]                                             ]
[info]                                           
[info]                                          =
[info]                                           scala.scalanative.libc.stdlib.malloc(
[info]                                             (
[info]                                               scala.scalanative.runtime.
[info]                                                 Intrinsics.castRawSizeToInt(
[info]                                                 scala.scalanative.runtime.
[info]                                                   Intrinsics.sizeOf[
[info]                                                   
[info]                                                     it.unibo.dap.api.CSeq[
[info]                                                       scala.scalanative.unsafe.
[info]                                                         Ptr[Byte]
[info]                                                     ]
[info]                                                   
[info]                                                 ]
[info]                                               )
[info]                                             :Int).*(factor$proxy5)
[info]                                           ).asInstanceOf[
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               
[info]                                                 it.unibo.dap.api.CSeq[
[info]                                                   scala.scalanative.unsafe.Ptr[
[info]                                                     Byte]
[info]                                                 ]
[info]                                               
[info]                                             ]
[info]                                           ]
[info]                                         (if obj$proxy5.==(null) then
[info]                                           throw 
[info]                                             new NullPointerException(
[info]                                               _root_.scala.StringContext.apply(
[info]                                                 ["Object "," is null" : String]*
[info]                                                 ).s([obj$proxy5 : Any]*)
[info]                                             )
[info]                                          else obj$proxy5):
[info]                                           
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               it.unibo.dap.api.CSeq[
[info]                                                 scala.scalanative.unsafe.Ptr[
[info]                                                   Byte]
[info]                                               ]
[info]                                             ]
[info]                                           
[info]                                       }:
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           
[info]                                             it.unibo.dap.api.CSeq[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                         ]
[info]                                     }
[info]                                   ptr.unary_!(
[info]                                     scala.scalanative.unsafe.Tag.
[info]                                       materializeCStruct2Tag[
[info]                                       
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ,
[info]                                     scala.scalanative.unsigned.USize](
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializePtrTag[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](_$8)
[info]                                         ,
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeUSizeTag
[info]                                     )
[info]                                   )._1_=(
[info]                                     {
[info]                                       val factor$proxy6: Int = s$proxy1.length
[info]                                       {
[info]                                         val obj$proxy6:
[info]                                           
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                          =
[info]                                           scala.scalanative.libc.stdlib.malloc(
[info]                                             (
[info]                                               scala.scalanative.runtime.
[info]                                                 Intrinsics.castRawSizeToInt(
[info]                                                 scala.scalanative.runtime.
[info]                                                   Intrinsics.sizeOf[
[info]                                                   
[info]                                                     scala.scalanative.unsafe.Ptr
[info]                                                       [Byte]
[info]                                                   
[info]                                                 ]
[info]                                               )
[info]                                             :Int).*(factor$proxy6)
[info]                                           ).asInstanceOf[
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           ]
[info]                                         (if obj$proxy6.==(null) then
[info]                                           throw 
[info]                                             new NullPointerException(
[info]                                               _root_.scala.StringContext.apply(
[info]                                                 ["Object "," is null" : String]*
[info]                                                 ).s([obj$proxy6 : Any]*)
[info]                                             )
[info]                                          else obj$proxy6):
[info]                                           
[info]                                             scala.scalanative.unsafe.Ptr[
[info]                                               scala.scalanative.unsafe.Ptr[Byte]
[info]                                               ]
[info]                                           
[info]                                       }:
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                     }
[info]                                   )(
[info]                                     scala.scalanative.unsafe.Tag.
[info]                                       materializeCStruct2Tag[
[info]                                       
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ,
[info]                                     scala.scalanative.unsigned.USize](
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializePtrTag[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](_$8)
[info]                                         ,
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeUSizeTag
[info]                                     )
[info]                                   )
[info]                                   ptr.unary_!(
[info]                                     scala.scalanative.unsafe.Tag.
[info]                                       materializeCStruct2Tag[
[info]                                       
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ,
[info]                                     scala.scalanative.unsigned.USize](
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializePtrTag[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](_$8)
[info]                                         ,
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeUSizeTag
[info]                                     )
[info]                                   )._2_=(
[info]                                     scala.scalanative.unsigned.UnsignedRichInt(
[info]                                       s$proxy1.length).toCSize
[info]                                   )(
[info]                                     scala.scalanative.unsafe.Tag.
[info]                                       materializeCStruct2Tag[
[info]                                       
[info]                                         scala.scalanative.unsafe.Ptr[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ,
[info]                                     scala.scalanative.unsigned.USize](
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializePtrTag[
[info]                                         scala.scalanative.unsafe.Ptr[Byte]](_$8)
[info]                                         ,
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeUSizeTag
[info]                                     )
[info]                                   )
[info]                                   intWrapper(0).until(s$proxy1.length).foreach[
[info]                                     Unit]((i: Int) =>
[info]                                     ptr.unary_!(
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeCStruct2Tag[
[info]                                         
[info]                                           scala.scalanative.unsafe.Ptr[
[info]                                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                                         ,
[info]                                       scala.scalanative.unsigned.USize](
[info]                                         scala.scalanative.unsafe.Tag.
[info]                                           materializePtrTag[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]](
[info]                                           _$8),
[info]                                         scala.scalanative.unsafe.Tag.
[info]                                           materializeUSizeTag
[info]                                       )
[info]                                     )._1(
[info]                                       scala.scalanative.unsafe.Tag.
[info]                                         materializeCStruct2Tag[
[info]                                         
[info]                                           scala.scalanative.unsafe.Ptr[
[info]                                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                                         ,
[info]                                       scala.scalanative.unsigned.USize](
[info]                                         scala.scalanative.unsafe.Tag.
[info]                                           materializePtrTag[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]](
[info]                                           _$8),
[info]                                         scala.scalanative.unsafe.Tag.
[info]                                           materializeUSizeTag
[info]                                       )
[info]                                     ).update(i, s$proxy1.apply(i))(_$8)
[info]                                   )
[info]                                   ptr:
[info]                                     
[info]                                       scala.scalanative.unsafe.Ptr[
[info]                                         it.unibo.dap.api.CSeq[
[info]                                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                                       ]
[info]                                     
[info]                                 }
[info]                               }:
[info]                                 NativeADTs_this.ISeq[
[info]                                   scala.scalanative.unsafe.Ptr[Byte]]
[info]                             }
[info]                           }
[info]                         ):
[info]                           ProductInterface_this.MSet[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                       },
[info]                       ProductADTsConversions$_this.back[
[info]                         Option[scala.scalanative.unsafe.Ptr[Byte]]](s.msg)[
[info]                         
[info]                           ProductInterface_this.IOption[
[info]                             scala.scalanative.unsafe.Ptr[Byte]]
[info]                         
[info]                       ](
[info]                         ProductInterface_this.given_Iso_IOption_Option[
[info]                           scala.scalanative.unsafe.Ptr[Byte]]
[info]                       )
[info]                     ):
[info]                       ProductInterface_this.State[
[info]                         scala.scalanative.unsafe.Ptr[Byte]]
[info]                   }
[info]                 )
[info]               )(ProductInterface_this.given_ExecutionContext)
[info]               ()
[info]             }:Unit
[info]           }
[info]         }
[info]     }
[info]     trait NativeADTs() extends Object, it.unibo.dap.api.NativeProductApi.ADTs {
[info]       override type IString = scala.scalanative.unsafe.CString
[info]       override final lazy given val given_Iso_IString_String:
[info]         it.unibo.dap.utils.Iso[NativeADTs.this.IString, String] =
[info]         {
[info]           val toFn$proxy1:
[info]             scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar] =>
[info]               String
[info]            = (_$3: scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar])
[info]              =>
[info]             scala.scalanative.unsafe.fromCString(_$3,
[info]               scala.scalanative.unsafe.package.fromCString$default$2)
[info]           val fromFn$proxy1:
[info]             String =>
[info]               scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]
[info]            = (s: String) =>
[info]             {
[info]               val ptr:
[info]                 scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar] =
[info]                 {
[info]                   val factor$proxy7: Int = s.length().+(1)
[info]                   {
[info]                     val obj$proxy7:
[info]                       
[info]                         scala.scalanative.unsafe.Ptr[
[info]                           scala.scalanative.unsafe.CChar]
[info]                       
[info]                      =
[info]                       scala.scalanative.libc.stdlib.malloc(
[info]                         (
[info]                           scala.scalanative.runtime.Intrinsics.castRawSizeToInt(
[info]                             scala.scalanative.runtime.Intrinsics.sizeOf[
[info]                               scala.scalanative.unsafe.CChar]
[info]                           )
[info]                         :Int).*(factor$proxy7)
[info]                       ).asInstanceOf[
[info]                         scala.scalanative.unsafe.Ptr[
[info]                           scala.scalanative.unsafe.CChar]
[info]                       ]
[info]                     (if obj$proxy7.==(null) then
[info]                       throw 
[info]                         new NullPointerException(
[info]                           _root_.scala.StringContext.apply(
[info]                             ["Object "," is null" : String]*).s(
[info]                             [obj$proxy7 : Any]*)
[info]                         )
[info]                      else obj$proxy7):
[info]                       
[info]                         scala.scalanative.unsafe.Ptr[
[info]                           scala.scalanative.unsafe.CChar]
[info]                       
[info]                   }:scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]
[info]                   }
[info]               intWrapper(0).until(s.length()).foreach[Unit]((i: Int) =>
[info]                 ptr.update(i, s.charAt(i).toByte)(
[info]                   scala.scalanative.unsafe.Tag.materializeByteTag)
[info]               )
[info]               ptr.update(s.length(), 0.toByte)(
[info]                 scala.scalanative.unsafe.Tag.materializeByteTag)
[info]               ptr:scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]
[info]             }
[info]           {
[info]             final class $anon() extends Object(), it.unibo.dap.utils.Iso[
[info]               scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar],
[info]               String] {
[info]               def to(
[info]                 a: scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar])
[info]                 : String = toFn$proxy1.apply(a)
[info]               def from(b: String):
[info]                 scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar] =
[info]                 fromFn$proxy1.apply(b)
[info]             }
[info]             new $anon():
[info]               
[info]                 it.unibo.dap.utils.Iso[
[info]                   scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar],
[info]                   String]
[info]               
[info]           }:
[info]             it.unibo.dap.utils.Iso[
[info]               scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar],
[info]               String]
[info]         }
[info]       override type IOption[T >: Nothing <: Any] = T | Null
[info]       override final given def given_Iso_IOption_Option[T >: Nothing <: Any]:
[info]         it.unibo.dap.utils.Iso[NativeADTs.this.IOption[T], Option[T]] =
[info]         {
[info]           val toFn$proxy2: T | Null => Option[T] = (t: T | Null) =>
[info]             Option.when[T](t.!=(null))(t.asInstanceOf[T])
[info]           val fromFn$proxy2: Option[T] => T | Null = (_$4: Option[T]) =>
[info]             _$4.orNull[T | Null](<:<.refl[Null])
[info]           {
[info]             final class $anon() extends Object(), it.unibo.dap.utils.Iso[
[info]               T | Null, Option[T]] {
[info]               def to(a: T | Null): Option[T] = toFn$proxy2.apply(a)
[info]               def from(b: Option[T]): T | Null = fromFn$proxy2.apply(b)
[info]             }
[info]             new $anon():it.unibo.dap.utils.Iso[T | Null, Option[T]]
[info]           }:it.unibo.dap.utils.Iso[T | Null, Option[T]]
[info]         }
[info]       override type ISeq[T >: Nothing <: Any] =
[info]         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CSeq[T]]
[info]       given class iseqc[T >: Nothing <: Any]() extends
[info]         Conversion[NativeADTs.this.ISeq[iseqc.this.T], Seq[iseqc.this.T]]() {
[info]         T
[info]         inline def apply(x: NativeADTs.this.ISeq[iseqc.this.T]):
[info]           Seq[iseqc.this.T] =
[info]           (implicit match 
[info]             {
[info]               case given _$6 @ _:scala.scalanative.unsafe.Tag[iseqc.this.T] =>
[info]                 implicit match 
[info]                   {
[info]                     case given _$7 @ _:scala.reflect.ClassTag[iseqc.this.T] =>
[info]                       scribe.package.info(
[info]                         _root_.scala.StringContext.apply(
[info]                           ["to -> [","]" : String]*).s(
[info]                           [
[info]                             summon[scala.reflect.ClassTag[iseqc.this.T]](_$7).
[info]                               runtimeClass
[info]                            : Any]*
[info]                         )
[info]                       )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                         sourcecode.Name.generate, sourcecode.Line.generate,
[info]                         scribe.mdc.MDC.instance)
[info]                       it.unibo.dap.api.CArraySeq.apply[T](
[info]                         x.unary_!(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$6),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         )._1(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$6),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         ),
[info]                         x.unary_!(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$6),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         )._2(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$6),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         ).toInt
[info]                       )(_$6)
[info]                     case _ =>
[info]                       scribe.package.error("[to] I don\'t have a class tag")(
[info]                         sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                         sourcecode.Name.generate, sourcecode.Line.generate,
[info]                         scribe.mdc.MDC.instance)
[info]                       ???
[info]                   }
[info]               case _ =>
[info]                 scribe.package.error("[to] I don\'t have a tag")(
[info]                   sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                   sourcecode.Name.generate, sourcecode.Line.generate,
[info]                   scribe.mdc.MDC.instance)
[info]                 ???
[info]             }
[info]           ):Seq[iseqc.this.T]
[info]         private def apply$retainedBody(x: NativeADTs.this.ISeq[T]): Seq[T] =
[info]           {
[info]             scribe.package.error("[to] I don\'t have a tag")(
[info]               sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                 sourcecode.FileName,
[info]               sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(75):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]             ???
[info]           }:Seq[iseqc.this.T]
[info]       }
[info]       final given def iseqc[T >: Nothing <: Any]: NativeADTs.this.iseqc[T] =
[info]         new NativeADTs.this.iseqc[T]()
[info]       given class iseqcc[T >: Nothing <: Any]() extends
[info]         Conversion[Seq[iseqcc.this.T], NativeADTs.this.ISeq[iseqcc.this.T]]() {
[info]         T
[info]         inline def apply(s: Seq[iseqcc.this.T]):
[info]           NativeADTs.this.ISeq[iseqcc.this.T] =
[info]           (implicit match 
[info]             {
[info]               case given _$8 @ _:scala.scalanative.unsafe.Tag[iseqcc.this.T] =>
[info]                 implicit match 
[info]                   {
[info]                     case given _$9 @ _:scala.reflect.ClassTag[iseqcc.this.T] =>
[info]                       scribe.package.info("from <-")(sourcecode.Pkg.generate,
[info]                         sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                         sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]                       val ptr:
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CSeq[T]]
[info]                          =
[info]                         it.unibo.dap.utils.CUtils.freshPointer[
[info]                           it.unibo.dap.api.CSeq[iseqcc.this.T]](
[info]                           it.unibo.dap.utils.CUtils.freshPointer$default$1[
[info]                             it.unibo.dap.api.CSeq[T]]
[info]                         )
[info]                       ptr.unary_!(
[info]                         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                           scala.scalanative.unsafe.Ptr[T],
[info]                           scala.scalanative.unsigned.USize](
[info]                           scala.scalanative.unsafe.Tag.materializePtrTag[T](_$8)
[info]                             ,
[info]                         scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                       )._1_=(
[info]                         it.unibo.dap.utils.CUtils.freshPointer[iseqcc.this.T](
[info]                           s.length)
[info]                       )(
[info]                         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                           scala.scalanative.unsafe.Ptr[T],
[info]                           scala.scalanative.unsigned.USize](
[info]                           scala.scalanative.unsafe.Tag.materializePtrTag[T](_$8)
[info]                             ,
[info]                         scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                       )
[info]                       ptr.unary_!(
[info]                         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                           scala.scalanative.unsafe.Ptr[T],
[info]                           scala.scalanative.unsigned.USize](
[info]                           scala.scalanative.unsafe.Tag.materializePtrTag[T](_$8)
[info]                             ,
[info]                         scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                       )._2_=(
[info]                         scala.scalanative.unsigned.UnsignedRichInt(s.length).
[info]                           toCSize
[info]                       )(
[info]                         scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                           scala.scalanative.unsafe.Ptr[T],
[info]                           scala.scalanative.unsigned.USize](
[info]                           scala.scalanative.unsafe.Tag.materializePtrTag[T](_$8)
[info]                             ,
[info]                         scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                       )
[info]                       intWrapper(0).until(s.length).foreach[Unit]((i: Int) =>
[info]                         ptr.unary_!(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$8),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         )._1(
[info]                           scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                             scala.scalanative.unsafe.Ptr[T],
[info]                             scala.scalanative.unsigned.USize](
[info]                             scala.scalanative.unsafe.Tag.materializePtrTag[T](
[info]                               _$8),
[info]                             scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                         ).update(i, s.apply(i))(_$8)
[info]                       )
[info]                       ptr:scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CSeq[T]]
[info]                     case _ =>
[info]                       scribe.package.error("[back] I don\'t have a class tag")(
[info]                         sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                         sourcecode.Name.generate, sourcecode.Line.generate,
[info]                         scribe.mdc.MDC.instance)
[info]                       ???
[info]                   }
[info]               case _ =>
[info]                 scribe.package.error("[back] I don\'t have a tag!")(
[info]                   sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                   sourcecode.Name.generate, sourcecode.Line.generate,
[info]                   scribe.mdc.MDC.instance)
[info]                 ???
[info]             }
[info]           ):NativeADTs.this.ISeq[iseqcc.this.T]
[info]         private def apply$retainedBody(s: Seq[T]): NativeADTs.this.ISeq[T] =
[info]           {
[info]             val NativeADTs_this:
[info]               (NativeADTs.this : it.unibo.dap.api.NativeProductApi.NativeADTs)
[info]                = (this:NativeADTs.this.iseqcc[T]).1_<outer>
[info]             {
[info]               scribe.package.error("[back] I don\'t have a tag!")(
[info]                 sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                 sourcecode.FileName.apply("NativeProductApi.scala"):
[info]                   sourcecode.FileName,
[info]                 sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                 sourcecode.Line.apply(87):sourcecode.Line,
[info]                 scribe.mdc.MDC.instance)
[info]               ???
[info]             }:NativeADTs_this.ISeq[iseqcc.this.T]
[info]           }
[info]       }
[info]       final inline given def iseqcc[T >: Nothing <: Any]:
[info]         NativeADTs.this.iseqcc[T] =
[info]         new NativeADTs.this.iseqcc[T]():NativeADTs.this.iseqcc[T]
[info]       private final given def iseqcc$retainedBody[T]: NativeADTs.this.iseqcc[T]
[info]          = new NativeADTs.this.iseqcc[T]():NativeADTs.this.iseqcc[T]
[info]       override type IFunction1[T1 >: Nothing <: Any, R >: Nothing <: Any] =
[info]         scala.scalanative.unsafe.CFuncPtr1[T1, R]
[info]       given class f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]() extends
[info]         Conversion[NativeADTs.this.IFunction1[f1c.this.T1, f1c.this.R], T1 => R]
[info]         () {
[info]         T1
[info]         R
[info]         inline def apply(f: NativeADTs.this.IFunction1[f1c.this.T1, f1c.this.R])
[info]           : T1 => R = (arg1: T1) => f.apply(arg1):(T1 => R)
[info]         private def apply$retainedBody(
[info]           f: scala.scalanative.unsafe.CFuncPtr1[T1, R]): T1 => R =
[info]           (arg1: T1) => f.apply(arg1):(T1 => R)
[info]       }
[info]       final given def f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]:
[info]         NativeADTs.this.f1c[T1, R] = new NativeADTs.this.f1c[T1, R]()
[info]       override type IFunction2[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any] = scala.scalanative.unsafe.CFuncPtr2[T1, T2, R]
[info]       given class f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]() extends
[info]         Conversion[
[info]           NativeADTs.this.IFunction2[f2c.this.T1, f2c.this.T2, f2c.this.R],
[info]           (T1, T2) => R]
[info]       () {
[info]         T1
[info]         T2
[info]         R
[info]         inline def apply(
[info]           f: NativeADTs.this.IFunction2[f2c.this.T1, f2c.this.T2, f2c.this.R]):
[info]           (T1, T2) => R =
[info]           (arg1: T1, arg2: T2) => f.apply(arg1, arg2):((T1, T2) => R)
[info]         private def apply$retainedBody(
[info]           f: scala.scalanative.unsafe.CFuncPtr2[T1, T2, R]): (T1, T2) => R =
[info]           (arg1: T1, arg2: T2) => f.apply(arg1, arg2):((T1, T2) => R)
[info]       }
[info]       final given def f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]: NativeADTs.this.f2c[T1, T2, R] =
[info]         new NativeADTs.this.f2c[T1, T2, R]()
[info]       final lazy given val toNeighbor:
[info]         Conversion[it.unibo.dap.api.CNeighbor, NativeADTs.this.Neighbor] = (
[info]         _$5: it.unibo.dap.api.CNeighbor) =>
[info]         _$5._1(
[info]           scala.scalanative.unsafe.Tag.materializeCStruct1Tag[
[info]             scala.scalanative.unsafe.Ptr[scala.scalanative.unsafe.CChar]](
[info]             it.unibo.dap.api.ctokenTag)
[info]         )
[info]       final lazy given val toRule:
[info]         Conversion[it.unibo.dap.api.CRule,
[info]           NativeADTs.this.Rule[it.unibo.dap.api.CToken]]
[info]        = (r: it.unibo.dap.api.CRule) =>
[info]         this.Rule.apply[scala.scalanative.unsafe.Ptr[Byte]](
[info]           pre =
[info]             scala.util.chaining.scalaUtilChainingOps[
[info]               
[info]                 scala.scalanative.unsafe.Ptr[
[info]                   it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]               
[info]             ](
[info]               r._1(
[info]                 scala.scalanative.unsafe.Tag.materializeCStruct4Tag[
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                   ,
[info]                 Double,
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                   ,
[info]                 scala.scalanative.unsafe.Ptr[Byte]](
[info]                   scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                     
[info]                       scala.scalanative.unsafe.CStruct2[
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                         scala.scalanative.libc.stddef.size_t]
[info]                     
[info]                   ](
[info]                     scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.unsigned.USize](
[info]                       it.unibo.dap.api.given_Tag_Ptr,
[info]                       scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                   ),
[info]                 scala.scalanative.unsafe.Tag.materializeDoubleTag,
[info]                   scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                     
[info]                       scala.scalanative.unsafe.CStruct2[
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                         scala.scalanative.libc.stddef.size_t]
[info]                     
[info]                   ](
[info]                     scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.unsigned.USize](
[info]                       it.unibo.dap.api.given_Tag_Ptr,
[info]                       scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                   ),
[info]                 it.unibo.dap.api.ctokenTag)
[info]               )
[info]             ).pipe[NativeADTs.this.MSet[scala.scalanative.unsafe.Ptr[Byte]]]((
[info]               pre:
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 
[info]             ) => this.MSet.apply[scala.scalanative.unsafe.Ptr[Byte]](pre))
[info]           ,
[info]           rate =
[info]             r._2(
[info]               scala.scalanative.unsafe.Tag.materializeCStruct4Tag[
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 ,
[info]               Double,
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 ,
[info]               scala.scalanative.unsafe.Ptr[Byte]](
[info]                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                   
[info]                     scala.scalanative.unsafe.CStruct2[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.libc.stddef.size_t]
[info]                   
[info]                 ](
[info]                   scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                     scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                     scala.scalanative.unsigned.USize](
[info]                     it.unibo.dap.api.given_Tag_Ptr,
[info]                     scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                 ),
[info]               scala.scalanative.unsafe.Tag.materializeDoubleTag,
[info]                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                   
[info]                     scala.scalanative.unsafe.CStruct2[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.libc.stddef.size_t]
[info]                   
[info]                 ](
[info]                   scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                     scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                     scala.scalanative.unsigned.USize](
[info]                     it.unibo.dap.api.given_Tag_Ptr,
[info]                     scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                 ),
[info]               it.unibo.dap.api.ctokenTag)
[info]             )
[info]           ,
[info]           eff =
[info]             scala.util.chaining.scalaUtilChainingOps[
[info]               
[info]                 scala.scalanative.unsafe.Ptr[
[info]                   it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]               
[info]             ](
[info]               r._3(
[info]                 scala.scalanative.unsafe.Tag.materializeCStruct4Tag[
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                   ,
[info]                 Double,
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                   ,
[info]                 scala.scalanative.unsafe.Ptr[Byte]](
[info]                   scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                     
[info]                       scala.scalanative.unsafe.CStruct2[
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                         scala.scalanative.libc.stddef.size_t]
[info]                     
[info]                   ](
[info]                     scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.unsigned.USize](
[info]                       it.unibo.dap.api.given_Tag_Ptr,
[info]                       scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                   ),
[info]                 scala.scalanative.unsafe.Tag.materializeDoubleTag,
[info]                   scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                     
[info]                       scala.scalanative.unsafe.CStruct2[
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                         scala.scalanative.libc.stddef.size_t]
[info]                     
[info]                   ](
[info]                     scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.unsigned.USize](
[info]                       it.unibo.dap.api.given_Tag_Ptr,
[info]                       scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                   ),
[info]                 it.unibo.dap.api.ctokenTag)
[info]               )
[info]             ).pipe[NativeADTs.this.MSet[scala.scalanative.unsafe.Ptr[Byte]]]((
[info]               eff:
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 
[info]             ) => this.MSet.apply[scala.scalanative.unsafe.Ptr[Byte]](eff))
[info]           ,
[info]           msg =
[info]             r._4(
[info]               scala.scalanative.unsafe.Tag.materializeCStruct4Tag[
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 ,
[info]               Double,
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 ,
[info]               scala.scalanative.unsafe.Ptr[Byte]](
[info]                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                   
[info]                     scala.scalanative.unsafe.CStruct2[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.libc.stddef.size_t]
[info]                   
[info]                 ](
[info]                   scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                     scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                     scala.scalanative.unsigned.USize](
[info]                     it.unibo.dap.api.given_Tag_Ptr,
[info]                     scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                 ),
[info]               scala.scalanative.unsafe.Tag.materializeDoubleTag,
[info]                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                   
[info]                     scala.scalanative.unsafe.CStruct2[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.libc.stddef.size_t]
[info]                   
[info]                 ](
[info]                   scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                     scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                     scala.scalanative.unsigned.USize](
[info]                     it.unibo.dap.api.given_Tag_Ptr,
[info]                     scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                 ),
[info]               it.unibo.dap.api.ctokenTag)
[info]             )
[info]         )
[info]       final lazy given val toState:
[info]         Conversion[it.unibo.dap.api.CState,
[info]           NativeADTs.this.State[it.unibo.dap.api.CToken]]
[info]        = (s: it.unibo.dap.api.CState) =>
[info]         this.State.apply[scala.scalanative.unsafe.Ptr[Byte]](
[info]           tokens =
[info]             this.MSet.apply[scala.scalanative.unsafe.Ptr[Byte]](
[info]               s._1(
[info]                 scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                   
[info]                     scala.scalanative.unsafe.Ptr[
[info]                       it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                   ,
[info]                 scala.scalanative.unsafe.Ptr[Byte]](
[info]                   scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                     
[info]                       scala.scalanative.unsafe.CStruct2[
[info]                         scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                         scala.scalanative.libc.stddef.size_t]
[info]                     
[info]                   ](
[info]                     scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.unsigned.USize](
[info]                       it.unibo.dap.api.given_Tag_Ptr,
[info]                       scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                   ),
[info]                 it.unibo.dap.api.ctokenTag)
[info]               )
[info]             )
[info]           ,
[info]           msg =
[info]             s._2(
[info]               scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                 
[info]                   scala.scalanative.unsafe.Ptr[
[info]                     it.unibo.dap.api.CSeq[it.unibo.dap.api.CToken]]
[info]                 ,
[info]               scala.scalanative.unsafe.Ptr[Byte]](
[info]                 scala.scalanative.unsafe.Tag.materializePtrTag[
[info]                   
[info]                     scala.scalanative.unsafe.CStruct2[
[info]                       scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                       scala.scalanative.libc.stddef.size_t]
[info]                   
[info]                 ](
[info]                   scala.scalanative.unsafe.Tag.materializeCStruct2Tag[
[info]                     scala.scalanative.unsafe.Ptr[it.unibo.dap.api.CToken],
[info]                     scala.scalanative.unsigned.USize](
[info]                     it.unibo.dap.api.given_Tag_Ptr,
[info]                     scala.scalanative.unsafe.Tag.materializeUSizeTag)
[info]                 ),
[info]               it.unibo.dap.api.ctokenTag)
[info]             )
[info]         )
[info]       final lazy given val given_Conversion_State_CState:
[info]         Conversion[NativeADTs.this.State[it.unibo.dap.api.CToken],
[info]           it.unibo.dap.api.CState]
[info]        = (s: NativeADTs.this.State[it.unibo.dap.api.CToken]) =>
[info]         {
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(
[info]               ["Converting State to CState but i don\'t know how to do it" :
[info]                 String]*
[info]             ).s([ : Any]*)
[info]           )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("NativeProductApi.scala"):
[info]               sourcecode.FileName,
[info]             sourcecode.Name.apply("given_Conversion_State_CState"):
[info]               sourcecode.Name,
[info]           sourcecode.Line.apply(120):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           ???
[info]         }
[info]     }
[info]   }
[info] }
[warn] 8 warnings found
[warn] 12 warnings found
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/native/src/main/scala/it/unibo/dap/utils/CUtils.scala
[info] package it.unibo.dap.utils {
[info]   import scala.scalanative.unsafe.{sizeOf, Ptr}
[info]   import scala.scalanative.libc.stdlib
[info]   import scala.reflect.ClassTag
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @SuppressWarnings(
[info]     value =
[info]       Array.apply[String](
[info]         ["scalafix:DisableSyntax.asInstanceOf","scalafix:DisableSyntax.null" :
[info]           String]*
[info]       )(scala.reflect.ClassTag.apply[String](classOf[String]))
[info]   ) final lazy module val CUtils: it.unibo.dap.utils.CUtils =
[info]     new it.unibo.dap.utils.CUtils()
[info]   @SourceFile("dap/native/src/main/scala/it/unibo/dap/utils/CUtils.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @SuppressWarnings(
[info]     value =
[info]       Array.apply[String](
[info]         ["scalafix:DisableSyntax.asInstanceOf","scalafix:DisableSyntax.null" :
[info]           String]*
[info]       )(scala.reflect.ClassTag.apply[String](classOf[String]))
[info]   ) final module class CUtils() extends Object() {
[info]     this: it.unibo.dap.utils.CUtils.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.CUtils.type])
[info]     inline def freshPointer[T >: Nothing <: Any](factor: Int):
[info]       scala.scalanative.unsafe.Ptr[T] =
[info]       it.unibo.dap.utils.CUtils.requireNonNull[scala.scalanative.unsafe.Ptr[T]](
[info]         scala.scalanative.libc.stdlib.malloc(
[info]           scala.scalanative.unsafe.sizeOf[T].*(factor)).asInstanceOf[
[info]           scala.scalanative.unsafe.Ptr[T]]
[info]       ):scala.scalanative.unsafe.Ptr[T]
[info]     def freshPointer$default$1[T >: Nothing <: Any]: Int @uncheckedVariance = 1
[info]     inline def requireNonNull[T >: Nothing <: Any](obj: T): T =
[info]       (if obj.==(null) then
[info]         throw 
[info]           new NullPointerException(
[info]             _root_.scala.StringContext.apply(["Object "," is null" : String]*).s
[info]               ([obj : Any]*)
[info]           )
[info]        else obj):T
[info]     inline def withLogging[T >: Nothing <: Any](block: => T): T =
[info]       (try block catch 
[info]         {
[info]           case e @ _ =>
[info]             scribe.package.error(e.getMessage())(sourcecode.Pkg.generate,
[info]               sourcecode.FileName.generate, sourcecode.Name.generate,
[info]               sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]             scala.scalanative.libc.stdlib.exit(1).asInstanceOf[T]
[info]         }
[info]       ):T
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/Api.scala
[info] package it.unibo.dap.api {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/Api.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Api() extends Object {
[info]     val interface: Api.this.Interface
[info]     trait ADTs() extends Object {
[info]       import it.unibo.dap.utils.Iso
[info]       export scala.scalajs.js.annotation.{JSExport, JSExportAll}
[info]       @SourceFile(
[info]         "src/main/scala/scala/scalajs/js/annotation/ExportAnnotations.scala")
[info]         final type JSExport = scala.scalajs.js.annotation.JSExport
[info]       @SourceFile(
[info]         "src/main/scala/scala/scalajs/js/annotation/ExportAnnotations.scala")
[info]         final type JSExportAll = scala.scalajs.js.annotation.JSExportAll
[info]       type IString >: Nothing <: Any
[info]       lazy given val given_Iso_IString_String:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IString, String]
[info]       type IOption[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def given_Iso_IOption_Option[T >: Nothing <: Any]:
[info]         it.unibo.dap.utils.Iso[ADTs.this.IOption[T], Option[T]]
[info]       type ISeq[T >: Nothing <: Any] >: Nothing <: Any
[info]       given def iseqc[T >: Nothing <: Any]:
[info]         Conversion[ADTs.this.ISeq[T], Seq[T]]
[info]       given def iseqcc[T >: Nothing <: Any]:
[info]         Conversion[Seq[T], ADTs.this.ISeq[T]]
[info]       type IFunction1[T1 >: Nothing <: Any, R >: Nothing <: Any]
[info]          >: Nothing <: Any
[info]       given def f1c[T1 >: Nothing <: Any, R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction1[T1, R], T1 => R]
[info]       type IFunction2[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any] >: Nothing <: Any
[info]       given def f2c[T1 >: Nothing <: Any, T2 >: Nothing <: Any,
[info]         R >: Nothing <: Any]:
[info]         Conversion[ADTs.this.IFunction2[T1, T2, R], (T1, T2) => R]
[info]       @JSExport type Neighbor = ADTs.this.IString
[info]       @JSExport case class Neighborhood(
[info]         neighbors: Seq[ADTs.this.Neighbor] @Repeated) extends Object(),
[info]         _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Neighborhood @unchecked =>
[info]                   this.neighbors.==(x$0.neighbors).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Neighborhood @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "Neighborhood"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "neighbors"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         val neighbors: Seq[ADTs.this.Neighbor] @Repeated
[info]         def _1: Seq[ADTs.this.Neighbor] @Repeated = this.neighbors
[info]       }
[info]       final lazy module val Neighborhood: ADTs.this.Neighborhood =
[info]         new ADTs.this.Neighborhood()
[info]       final module class Neighborhood() extends AnyRef(), 
[info]         scala.deriving.Mirror.Product {
[info]         this: Api.this.ADTs.this.Neighborhood.type =>
[info]         def apply(neighbors: Seq[ADTs.this.Neighbor] @Repeated):
[info]           ADTs.this.Neighborhood = new ADTs.this.Neighborhood(neighbors*)
[info]         def unapplySeq(x$1: ADTs.this.Neighborhood): ADTs.this.Neighborhood =
[info]           x$1
[info]         override def toString: String = "Neighborhood"
[info]         type MirroredMonoType = ADTs.this.Neighborhood
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Neighborhood.MirroredMonoType =
[info]           new ADTs.this.Neighborhood(
[info]             x$0.productElement(0).$asInstanceOf[Seq[ADTs.this.Neighbor]]*)
[info]       }
[info]       @JSExportAll @JSExport case class MSet[T >: Nothing <: Any](
[info]         elems: ADTs.this.ISeq[T]) extends Object(), _root_.scala.Product, _root_
[info]         .scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.MSet[T] @unchecked =>
[info]                   this.elems.==(x$0.elems).&&(x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.MSet[T] @unchecked]
[info]         override def productArity: Int = 1
[info]         override def productPrefix: String = "MSet"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "elems"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         T
[info]         val elems: ADTs.this.ISeq[T]
[info]         def copy[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def copy$default$1[T]: ADTs.this.ISeq[T] = MSet.this.elems
[info]         def _1: ADTs.this.ISeq[T] = this.elems
[info]       }
[info]       final lazy module val MSet: ADTs.this.MSet = new ADTs.this.MSet()
[info]       final module class MSet() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.MSet.type =>
[info]         def apply[T](elems: ADTs.this.ISeq[T]): ADTs.this.MSet[T] =
[info]           new ADTs.this.MSet[T](elems)
[info]         def unapply[T](x$1: ADTs.this.MSet[T]): ADTs.this.MSet[T] = x$1
[info]         override def toString: String = "MSet"
[info]         type MirroredMonoType = ADTs.this.MSet[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.MSet.MirroredMonoType =
[info]           new ADTs.this.MSet[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.ISeq[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class Rule[Token >: Nothing <: Any](
[info]         pre: ADTs.this.MSet[Token], rate: Double, eff: ADTs.this.MSet[Token],
[info]         msg: ADTs.this.IOption[Token]) extends Object(), _root_.scala.Product,
[info]         _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           {
[info]             var acc: Int = -889275714
[info]             acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.pre))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.doubleHash(Rule.this.rate))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.eff))
[info]             acc =
[info]               scala.runtime.Statics.mix(acc,
[info]                 scala.runtime.Statics.anyHash(Rule.this.msg))
[info]             scala.runtime.Statics.finalizeHash(acc, 4)
[info]           }
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.Rule[Token] @unchecked =>
[info]                   this.rate.==(x$0.rate).&&(this.pre.==(x$0.pre)).&&(
[info]                     this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.Rule[Token] @unchecked]
[info]         override def productArity: Int = 4
[info]         override def productPrefix: String = "Rule"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case 2 => this._3
[info]               case 3 => this._4
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "pre"
[info]               case 1 => "rate"
[info]               case 2 => "eff"
[info]               case 3 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val pre: ADTs.this.MSet[Token]
[info]         val rate: Double
[info]         val eff: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = Rule.this.pre
[info]         def copy$default$2[Token]: Double @uncheckedVariance = Rule.this.rate
[info]         def copy$default$3[Token]: ADTs.this.MSet[Token] = Rule.this.eff
[info]         def copy$default$4[Token]: ADTs.this.IOption[Token] = Rule.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.pre
[info]         def _2: Double = this.rate
[info]         def _3: ADTs.this.MSet[Token] = this.eff
[info]         def _4: ADTs.this.IOption[Token] = this.msg
[info]       }
[info]       final lazy module val Rule: ADTs.this.Rule = new ADTs.this.Rule()
[info]       final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.Rule.type =>
[info]         def apply[Token](pre: ADTs.this.MSet[Token], rate: Double,
[info]           eff: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]):
[info]           ADTs.this.Rule[Token] = new ADTs.this.Rule[Token](pre, rate, eff, msg)
[info]         def unapply[Token](x$1: ADTs.this.Rule[Token]): ADTs.this.Rule[Token] =
[info]           x$1
[info]         override def toString: String = "Rule"
[info]         type MirroredMonoType = ADTs.this.Rule[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.Rule.MirroredMonoType =
[info]           new ADTs.this.Rule[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[Double],
[info]             x$0.productElement(2).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(3).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]       @JSExportAll @JSExport case class State[Token >: Nothing <: Any](
[info]         tokens: ADTs.this.MSet[Token], msg: ADTs.this.IOption[Token]) extends
[info]         Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]         override def hashCode(): Int =
[info]           scala.runtime.ScalaRunTime._hashCode(this)
[info]         override def equals(x$0: Any): Boolean =
[info]           this.eq(x$0.$asInstanceOf[Object]).||(
[info]             x$0 match 
[info]               {
[info]                 case x$0 @ _:ADTs.this.State[Token] @unchecked =>
[info]                   this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                     x$0.canEqual(this))
[info]                 case _ => false
[info]               }
[info]           )
[info]         override def toString(): String =
[info]           scala.runtime.ScalaRunTime._toString(this)
[info]         override def canEqual(that: Any): Boolean =
[info]           that.isInstanceOf[ADTs.this.State[Token] @unchecked]
[info]         override def productArity: Int = 2
[info]         override def productPrefix: String = "State"
[info]         override def productElement(n: Int): Any =
[info]           n match 
[info]             {
[info]               case 0 => this._1
[info]               case 1 => this._2
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         override def productElementName(n: Int): String =
[info]           n match 
[info]             {
[info]               case 0 => "tokens"
[info]               case 1 => "msg"
[info]               case _ => throw new IndexOutOfBoundsException(n.toString())
[info]             }
[info]         Token
[info]         val tokens: ADTs.this.MSet[Token]
[info]         val msg: ADTs.this.IOption[Token]
[info]         def copy[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def copy$default$1[Token]: ADTs.this.MSet[Token] = State.this.tokens
[info]         def copy$default$2[Token]: ADTs.this.IOption[Token] = State.this.msg
[info]         def _1: ADTs.this.MSet[Token] = this.tokens
[info]         def _2: ADTs.this.IOption[Token] = this.msg
[info]       }
[info]       final lazy module val State: ADTs.this.State = new ADTs.this.State()
[info]       final module class State() extends AnyRef(), scala.deriving.Mirror.Product
[info]          { this: Api.this.ADTs.this.State.type =>
[info]         def apply[Token](tokens: ADTs.this.MSet[Token],
[info]           msg: ADTs.this.IOption[Token]): ADTs.this.State[Token] =
[info]           new ADTs.this.State[Token](tokens, msg)
[info]         def unapply[Token](x$1: ADTs.this.State[Token]): ADTs.this.State[Token]
[info]            = x$1
[info]         override def toString: String = "State"
[info]         type MirroredMonoType = ADTs.this.State[? <: AnyKind]
[info]         def fromProduct(x$0: Product):
[info]           it.unibo.dap.api.Api.ADTs.State.MirroredMonoType =
[info]           new ADTs.this.State[Any](
[info]             x$0.productElement(0).$asInstanceOf[ADTs.this.MSet[Any]],
[info]             x$0.productElement(1).$asInstanceOf[ADTs.this.IOption[Any]])
[info]       }
[info]     }
[info]     trait Interface() extends Object { ctx: Api.this.ADTs =>
[info]       export it.unibo.dap.controller.Serializable
[info]       final def Serializable: it.unibo.dap.controller.Serializable.type =
[info]         it.unibo.dap.controller.Serializable
[info]       final type Serializable[T] = it.unibo.dap.controller.Serializable[T]
[info]       export it.unibo.dap.model.Equatable
[info]       final def Equatable: it.unibo.dap.model.Equatable.type =
[info]         it.unibo.dap.model.Equatable
[info]       final type Equatable[T] = it.unibo.dap.model.Equatable[T]
[info]       @JSExport def simulation[Token >: Nothing <: Any](
[info]         rules: Interface.this.ISeq[Interface.this.Rule[Token]],
[info]         initialState: Interface.this.State[Token],
[info]         neighborhood: Interface.this.ISeq[Interface.this.Neighbor],
[info]         serializer: Interface.this.IFunction1[Token, Interface.this.IString],
[info]         deserializer: Interface.this.IFunction1[Interface.this.IString, Token],
[info]         equalizer: Interface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token]
[info]       @JSExport def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn: Interface.this.IFunction1[Interface.this.State[Token], Unit])
[info]         : Unit
[info]       @JSExport def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala
[info] package it.unibo.dap.api {
[info]   import scala.concurrent.ExecutionContext
[info]   import it.unibo.dap.boundary.sockets.{InetNeighborhoodResolver,
[info]     SocketExchangeComponent, SocketNetworking}
[info]   import it.unibo.dap.model.DAP.*
[info]   import it.unibo.dap.model.{CTMC, DAP, Equatable}
[info]   import it.unibo.dap.controller.DistributableInstances.given
[info]   import it.unibo.dap.controller.{DAPSimulation, Serializable}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DASPSimulation[Token >: Nothing <: Any](
[info]     initialState: it.unibo.dap.model.DAP.State[Token],
[info]     rules: Set[it.unibo.dap.model.DAP.Rule[Token]])(using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.DAPSimulation[DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketExchangeComponent[
[info]       DASPSimulation.this.Token],
[info]     it.unibo.dap.boundary.sockets.SocketNetworking[DASPSimulation.this.Token], 
[info]     it.unibo.dap.boundary.sockets.InetNeighborhoodResolver {
[info]     Token
[info]     private[this] val initialState: it.unibo.dap.model.DAP.State[Token]
[info]     private[this] val rules: Set[it.unibo.dap.model.DAP.Rule[Token]]
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]     override def initial:
[info]       it.unibo.dap.model.DAP.State[DASPSimulation.this.Token] =
[info]       this.initialState
[info]     override def behavior:
[info]       it.unibo.dap.model.CTMC[
[info]         it.unibo.dap.model.DAP.State[DASPSimulation.this.Token]]
[info]      =
[info]       it.unibo.dap.model.DAP.given_Conversion_DAP_CTMC[Token](this.evidence$1).
[info]         apply(it.unibo.dap.model.DAP.apply[Token](this.rules)(this.evidence$1))
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DASPSimulation: it.unibo.dap.api.DASPSimulation =
[info]     new it.unibo.dap.api.DASPSimulation()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DASPSimulation() extends Object() {
[info]     this: it.unibo.dap.api.DASPSimulation.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.api.DASPSimulation.type])
[info]     def withStaticNeighbors[Token >: Nothing <: Any](
[info]       s0: it.unibo.dap.model.DAP.State[Token],
[info]       rules: Set[it.unibo.dap.model.DAP.Rule[Token]], neighbors: Set[String])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[Token],
[info]       evidence$2: it.unibo.dap.controller.Serializable[Token],
[info]       x$4: scala.concurrent.ExecutionContext):
[info]       it.unibo.dap.api.DASPSimulation[Token] =
[info]       {
[info]         final class $anon() extends Object(),
[info]           
[info]             it.unibo.dap.controller.Simulation[it.unibo.dap.model.CTMC, Token,
[info]               it.unibo.dap.model.DAP.State[Token]]
[info]           (it.unibo.dap.model.CTMC.given_Simulatable_CTMC,
[info]             it.unibo.dap.controller.DistributableInstances.
[info]               given_Distributable_State_T[Token](evidence$2)
[info]           )(),
[info]           it.unibo.dap.controller.DAPSimulation[Token](evidence$1, evidence$2)()
[info]             ,
[info]           it.unibo.dap.boundary.sockets.SocketExchangeComponent[Token](
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.Networking[Token, Token](evidence$2,
[info]             evidence$2)(),
[info]           it.unibo.dap.boundary.sockets.SocketNetworking[Token](evidence$2, x$4)
[info]             (),
[info]         it.unibo.dap.api.DASPSimulation[Token](s0, rules)(evidence$1, evidence$2
[info]           ) {
[info]           override val neighborhoodResolver: NeighborhoodResolver =
[info]             this.NeighborhoodResolver.static(
[info]               neighbors.map[(Address, Port)]((x$1: String) =>
[info]                 x$1 match 
[info]                   {
[info]                     case 
[info]                       _root_.scala.StringContext.apply(["",":","" : String]*).s(
[info]                         address @ _, port @ _)
[info]                      =>
[info]                       Tuple2.apply[String, Int](address,
[info]                         augmentString(port).toInt)
[info]                     case _ =>
[info]                       throw 
[info]                         new IllegalArgumentException(
[info]                           "Invalid address:port format")
[info]                   }
[info]               )
[info]             )
[info]         }
[info]         new $anon():it.unibo.dap.api.DASPSimulation[Token]
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala
[info] package it.unibo.dap.api {
[info]   import it.unibo.dap.model.DAP
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ProductApi() extends Object, it.unibo.dap.api.Api {
[info]     trait ProductInterface() extends Object, ProductApi.this.Interface {
[info]       ctx: ProductApi.this.ADTs =>
[info]       import scala.concurrent.ExecutionContext
[info]       export this.ProductADTsConversions.{*, given}
[info]       final def Iso:
[info]         
[info]           (ProductInterface.this.ProductADTsConversions.Iso :
[info]             => it.unibo.dap.utils.Iso.type)
[info]         
[info]        = this.ProductADTsConversions.Iso
[info]       final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]       final given def given_Conversion_Function_Function[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Function_Function[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Function_Function[Token]
[info]       final given def given_Conversion_Rule_Rule[Token]:
[info]         
[info]           ProductInterface.this.ProductADTsConversions.
[info]             given_Conversion_Rule_Rule[Token]
[info]         
[info]        = this.ProductADTsConversions.given_Conversion_Rule_Rule[Token]
[info]       final given def fromT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]         this.ProductADTsConversions.fromT[Token]
[info]       final inline given def from[T]:
[info]         ProductInterface.this.ProductADTsConversions.from[T] =
[info]         this.ProductADTsConversions.from[T]
[info]       extension [B](b: B) final def back[A](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]         this.ProductADTsConversions.back[B](b)[A](iso)
[info]       final given def to[T]: ProductInterface.this.ProductADTsConversions.to[T]
[info]          = this.ProductADTsConversions.to[T]
[info]       final given def toT[Token]:
[info]         ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]         this.ProductADTsConversions.toT[Token]
[info]       extension [A](a: A) final def as[B](using 
[info]         iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]         this.ProductADTsConversions.as[A](a)[B](iso)
[info]       lazy given val given_ExecutionContext: scala.concurrent.ExecutionContext
[info]       override inline def simulation[Token >: Nothing <: Any](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]             sourcecode.Name.generate, sourcecode.Line.generate,
[info]             scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(this.given_Conversion_Rule_Rule[Token].apply(r)))
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]               sourcecode.Name.generate, sourcecode.Line.generate,
[info]               scribe.mdc.MDC.instance)
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             this.fromT[Token].apply(initialState),
[info]             realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       private def simulation$retainedBody[Token](
[info]         rules: ProductInterface.this.ISeq[ProductInterface.this.Rule[Token]],
[info]         initialState: ProductInterface.this.State[Token],
[info]         neighborhood: ProductInterface.this.ISeq[ProductInterface.this.Neighbor]
[info]           ,
[info]         serializer:
[info]           ProductInterface.this.IFunction1[Token, ProductInterface.this.IString]
[info]           ,
[info]         deserializer:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.IString, Token]
[info]           ,
[info]       equalizer: ProductInterface.this.IFunction2[Token, Token, Boolean]):
[info]         it.unibo.dap.api.DASPSimulation[Token] =
[info]         {
[info]           final lazy given val given_Equatable_Token:
[info]             ProductInterface.this.Equatable[Token] = (t1: Token, t2: Token) =>
[info]             this.f2c[Token, Token, Boolean].apply(equalizer).apply(t1, t2)
[info]           final lazy given val given_Serializable_Token:
[info]             ProductInterface.this.Serializable[Token] =
[info]             this.Serializable.from[Token](
[info]               (_$1: Token) =>
[info]                 this.as[ProductInterface.this.IString](
[info]                   this.f1c[Token, ProductInterface.this.IString].apply(
[info]                     serializer).apply(_$1)
[info]                 )[String](this.given_Iso_IString_String).getBytes()
[info]               ,
[info]             (b: Array[Byte]) =>
[info]               this.f1c[ProductInterface.this.IString, Token].apply(deserializer)
[info]                 .apply(
[info]                 this.back[String](new String(b))[ProductInterface.this.IString](
[info]                   this.given_Iso_IString_String)
[info]               )
[info]             )
[info]           scribe.package.info("[ProductApi] converting neighborhood")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allNeighbors: Set[String] =
[info]             this.iseqc[ProductInterface.this.IString].apply(neighborhood).toSet[
[info]               ProductInterface.this.IString].map[String]((
[info]               _$2: ProductInterface.this.IString) =>
[info]               this.as[ProductInterface.this.IString](_$2)[String](
[info]                 this.given_Iso_IString_String)
[info]             )
[info]           allNeighbors.foreach[Unit]((n: String) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Neighbors: ","" : String]*).s(
[info]                 [n : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           scribe.package.info("[=========SIM=========]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val allRulesAsSeq: Seq[ProductInterface.this.Rule[Token]] =
[info]             this.iseqc[ProductInterface.this.Rule[Token]].apply(rules)
[info]           scribe.package.info(
[info]             _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]               [allRulesAsSeq.mkString(",") : Any]*)
[info]           )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           scribe.package.info("[=====================]")(
[info]             sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]             sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance)
[info]           val realRules:
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]] =
[info]             scala.collection.mutable.Set.apply[
[info]               it.unibo.dap.model.DAP.Rule[Token]](
[info]               [ : it.unibo.dap.model.DAP.Rule[Token]]*)
[info]           this.iseqc[ProductInterface.this.Rule[Token]].apply(rules).foreach[
[info]             scala.collection.mutable.Set[it.unibo.dap.model.DAP.Rule[Token]]]((
[info]             r: ProductInterface.this.Rule[Token]) =>
[info]             realRules.+=(
[info]               {
[info]                 val given_Conversion_Rule_Rule_this:
[info]                   
[info]                     ProductInterface.this.ProductADTsConversions.
[info]                       given_Conversion_Rule_Rule[Token]
[info]                   
[info]                  = this.given_Conversion_Rule_Rule[Token]
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 {
[info]                   scribe.package.info("Inside conversion")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val rules: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rules: ","" : String]*).s
[info]                       ([rules : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                       [r.rate : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val eff: it.unibo.dap.model.MSet[Token] =
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             ProductInterface.this.ProductADTsConversions.type)
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                             sourcecode.Line.apply(23):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     }
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                       [eff : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val msg: Option[Token] =
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   scribe.package.info(
[info]                     _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                       [msg : Any]*)
[info]                   )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                     it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.pre.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]                       },
[info]                     (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                       {
[info]                         val ProductADTsConversions$_this:
[info]                           
[info]                             (ProductADTsConversions$_this :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                           
[info]                          = ProductADTsConversions$_this
[info]                         {
[info]                           val from_this:
[info]                             ProductADTsConversions$_this.from[Token] =
[info]                             new ProductADTsConversions$_this.from[Token]():
[info]                               ProductADTsConversions$_this.from[Token]
[info]                           val ProductInterface_this:
[info]                             
[info]                               (ProductInterface.this : ProductApi.this.ADTs &
[info]                                 ProductApi.this.ProductInterface)
[info]                             
[info]                            =
[info]                             (from_this:ProductADTsConversions$_this.from[Token])
[info]                               .2_<outer>
[info]                           {
[info]                             scribe.package.info("=======>")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             val res: it.unibo.dap.model.MSet[Token] =
[info]                               it.unibo.dap.model.MSet.ofList[Token](
[info]                                 ProductInterface_this.iseqc[Token].apply(
[info]                                   r.eff.elems).toList
[info]                               )
[info]                             scribe.package.info("<=======")(
[info]                               sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                                 sourcecode.Pkg,
[info]                               sourcecode.FileName.apply("ProductApi.scala"):
[info]                                 sourcecode.FileName,
[info]                               sourcecode.Name.apply("res"):sourcecode.Name,
[info]                               sourcecode.Line.apply(23):sourcecode.Line,
[info]                               scribe.mdc.MDC.instance)
[info]                             res:it.unibo.dap.model.MSet[Token]
[info]                           }:it.unibo.dap.model.MSet[Token]
[info]                         }
[info]                       },
[info]                       ProductADTsConversions$_this.as[
[info]                         ProductInterface_this.IOption[Token]](r.msg)[
[info]                         Option[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     )
[info]                   scribe.package.info("Conversion ok")(
[info]                     sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                     sourcecode.FileName.apply("ProductApi.scala"):
[info]                       sourcecode.FileName,
[info]                     sourcecode.Name.apply("simulation$retainedBody"):
[info]                       sourcecode.Name,
[info]                     sourcecode.Line.apply(23):sourcecode.Line,
[info]                     scribe.mdc.MDC.instance)
[info]                   res:it.unibo.dap.model.DAP.Rule[Token]
[info]                 }:it.unibo.dap.model.DAP.Rule[Token]
[info]               }
[info]             )
[info]           )
[info]           realRules.foreach[Unit]((r: it.unibo.dap.model.DAP.Rule[Token]) =>
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(["Rule: ","" : String]*).s(
[info]                 [r : Any]*)
[info]             )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]               sourcecode.FileName.apply("ProductApi.scala"):sourcecode.FileName
[info]                 ,
[info]               sourcecode.Name.apply("simulation$retainedBody"):sourcecode.Name,
[info]               sourcecode.Line.apply(23):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]           )
[info]           it.unibo.dap.api.DASPSimulation.withStaticNeighbors[Token](
[info]             {
[info]               val fromT_this:
[info]                 ProductInterface.this.ProductADTsConversions.fromT[Token] =
[info]                 this.fromT[Token]
[info]               val ProductADTsConversions$_this:
[info]                 ProductInterface.this.ProductADTsConversions.type =
[info]                 this.ProductADTsConversions
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         ProductInterface.this.ProductADTsConversions.type)
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             initialState.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("simulation$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(23):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](initialState.msg)[
[info]                   Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[Token]
[info]             },
[info]           realRules.toSet[it.unibo.dap.model.DAP.Rule[Token]], allNeighbors)(
[info]             given_Equatable_Token, given_Serializable_Token,
[info]             this.given_ExecutionContext)
[info]         }:it.unibo.dap.api.DASPSimulation[Token]
[info]       override inline def launch[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           ProductInterface.this.IFunction1[ProductInterface.this.State[Token],
[info]             Unit]
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(this.toT[Token].apply(s))
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       private def launch$retainedBody[Token](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token], port: Int,
[info]         updateFn:
[info]           
[info]             ProductInterface.this.IFunction1[
[info]               ProductInterface.this.State[Token], Unit]
[info]           
[info]       ): Unit =
[info]         {
[info]           simulation.launch(port)((s: it.unibo.dap.model.DAP.State[Token]) =>
[info]             this.f1c[ProductInterface.this.State[Token], Unit].apply(updateFn).
[info]               apply(
[info]               {
[info]                 val toT_this:
[info]                   ProductInterface.this.ProductADTsConversions.toT[Token] =
[info]                   this.toT[Token]
[info]                 val ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions.type =
[info]                   this.ProductADTsConversions
[info]                 val ProductInterface_this:
[info]                   
[info]                     (ProductInterface.this : ProductApi.this.ADTs &
[info]                       ProductApi.this.ProductInterface)
[info]                   
[info]                  =
[info]                   (ProductADTsConversions$_this:
[info]                     ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                 ProductInterface_this.State.apply[Token](
[info]                   {
[info]                     val to_this: ProductADTsConversions$_this.to[Token] =
[info]                       ProductADTsConversions$_this.to[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                     ProductInterface_this.MSet.apply[Token](
[info]                       ProductInterface_this.iseqcc[Token].apply(
[info]                         s.tokens.asList.toSeq)
[info]                     ):ProductInterface_this.MSet[Token]
[info]                   },
[info]                   ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                     ProductInterface_this.IOption[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 ):ProductInterface_this.State[Token]
[info]               }
[info]             )
[info]           )(this.given_ExecutionContext)
[info]           ()
[info]         }:Unit
[info]       override def stop[Token >: Nothing <: Any](
[info]         simulation: it.unibo.dap.api.DASPSimulation[Token]): Unit =
[info]         {
[info]           simulation.stop()
[info]           ()
[info]         }
[info]       final lazy module val ProductADTsConversions:
[info]         ProductInterface.this.ProductADTsConversions =
[info]         new ProductInterface.this.ProductADTsConversions()
[info]       final module class ProductADTsConversions() extends Object() {
[info]         this: ProductApi.this.ProductInterface.this.ProductADTsConversions.type
[info]            =>
[info]         export it.unibo.dap.utils.{as, back, Iso}
[info]         extension [A](a: A) final def as[B](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]           it.unibo.dap.utils.Iso$package.as[A](a)[B](iso)
[info]         extension [B](b: B) final def back[A](using 
[info]           iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]           it.unibo.dap.utils.Iso$package.back[B](b)[A](iso)
[info]         final def Iso: it.unibo.dap.utils.Iso.type = it.unibo.dap.utils.Iso
[info]         final type Iso[A,B] = it.unibo.dap.utils.Iso[A, B]
[info]         import it.unibo.dap.model
[info]         given class from[T >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.MSet[from.this.T],
[info]             it.unibo.dap.model.MSet[from.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: ProductInterface.this.MSet[from.this.T]):
[info]             it.unibo.dap.model.MSet[from.this.T] =
[info]             {
[info]               scribe.package.info("=======>")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.MSet[T] =
[info]                 it.unibo.dap.model.MSet.ofList[T](
[info]                   ProductApi.this.ProductInterface.this.iseqc[T].apply(m.elems).
[info]                     toList
[info]                 )
[info]               scribe.package.info("<=======")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.MSet[T]
[info]             }:it.unibo.dap.model.MSet[from.this.T]
[info]           private def apply$retainedBody(m: ProductInterface.this.MSet[T]):
[info]             it.unibo.dap.model.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .from[T]
[info]                   
[info]                 ).2_<outer>
[info]               {
[info]                 scribe.package.info("=======>")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.MSet[T] =
[info]                   it.unibo.dap.model.MSet.ofList[T](
[info]                     ProductInterface_this.iseqc[T].apply(m.elems).toList)
[info]                 scribe.package.info("<=======")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(57):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.MSet[T]
[info]               }:it.unibo.dap.model.MSet[from.this.T]
[info]             }
[info]         }
[info]         final inline given def from[T >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               from
[info]           [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             
[info]           [T]():
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .from
[info]             [T]
[info]         given class to[T >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.MSet[to.this.T],
[info]             ProductInterface.this.MSet[to.this.T]]
[info]         () {
[info]           T
[info]           inline def apply(m: it.unibo.dap.model.MSet[to.this.T]):
[info]             ProductInterface.this.MSet[to.this.T] =
[info]             ProductApi.this.ProductInterface.this.MSet.apply[T](
[info]               ProductApi.this.ProductInterface.this.iseqcc[T].apply(
[info]                 m.asList.toSeq)
[info]             ):ProductInterface.this.MSet[to.this.T]
[info]           private def apply$retainedBody(m: it.unibo.dap.model.MSet[T]):
[info]             ProductInterface.this.MSet[T] =
[info]             {
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .to[T]
[info]                   
[info]                 ).2_<outer>
[info]               ProductInterface_this.MSet.apply[T](
[info]                 ProductInterface_this.iseqcc[T].apply(m.asList.toSeq)):
[info]                 ProductInterface_this.MSet[to.this.T]
[info]             }
[info]         }
[info]         final given def to[T >: Nothing <: Any]:
[info]           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.to
[info]             [T]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .to
[info]             
[info]           [T]()
[info]         given class fromT[Token >: Nothing <: Any]() extends
[info]           Conversion[ProductInterface.this.State[fromT.this.Token],
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: ProductInterface.this.State[fromT.this.Token]):
[info]             it.unibo.dap.model.DAP.State[fromT.this.Token] =
[info]             it.unibo.dap.model.DAP.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                 apply(s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.as[
[info]                 ProductInterface.this.IOption[Token]](s.msg)[Option[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]           private def apply$retainedBody(s: ProductInterface.this.State[Token])
[info]             : it.unibo.dap.model.DAP.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .fromT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               it.unibo.dap.model.DAP.State.apply[Token](
[info]                 {
[info]                   val ProductADTsConversions$_this:
[info]                     
[info]                       (ProductADTsConversions$_this :
[info]                         (
[info]                           it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                            : ProductInterface.this.ProductADTsConversions.type)
[info]                       )
[info]                     
[info]                    = ProductADTsConversions$_this
[info]                   {
[info]                     val from_this: ProductADTsConversions$_this.from[Token] =
[info]                       new ProductADTsConversions$_this.from[Token]():
[info]                         ProductADTsConversions$_this.from[Token]
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (from_this:ProductADTsConversions$_this.from[Token]).
[info]                         2_<outer>
[info]                     {
[info]                       scribe.package.info("=======>")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       val res: it.unibo.dap.model.MSet[Token] =
[info]                         it.unibo.dap.model.MSet.ofList[Token](
[info]                           ProductInterface_this.iseqc[Token].apply(
[info]                             s.tokens.elems).toList
[info]                         )
[info]                       scribe.package.info("<=======")(
[info]                         sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg
[info]                           ,
[info]                         sourcecode.FileName.apply("ProductApi.scala"):
[info]                           sourcecode.FileName,
[info]                         sourcecode.Name.apply("apply$retainedBody"):
[info]                           sourcecode.Name,
[info]                         sourcecode.Line.apply(66):sourcecode.Line,
[info]                         scribe.mdc.MDC.instance)
[info]                       res:it.unibo.dap.model.MSet[Token]
[info]                     }:it.unibo.dap.model.MSet[Token]
[info]                   }
[info]                 },
[info]                 ProductADTsConversions$_this.as[
[info]                   ProductInterface_this.IOption[Token]](s.msg)[Option[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):it.unibo.dap.model.DAP.State[fromT.this.Token]
[info]             }
[info]         }
[info]         final given def fromT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               fromT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .fromT
[info]             
[info]           [Token]()
[info]         given class toT[Token >: Nothing <: Any]() extends
[info]           Conversion[it.unibo.dap.model.DAP.State[toT.this.Token],
[info]             ProductInterface.this.State[toT.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(s: it.unibo.dap.model.DAP.State[toT.this.Token]):
[info]             ProductInterface.this.State[toT.this.Token] =
[info]             ProductApi.this.ProductInterface.this.State.apply[Token](
[info]               ProductInterface.this.ProductADTsConversions.this.to[Token].apply(
[info]                 s.tokens),
[info]               ProductInterface.this.ProductADTsConversions.this.back[
[info]                 Option[Token]](s.msg)[ProductInterface.this.IOption[Token]](
[info]                 ProductApi.this.ProductInterface.this.given_Iso_IOption_Option[
[info]                   Token]
[info]               )
[info]             ):ProductInterface.this.State[toT.this.Token]
[info]           private def apply$retainedBody(s: it.unibo.dap.model.DAP.State[Token])
[info]             : ProductInterface.this.State[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .toT[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               ProductInterface_this.State.apply[Token](
[info]                 {
[info]                   val to_this: ProductADTsConversions$_this.to[Token] =
[info]                     ProductADTsConversions$_this.to[Token]
[info]                   val ProductInterface_this:
[info]                     
[info]                       (ProductInterface.this : ProductApi.this.ADTs &
[info]                         ProductApi.this.ProductInterface)
[info]                     
[info]                    = (to_this:ProductADTsConversions$_this.to[Token]).2_<outer>
[info]                   ProductInterface_this.MSet.apply[Token](
[info]                     ProductInterface_this.iseqcc[Token].apply(
[info]                       s.tokens.asList.toSeq)
[info]                   ):ProductInterface_this.MSet[Token]
[info]                 },
[info]                 ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                   ProductInterface_this.IOption[Token]](
[info]                   ProductInterface_this.given_Iso_IOption_Option[Token])
[info]               ):ProductInterface_this.State[toT.this.Token]
[info]             }
[info]         }
[info]         final given def toT[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               toT
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .toT
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Function_Function[Token >: Nothing <: Any]
[info]           () extends
[info]           Conversion[ProductInterface.this.State[Token] => Unit,
[info]             it.unibo.dap.model.DAP.State[Token] => Unit]
[info]         () {
[info]           Token
[info]           inline def apply(f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]               f.apply(
[info]                 ProductInterface.this.ProductADTsConversions.this.toT[Token].
[info]                   apply(s)
[info]               )
[info]             :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]           private def apply$retainedBody(
[info]             f: ProductInterface.this.State[Token] => Unit):
[info]             it.unibo.dap.model.DAP.State[Token] => Unit =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Function_Function[Token]
[info]                   
[info]                 ).1_<outer>
[info]               (s: it.unibo.dap.model.DAP.State[Token]) =>
[info]                 f.apply(
[info]                   {
[info]                     val toT_this: ProductADTsConversions$_this.toT[Token] =
[info]                       ProductADTsConversions$_this.toT[Token]
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     val ProductInterface_this:
[info]                       
[info]                         (ProductInterface.this : ProductApi.this.ADTs &
[info]                           ProductApi.this.ProductInterface)
[info]                       
[info]                      =
[info]                       (ProductADTsConversions$_this:
[info]                         ProductInterface.this.ProductADTsConversions).1_<outer>
[info]                     ProductInterface_this.State.apply[Token](
[info]                       {
[info]                         val to_this: ProductADTsConversions$_this.to[Token] =
[info]                           ProductADTsConversions$_this.to[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (to_this:ProductADTsConversions$_this.to[Token]).
[info]                             2_<outer>
[info]                         ProductInterface_this.MSet.apply[Token](
[info]                           ProductInterface_this.iseqcc[Token].apply(
[info]                             s.tokens.asList.toSeq)
[info]                         ):ProductInterface_this.MSet[Token]
[info]                       },
[info]                       ProductADTsConversions$_this.back[Option[Token]](s.msg)[
[info]                         ProductInterface_this.IOption[Token]](
[info]                         ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                     ):ProductInterface_this.State[Token]
[info]                   }
[info]                 )
[info]               :(it.unibo.dap.model.DAP.State[Token] => Unit)
[info]             }
[info]         }
[info]         final given def given_Conversion_Function_Function[
[info]           Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Function_Function
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Function_Function
[info]             
[info]           [Token]()
[info]         given class given_Conversion_Rule_Rule[Token >: Nothing <: Any]()
[info]            extends
[info]           Conversion[
[info]             ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token],
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]]
[info]         () {
[info]           Token
[info]           inline def apply(
[info]             r: ProductInterface.this.Rule[given_Conversion_Rule_Rule.this.Token]
[info]             ):
[info]             it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]              =
[info]             {
[info]               scribe.package.info("Inside conversion")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               val rules:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.pre)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                   [rules : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                   [r.rate : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val eff:
[info]                 it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                  =
[info]                 ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                   apply(r.eff)
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                   [eff : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                 ProductInterface.this.ProductADTsConversions.this.as[
[info]                   ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                   ProductApi.this.ProductInterface.this.given_Iso_IOption_Option
[info]                     [Token]
[info]                 )
[info]               scribe.package.info(
[info]                 _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                   [msg : Any]*)
[info]               )(sourcecode.Pkg.generate, sourcecode.FileName.generate,
[info]                 sourcecode.Name.generate, sourcecode.Line.generate,
[info]                 scribe.mdc.MDC.instance)
[info]               val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                 it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.pre),
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                   ProductInterface.this.ProductADTsConversions.this.from[Token].
[info]                     apply(r.eff),
[info]                   ProductInterface.this.ProductADTsConversions.this.as[
[info]                     ProductInterface.this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductApi.this.ProductInterface.this.
[info]                       given_Iso_IOption_Option[Token]
[info]                   )
[info]                 )
[info]               scribe.package.info("Conversion ok")(sourcecode.Pkg.generate,
[info]                 sourcecode.FileName.generate, sourcecode.Name.generate,
[info]                 sourcecode.Line.generate, scribe.mdc.MDC.instance)
[info]               res:it.unibo.dap.model.DAP.Rule[Token]
[info]             }:it.unibo.dap.model.DAP.Rule[given_Conversion_Rule_Rule.this.Token]
[info]           private def apply$retainedBody(r: ProductInterface.this.Rule[Token]):
[info]             it.unibo.dap.model.DAP.Rule[Token] =
[info]             {
[info]               val ProductADTsConversions$_this:
[info]                 
[info]                   (
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                      : ProductInterface.this.ProductADTsConversions.type)
[info]                 
[info]                =
[info]                 (this:
[info]                   
[info]                     it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                       .given_Conversion_Rule_Rule[Token]
[info]                   
[info]                 ).1_<outer>
[info]               val ProductInterface_this:
[info]                 
[info]                   (ProductInterface.this : ProductApi.this.ADTs &
[info]                     ProductApi.this.ProductInterface)
[info]                 
[info]                =
[info]                 (ProductADTsConversions$_this:
[info]                   ProductInterface.this.ProductADTsConversions).1_<outer>
[info]               {
[info]                 scribe.package.info("Inside conversion")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val rules:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.pre.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("rules"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rules: ","" : String]*).s(
[info]                     [rules : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Rate: ","" : String]*).s(
[info]                     [r.rate : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val eff:
[info]                   it.unibo.dap.model.MSet[given_Conversion_Rule_Rule.this.Token]
[info]                    =
[info]                   {
[info]                     val ProductADTsConversions$_this:
[info]                       
[info]                         (ProductADTsConversions$_this :
[info]                           (
[info]                             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                              : ProductInterface.this.ProductADTsConversions.type
[info]                             )
[info]                         )
[info]                       
[info]                      = ProductADTsConversions$_this
[info]                     {
[info]                       val from_this: ProductADTsConversions$_this.from[Token] =
[info]                         new ProductADTsConversions$_this.from[Token]():
[info]                           ProductADTsConversions$_this.from[Token]
[info]                       val ProductInterface_this:
[info]                         
[info]                           (ProductInterface.this : ProductApi.this.ADTs &
[info]                             ProductApi.this.ProductInterface)
[info]                         
[info]                        =
[info]                         (from_this:ProductADTsConversions$_this.from[Token]).
[info]                           2_<outer>
[info]                       {
[info]                         scribe.package.info("=======>")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         val res: it.unibo.dap.model.MSet[Token] =
[info]                           it.unibo.dap.model.MSet.ofList[Token](
[info]                             ProductInterface_this.iseqc[Token].apply(r.eff.elems
[info]                               ).toList
[info]                           )
[info]                         scribe.package.info("<=======")(
[info]                           sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                             sourcecode.Pkg,
[info]                           sourcecode.FileName.apply("ProductApi.scala"):
[info]                             sourcecode.FileName,
[info]                           sourcecode.Name.apply("eff"):sourcecode.Name,
[info]                           sourcecode.Line.apply(80):sourcecode.Line,
[info]                           scribe.mdc.MDC.instance)
[info]                         res:it.unibo.dap.model.MSet[Token]
[info]                       }:it.unibo.dap.model.MSet[Token]
[info]                     }
[info]                   }
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Eff: ","" : String]*).s(
[info]                     [eff : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val msg: Option[given_Conversion_Rule_Rule.this.Token] =
[info]                   ProductADTsConversions$_this.as[
[info]                     ProductInterface_this.IOption[Token]](r.msg)[Option[Token]](
[info]                     ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                 scribe.package.info(
[info]                   _root_.scala.StringContext.apply(["Msg: ","" : String]*).s(
[info]                     [msg : Any]*)
[info]                 )(sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 val res: it.unibo.dap.model.DAP.Rule[Token] =
[info]                   it.unibo.dap.model.DAP.Rule.apply[Token](
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.pre.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                   (_$3: it.unibo.dap.model.MSet[Token]) => r.rate,
[info]                     {
[info]                       val ProductADTsConversions$_this:
[info]                         
[info]                           (ProductADTsConversions$_this :
[info]                             (
[info]                               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                                :
[info]                               ProductInterface.this.ProductADTsConversions.type)
[info]                             )
[info]                         
[info]                        = ProductADTsConversions$_this
[info]                       {
[info]                         val from_this: ProductADTsConversions$_this.from[Token]
[info]                            =
[info]                           new ProductADTsConversions$_this.from[Token]():
[info]                             ProductADTsConversions$_this.from[Token]
[info]                         val ProductInterface_this:
[info]                           
[info]                             (ProductInterface.this : ProductApi.this.ADTs &
[info]                               ProductApi.this.ProductInterface)
[info]                           
[info]                          =
[info]                           (from_this:ProductADTsConversions$_this.from[Token]).
[info]                             2_<outer>
[info]                         {
[info]                           scribe.package.info("=======>")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           val res: it.unibo.dap.model.MSet[Token] =
[info]                             it.unibo.dap.model.MSet.ofList[Token](
[info]                               ProductInterface_this.iseqc[Token].apply(
[info]                                 r.eff.elems).toList
[info]                             )
[info]                           scribe.package.info("<=======")(
[info]                             sourcecode.Pkg.apply("it.unibo.dap.api"):
[info]                               sourcecode.Pkg,
[info]                             sourcecode.FileName.apply("ProductApi.scala"):
[info]                               sourcecode.FileName,
[info]                             sourcecode.Name.apply("res"):sourcecode.Name,
[info]                             sourcecode.Line.apply(80):sourcecode.Line,
[info]                             scribe.mdc.MDC.instance)
[info]                           res:it.unibo.dap.model.MSet[Token]
[info]                         }:it.unibo.dap.model.MSet[Token]
[info]                       }
[info]                     },
[info]                     ProductADTsConversions$_this.as[
[info]                       ProductInterface_this.IOption[Token]](r.msg)[Option[Token]
[info]                       ](ProductInterface_this.given_Iso_IOption_Option[Token])
[info]                   )
[info]                 scribe.package.info("Conversion ok")(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.api"):sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("ProductApi.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("apply$retainedBody"):sourcecode.Name,
[info]                   sourcecode.Line.apply(80):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 res:it.unibo.dap.model.DAP.Rule[Token]
[info]               }:
[info]                 it.unibo.dap.model.DAP.Rule[
[info]                   given_Conversion_Rule_Rule.this.Token]
[info]             }
[info]         }
[info]         final given def given_Conversion_Rule_Rule[Token >: Nothing <: Any]:
[info]           
[info]             it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions.
[info]               given_Conversion_Rule_Rule
[info]           [Token]
[info]          =
[info]           new 
[info]             
[info]               it.unibo.dap.api.ProductApi.ProductInterface.ProductADTsConversions
[info]                 .given_Conversion_Rule_Rule
[info]             
[info]           [Token]()
[info]       }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import it.unibo.dap.controller.NeighborhoodResolverComponent
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetTypes() extends Object {
[info]     type Address = String
[info]     type Port = Int
[info]     type Endpoint = Tuple2[InetTypes.this.Address, InetTypes.this.Port]
[info]   }
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/InetNeighborhoodResolver.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait InetNeighborhoodResolver() extends Object,
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent, 
[info]     it.unibo.dap.boundary.sockets.InetTypes {
[info]     override type Neighbor = InetNeighborhoodResolver.this.Endpoint
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.Future
[info]   import it.unibo.dap.controller.Serializable
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/Networking.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Networking[MessageIn >: Nothing <: Any, MessageOut >: Nothing <: Any](
[info]     using evidence$1: it.unibo.dap.controller.Serializable[MessageIn],
[info]     evidence$2: it.unibo.dap.controller.Serializable[MessageOut]) extends Object
[info]      { self: it.unibo.dap.boundary.sockets.InetTypes =>
[info]     +MessageIn
[info]     -MessageOut
[info]     private[this] given val evidence$1:
[info]       it.unibo.dap.controller.Serializable[MessageIn]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[MessageOut]
[info]     def out(endpoint: Networking.this.Endpoint):
[info]       scala.concurrent.Future[Networking.this.Connection]
[info]     def in(port: Networking.this.Port)(onReceive: MessageIn => Unit):
[info]       scala.concurrent.Future[Networking.this.ConnectionListener]
[info]     trait Connection() extends Object, AutoCloseable {
[info]       def send(msg: Networking.this.MessageOut): scala.concurrent.Future[Unit]
[info]       def isOpen: Boolean
[info]     }
[info]     trait ConnectionListener() extends Object, AutoCloseable {
[info]       def isOpen: Boolean
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala
[info] package it.unibo.dap.boundary.sockets {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import it.unibo.dap.utils.*
[info]   import it.unibo.dap.controller.{ExchangeComponent, Serializable}
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/boundary/sockets/SocketExchangeComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SocketExchangeComponent[T >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.controller.Serializable[T]) extends Object, 
[info]     it.unibo.dap.controller.ExchangeComponent[SocketExchangeComponent.this.T] {
[info]     ctx:
[info]       it.unibo.dap.boundary.sockets.InetNeighborhoodResolver &
[info]         it.unibo.dap.boundary.sockets.Networking[
[info]           SocketExchangeComponent.this.T, SocketExchangeComponent.this.T]
[info]      =>
[info]     T
[info]     private[this] given val evidence$1: it.unibo.dap.controller.Serializable[T]
[info]     override type Configuration = SocketExchangeComponent.this.Port
[info]     override val exchange: SocketExchangeComponent.this.Exchange =
[info]       new this.SocketExchange()
[info]     private[this] class SocketExchange() extends Object(),
[info]       SocketExchangeComponent.this.Exchange, AutoCloseable {
[info]       private[this] var connectionListener:
[info]         Option[SocketExchangeComponent.this.ConnectionListener] =
[info]         Option.empty[SocketExchangeComponent.this.ConnectionListener]
[info]       private[this] val inChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       private[this] val outChannel: it.unibo.dap.utils.Channel[T] =
[info]         it.unibo.dap.utils.Channel.apply[SocketExchangeComponent.this.T]()
[info]       override def inputs:
[info]         it.unibo.dap.utils.ReadableChannel[SocketExchangeComponent.this.T] =
[info]         this.inChannel.asReadable
[info]       override def outputs:
[info]         it.unibo.dap.utils.SendableChannel[SocketExchangeComponent.this.T] =
[info]         this.outChannel.asSendable
[info]       override def spawn(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.utils.unit[List[Unit]](
[info]           scala.concurrent.Future.sequence[Unit, List, List[Unit]](
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.client(this.client$default$1)(x$2)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.serveClients(configuration)(x$2)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           )(
[info]             scala.collection.BuildFrom.buildFromIterableOps[List,
[info]               scala.concurrent.Future[Unit], Unit],
[info]           x$2)
[info]         )(x$2)
[info]       private[this] def client(
[info]         connections:
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection]
[info]       )(using x$2: scala.concurrent.ExecutionContext):
[info]         scala.concurrent.Future[Unit] =
[info]         this.outChannel.pop().flatMap[Unit]((msg: T) =>
[info]           scala.concurrent.Future.successful[
[info]             Set[SocketExchangeComponent.this.Neighbor]](
[info]             it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.
[info]               neighborhoodResolver.apply()
[info]           ).flatMap[Unit]((neighbors: Set[SocketExchangeComponent.this.Neighbor]
[info]             ) =>
[info]             scala.concurrent.Future.traverse[
[info]               (SocketExchangeComponent.this.Address,
[info]                 SocketExchangeComponent.this.Port),
[info]               
[info]                 Either[Throwable, (
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection)]
[info]               ,
[info]             Set](neighbors)((
[info]               n:
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port)
[info]             ) =>
[info]               connections.get(n).filter((
[info]                 _$1: SocketExchangeComponent.this.Connection) => _$1.isOpen).
[info]                 fold[
[info]                 scala.concurrent.Future[SocketExchangeComponent.this.Connection]
[info]                 ](this.establishConnection(n))((
[info]                 result: SocketExchangeComponent.this.Connection) =>
[info]                 scala.concurrent.Future.successful[
[info]                   SocketExchangeComponent.this.Connection](result)
[info]               ).flatMap[
[info]                 
[info]                   Right[Nothing, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((c: SocketExchangeComponent.this.Connection) =>
[info]                 c.send(msg).map[
[info]                   
[info]                     Right[Nothing, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   
[info]                 ]((_$2: Unit) =>
[info]                   Right.apply[Nothing,
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ](
[info]                     ArrowAssoc[
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port)
[info]                     ](n).->[SocketExchangeComponent.this.Connection](c)
[info]                   )
[info]                 )(x$2)
[info]               )(x$2).recover[
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ]((x$1: Throwable) =>
[info]                 x$1 match 
[info]                   {
[info]                     case e @ _ =>
[info]                       Left.apply[Throwable, Nothing](e)
[info]                   }
[info]               )(x$2)
[info]             )(
[info]               scala.collection.BuildFrom.buildFromIterableOps[Set,
[info]                 (SocketExchangeComponent.this.Address,
[info]                   SocketExchangeComponent.this.Port),
[info]                 
[info]                   Either[Throwable, (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)]
[info]                 
[info]               ],
[info]             x$2).flatMap[Unit]((
[info]               newConnections:
[info]                 
[info]                   Set[
[info]                     Either[Throwable, (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)]
[info]                   ]
[info]                 
[info]             ) =>
[info]               this.client(
[info]                 newConnections.collect[
[info]                   (
[info]                     (SocketExchangeComponent.this.Address,
[info]                       SocketExchangeComponent.this.Port),
[info]                     SocketExchangeComponent.this.Connection)
[info]                 ]((
[info]                   x$1:
[info]                     
[info]                       Either[Throwable, (
[info]                         (SocketExchangeComponent.this.Address,
[info]                           SocketExchangeComponent.this.Port),
[info]                         SocketExchangeComponent.this.Connection)]
[info]                     
[info]                 ) =>
[info]                   x$1 match 
[info]                     {
[info]                       case 
[info]                         Right.unapply[Throwable,
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                         ](nc @ _):
[info]                           
[info]                             Right[Throwable, (
[info]                               (SocketExchangeComponent.this.Address,
[info]                                 SocketExchangeComponent.this.Port),
[info]                               SocketExchangeComponent.this.Connection)]
[info]                           
[info]                        =>
[info]                         nc:
[info]                           (
[info]                             (SocketExchangeComponent.this.Address,
[info]                               SocketExchangeComponent.this.Port),
[info]                             SocketExchangeComponent.this.Connection)
[info]                     }
[info]                 ).toMap[
[info]                   (SocketExchangeComponent.this.Address,
[info]                     SocketExchangeComponent.this.Port),
[info]                   SocketExchangeComponent.this.Connection](
[info]                   <:<.refl[
[info]                     (
[info]                       (SocketExchangeComponent.this.Address,
[info]                         SocketExchangeComponent.this.Port),
[info]                       SocketExchangeComponent.this.Connection)
[info]                   ]
[info]                 )
[info]               )(x$2).map[Unit]((x$1: Unit) =>
[info]                 x$1:Unit @unchecked match 
[info]                   {
[info]                     case _ => ()
[info]                   }
[info]               )(x$2)
[info]             )(x$2)
[info]           )(x$2)
[info]         )(x$2)
[info]       private[this] def client$default$1:
[info]         
[info]           Map[SocketExchangeComponent.this.Endpoint,
[info]             SocketExchangeComponent.this.Connection] @uncheckedVariance
[info]         
[info]        =
[info]         Map.empty[
[info]           (SocketExchangeComponent.this.Address,
[info]             SocketExchangeComponent.this.Port),
[info]           SocketExchangeComponent.this.Connection]
[info]       private[this] def establishConnection(
[info]         endpoint: SocketExchangeComponent.this.Endpoint):
[info]         scala.concurrent.Future[SocketExchangeComponent.this.Connection] =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.out(endpoint)
[info]       private[this] def serveClients(
[info]         configuration: SocketExchangeComponent.this.Configuration)(using 
[info]         x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]          =
[info]         it.unibo.dap.boundary.sockets.SocketExchangeComponent.this.in(
[info]           configuration)((item: T) =>
[info]           {
[info]             this.inChannel.push(item)
[info]             ()
[info]           }
[info]         ).map[Unit]((c: SocketExchangeComponent.this.ConnectionListener) =>
[info]           {
[info]             scribe.package.info(
[info]               _root_.scala.StringContext.apply(
[info]                 ["Socket server listening on port ","" : String]*).f[Any](
[info]                 [configuration : Any]*)
[info]             )(
[info]               sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                 sourcecode.Pkg,
[info]               sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                 sourcecode.FileName,
[info]               sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]               sourcecode.Line.apply(48):sourcecode.Line, scribe.mdc.MDC.instance
[info]               )
[info]             this.connectionListener =
[info]               Some.apply[SocketExchangeComponent.this.ConnectionListener](c)
[info]           }
[info]         )(x$2).recoverWith[Unit]((x$1: Throwable) =>
[info]           x$1 match 
[info]             {
[info]               case e @ _ =>
[info]                 scribe.package.error(
[info]                   _root_.scala.StringContext.apply(
[info]                     ["Socket server error: ","" : String]*).s(
[info]                     [e.getMessage() : Any]*)
[info]                 )(
[info]                   sourcecode.Pkg.apply("it.unibo.dap.boundary.sockets"):
[info]                     sourcecode.Pkg,
[info]                   sourcecode.FileName.apply("SocketExchangeComponent.scala"):
[info]                     sourcecode.FileName,
[info]                   sourcecode.Name.apply("serveClients"):sourcecode.Name,
[info]                   sourcecode.Line.apply(50):sourcecode.Line,
[info]                   scribe.mdc.MDC.instance)
[info]                 this.serveClients(configuration)(x$2)
[info]             }
[info]         )(x$2)
[info]       override def close(): Unit =
[info]         {
[info]           this.inChannel.close()
[info]           this.outChannel.close()
[info]           this.connectionListener.foreach[Unit]((
[info]             _$3: SocketExchangeComponent.this.ConnectionListener) => _$3.close()
[info]             )
[info]         }
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.model.DAP.State
[info]   import it.unibo.dap.model.{CTMC, Equatable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/DAPSimulation.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait DAPSimulation[Token >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Equatable[Token],
[info]     evidence$2: it.unibo.dap.controller.Serializable[Token]) extends Object,
[info]     it.unibo.dap.controller.Simulation[CTMC, DAPSimulation.this.Token,
[info]       it.unibo.dap.model.DAP.State[DAPSimulation.this.Token]],
[info]     it.unibo.dap.controller.ExchangeComponent[DAPSimulation.this.Token], 
[info]     it.unibo.dap.controller.NeighborhoodResolverComponent {
[info]     Token
[info]     private[this] given val evidence$1: it.unibo.dap.model.Equatable[Token]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.Serializable[Token]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Distributable[State >: Nothing <: Any, Message >: Nothing <: Any]()
[info]      extends Object {
[info]     State
[info]     Message
[info]     extension (s: Distributable.this.State) def msg:
[info]       Option[Distributable.this.Message]
[info]     extension (s: Distributable.this.State) def updated(
[info]       msg: Distributable.this.Message): Distributable.this.State
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DistributableInstances:
[info]     it.unibo.dap.controller.DistributableInstances =
[info]     new it.unibo.dap.controller.DistributableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DistributableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.DistributableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.DistributableInstances.type])
[info]     import it.unibo.dap.model.{DAP, MSet}
[info]     final given def given_Distributable_State_T[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.controller.Serializable[T]):
[info]       it.unibo.dap.controller.Distributable[it.unibo.dap.model.DAP.State[T], T]
[info]        =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Distributable[it.unibo.dap.model.DAP.State[T], T] {
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def msg:
[info]             Option[T] = s.msg
[info]           extension (s: it.unibo.dap.model.DAP.State[T]) override def updated(
[info]             msg: T): it.unibo.dap.model.DAP.State[T] =
[info]             s.copy[T](
[info]               tokens =
[info]                 s.tokens.union(it.unibo.dap.model.MSet.apply[T]([msg : T]*)),
[info]               s.copy$default$2[T])
[info]         }
[info]         new $anon():
[info]           
[info]             it.unibo.dap.controller.Distributable[
[info]               it.unibo.dap.model.DAP.State[T], T]
[info]           
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Distributable$package:
[info]     it.unibo.dap.controller.Distributable$package =
[info]     new it.unibo.dap.controller.Distributable$package()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Distributable.scala")
[info]     final module class Distributable$package() extends Object() {
[info]     this: it.unibo.dap.controller.Distributable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Distributable$package.type])
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]       type DistributableState[Message >: Nothing <: Any] =
[info]       [State >: Nothing <: Any] =>>
[info]         it.unibo.dap.controller.Distributable[State, Message]
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala
[info] package it.unibo.dap.controller {
[info]   import it.unibo.dap.utils.{ReadableChannel, SendableChannel, Spawnable}
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/ExchangeComponent.scala")
[info]      @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ExchangeComponent[T >: Nothing <: Any]() extends Object {
[info]     ctx: it.unibo.dap.controller.NeighborhoodResolverComponent =>
[info]     T
[info]     type Configuration >: Nothing <: Any
[info]     val exchange: ExchangeComponent.this.Exchange
[info]     trait Exchange() extends Object,
[info]       it.unibo.dap.utils.Spawnable[ExchangeComponent.this.Configuration], 
[info]       AutoCloseable {
[info]       def inputs: it.unibo.dap.utils.ReadableChannel[ExchangeComponent.this.T]
[info]       def outputs: it.unibo.dap.utils.SendableChannel[ExchangeComponent.this.T]
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     
[info]       "dap/shared/src/main/scala/it/unibo/dap/controller/NeighborhoodResolverComponent.scala"
[info]       
[info]   ) @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait NeighborhoodResolverComponent() extends Object {
[info]     type Neighbor >: Nothing <: Any
[info]     type Neighborhood = Set[NeighborhoodResolverComponent.this.Neighbor]
[info]     val neighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver
[info]     trait NeighborhoodResolver() extends Object, (() =>
[info]       NeighborhoodResolverComponent.this.Neighborhood) {}
[info]     final lazy module val NeighborhoodResolver:
[info]       NeighborhoodResolverComponent.this.NeighborhoodResolver =
[info]       new NeighborhoodResolverComponent.this.NeighborhoodResolver()
[info]     final module class NeighborhoodResolver() extends Object() {
[info]       this:
[info]         it.unibo.dap.controller.NeighborhoodResolverComponent.this.
[info]           NeighborhoodResolver.type
[info]        =>
[info]       def static(neighborhood: NeighborhoodResolverComponent.this.Neighborhood)
[info]         : NeighborhoodResolverComponent.this.NeighborhoodResolver = () =>
[info]         neighborhood
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala
[info] package it.unibo.dap.controller {
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     case class SerDe[T >: Nothing <: Any](serialize: T => Array[Byte],
[info]     deserialize: Array[Byte] => T) extends Object(), _root_.scala.Product,
[info]     _root_.scala.Serializable {
[info]     override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]     override def equals(x$0: Any): Boolean =
[info]       this.eq(x$0.$asInstanceOf[Object]).||(
[info]         x$0 match 
[info]           {
[info]             case x$0 @ _:it.unibo.dap.controller.SerDe[T] @unchecked =>
[info]               this.serialize.==(x$0.serialize).&&(
[info]                 this.deserialize.==(x$0.deserialize)).&&(x$0.canEqual(this))
[info]             case _ => false
[info]           }
[info]       )
[info]     override def toString(): String = scala.runtime.ScalaRunTime._toString(this)
[info]     override def canEqual(that: Any): Boolean =
[info]       that.isInstanceOf[it.unibo.dap.controller.SerDe[T] @unchecked]
[info]     override def productArity: Int = 2
[info]     override def productPrefix: String = "SerDe"
[info]     override def productElement(n: Int): Any =
[info]       n match 
[info]         {
[info]           case 0 => this._1
[info]           case 1 => this._2
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     override def productElementName(n: Int): String =
[info]       n match 
[info]         {
[info]           case 0 => "serialize"
[info]           case 1 => "deserialize"
[info]           case _ => throw new IndexOutOfBoundsException(n.toString())
[info]         }
[info]     T
[info]     val serialize: T => Array[Byte]
[info]     val deserialize: Array[Byte] => T
[info]     def copy[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def copy$default$1[T]: T => Array[Byte] = SerDe.this.serialize
[info]     def copy$default$2[T]: Array[Byte] => T = SerDe.this.deserialize
[info]     def _1: T => Array[Byte] = this.serialize
[info]     def _2: Array[Byte] => T = this.deserialize
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerDe: it.unibo.dap.controller.SerDe =
[info]     new it.unibo.dap.controller.SerDe()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerDe() extends AnyRef(), scala.deriving.Mirror.Product {
[info]      this: it.unibo.dap.controller.SerDe.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerDe.type])
[info]     def apply[T](serialize: T => Array[Byte], deserialize: Array[Byte] => T):
[info]       it.unibo.dap.controller.SerDe[T] =
[info]       new it.unibo.dap.controller.SerDe[T](serialize, deserialize)
[info]     def unapply[T](x$1: it.unibo.dap.controller.SerDe[T]):
[info]       it.unibo.dap.controller.SerDe[T] = x$1
[info]     override def toString: String = "SerDe"
[info]     type MirroredMonoType = it.unibo.dap.controller.SerDe[? <: AnyKind]
[info]     def fromProduct(x$0: Product):
[info]       it.unibo.dap.controller.SerDe.MirroredMonoType =
[info]       new it.unibo.dap.controller.SerDe[Any](
[info]         x$0.productElement(0).$asInstanceOf[Any => Array[Byte]],
[info]         x$0.productElement(1).$asInstanceOf[Array[Byte] => Any])
[info]   }
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Serializable[T >: Nothing <: Any]() extends Object {
[info]     T
[info]     def serialize(t: Serializable.this.T): Array[Byte]
[info]     def deserialize(bytes: Array[Byte]): Serializable.this.T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Serializable: it.unibo.dap.controller.Serializable =
[info]     new it.unibo.dap.controller.Serializable()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Serializable() extends Object() {
[info]     this: it.unibo.dap.controller.Serializable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.Serializable.type])
[info]     def serialize[T >: Nothing <: Any](t: T)(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): Array[Byte] = s.serialize(t)
[info]     def deserialize[T >: Nothing <: Any](t: Array[Byte])(using 
[info]       s: it.unibo.dap.controller.Serializable[T]): T = s.deserialize(t)
[info]     def from[T >: Nothing <: Any](serializer: T => Array[Byte],
[info]       deserializer: Array[Byte] => T): it.unibo.dap.controller.Serializable[T]
[info]        =
[info]       it.unibo.dap.controller.Serializable.asSerializable[T](
[info]         it.unibo.dap.controller.SerDe.apply[T](serializer, deserializer))
[info]     extension [T >: Nothing <: Any](serde: it.unibo.dap.controller.SerDe[T])
[info]       def asSerializable: it.unibo.dap.controller.Serializable[T] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.controller.
[info]           Serializable[T] {
[info]           override def serialize(t: T): Array[Byte] = serde.serialize.apply(t)
[info]           override def deserialize(bytes: Array[Byte]): T =
[info]             serde.deserialize.apply(bytes)
[info]         }
[info]         new $anon():it.unibo.dap.controller.Serializable[T]
[info]       }
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val SerializableInstances:
[info]     it.unibo.dap.controller.SerializableInstances =
[info]     new it.unibo.dap.controller.SerializableInstances()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Serializable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class SerializableInstances() extends Object() {
[info]     this: it.unibo.dap.controller.SerializableInstances.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.controller.SerializableInstances.type])
[info]     final lazy module given val given_Serializable_String:
[info]       it.unibo.dap.controller.SerializableInstances.given_Serializable_String =
[info]       new 
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String(
[info]         )
[info]     final module class given_Serializable_String() extends Object(), 
[info]       it.unibo.dap.controller.Serializable[String] {
[info]       this:
[info]         it.unibo.dap.controller.SerializableInstances.given_Serializable_String.
[info]           type
[info]        =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[
[info]             it.unibo.dap.controller.SerializableInstances.
[info]               given_Serializable_String.type
[info]           ]
[info]         )
[info]       override def serialize(t: String): Array[Byte] = t.getBytes()
[info]       override def deserialize(bytes: Array[Byte]): String = new String(bytes)
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala
[info] package it.unibo.dap.controller {
[info]   import java.util.Random
[info]   import java.util.concurrent.atomic.AtomicBoolean
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   import scala.language.experimental.betterFors
[info]   import scala.concurrent.duration.DurationDouble
[info]   import it.unibo.dap.utils.{unit, Async}
[info]   import it.unibo.dap.model.Simulatable.Event
[info]   import it.unibo.dap.model.Simulatable
[info]   import scala.util.Failure
[info]   import scala.util.Success
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/controller/Simulation.scala")
[info]     @experimental(
[info]     
[info]       "Added by top level \u001b[33mimport \u001b[0mscala.language.experimental.betterFors"
[info]       
[info]   ) trait Simulation[B[_ >: Nothing <: Any] >: Nothing <: Any,
[info]     T >: Nothing <: Any, S >: Nothing <: Any](using 
[info]     evidence$1: it.unibo.dap.model.Simulatable[B],
[info]     evidence$2: it.unibo.dap.controller.DistributableState[T][S]) extends Object
[info]      { ctx: it.unibo.dap.controller.ExchangeComponent[Simulation.this.T] =>
[info]     B[_$1]
[info]     T
[info]     S
[info]     private[this] given val evidence$1: it.unibo.dap.model.Simulatable[B]
[info]     private[this] given val evidence$2:
[info]       it.unibo.dap.controller.DistributableState[T][S]
[info]     type SimulationError = String
[info]     def initial: Simulation.this.S
[info]     def behavior: Simulation.this.B[Simulation.this.S]
[info]     private[this] val isRunning: java.util.concurrent.atomic.AtomicBoolean =
[info]       new java.util.concurrent.atomic.AtomicBoolean(false)
[info]     def stop(): Either[Simulation.this.SimulationError, Unit] =
[info]       Either.cond[String, Unit](this.isRunning.compareAndSet(true, false), (),
[info]         "Simulation is not running.").map[Unit]((_$2: Unit) =>
[info]         this.exchange.close())
[info]     def launch(conf: this.Configuration)(updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       if this.isRunning.compareAndSet(false, true) then
[info]         {
[info]           val tasks: List[scala.concurrent.Future[Unit]] =
[info]             {
[info]               val elem$2: scala.concurrent.Future[Unit] =
[info]                 this.loop(this.initial, updateFn)(x$3)
[info]               {
[info]                 val elem$1: scala.concurrent.Future[Unit] =
[info]                   this.exchange.spawn(conf)(x$3)
[info]                 Nil.::[scala.concurrent.Future[Unit]](elem$1)
[info]               }.::[scala.concurrent.Future[Unit]](elem$2)
[info]             }
[info]           it.unibo.dap.utils.unit[List[Unit]](
[info]             scala.concurrent.Future.sequence[Unit, List, List[Unit]](tasks)(
[info]               scala.collection.BuildFrom.buildFromIterableOps[List,
[info]                 scala.concurrent.Future[Unit], Unit],
[info]             x$3).andThen[Unit]((x$1: scala.util.Try[List[Unit]]) =>
[info]               x$1 match 
[info]                 {
[info]                   case 
[info]                     scala.util.Failure.unapply[List[Unit]](e @ _):
[info]                       scala.util.Failure[List[Unit]]
[info]                    =>
[info]                     scribe.package.error(
[info]                       [scribe.LogFeature.throwable2LoggableMessage(e) :
[info]                         scribe.LogFeature]*
[info]                     )(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                   case 
[info]                     scala.util.Success.unapply[List[Unit]](_):
[info]                       scala.util.Success[List[Unit]]
[info]                    =>
[info]                     scribe.package.info("sim ended")(
[info]                       sourcecode.Pkg.apply("it.unibo.dap.controller"):
[info]                         sourcecode.Pkg,
[info]                       sourcecode.FileName.apply("Simulation.scala"):
[info]                         sourcecode.FileName,
[info]                       sourcecode.Name.apply("launch"):sourcecode.Name,
[info]                       sourcecode.Line.apply(46):sourcecode.Line,
[info]                       scribe.mdc.MDC.instance)
[info]                 }
[info]             )(x$3)
[info]           )(x$3)
[info]         }
[info]        else 
[info]         scala.concurrent.Future.failed[Nothing](
[info]           new IllegalStateException("Simulation is already running."))
[info]     private[this] def loop(state: Simulation.this.S, updateFn: S => Unit)(using 
[info]       x$3: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] =
[info]       {
[info]         val event: it.unibo.dap.model.Simulatable.Event[S] =
[info]           this.evidence$1.simulateStep[S](this.behavior)(state)(using
[info]             new java.util.Random())
[info]         it.unibo.dap.utils.Async.operations.sleep(
[info]           scala.concurrent.duration.DurationDouble(event.time).seconds).
[info]           withFilter((x$1: Unit) =>
[info]           x$1:Unit @unchecked match 
[info]             {
[info]               case _ => this.isRunning.get()
[info]             }
[info]         )(x$3).flatMap[Unit]((x$1: Unit) =>
[info]           x$1:(x$1 : Unit) @unchecked match 
[info]             {
[info]               case _ =>
[info]                 this.updateLogic(event, updateFn)(x$3).map[Unit]((x$1: Unit) =>
[info]                   x$1:Unit @unchecked match 
[info]                     {
[info]                       case _ => ()
[info]                     }
[info]                 )(x$3)
[info]             }
[info]         )(x$3)
[info]       }
[info]     private[this] def updateLogic(
[info]       event: it.unibo.dap.model.Simulatable.Event[Simulation.this.S],
[info]       updateFn: S => Unit)(using x$3: scala.concurrent.ExecutionContext):
[info]       scala.concurrent.Future[Unit] =
[info]       {
[info]         updateFn.apply(event.state)
[info]         this.evidence$2.msg(event.state).foreach[
[info]           Either[it.unibo.dap.utils.Channel.Error, Unit]](
[info]           {
[info]             val $1$: it.unibo.dap.utils.SendableChannel[T] =
[info]               this.exchange.outputs
[info]             (item: T) => $1$.push(item)
[info]           }
[info]         )
[info]         val in: Option[T] = this.exchange.inputs.poll()
[info]         val newState: S =
[info]           in.fold[S](event.state)((msg: T) =>
[info]             this.evidence$2.updated(event.state)(msg))
[info]         this.loop(newState, updateFn)(x$3)
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait CTMC[S >: Nothing <: Any]() extends Object {
[info]     S
[info]     import it.unibo.dap.model.CTMC.Action
[info]     def transitions(a: CTMC.this.S):
[info]       Set[it.unibo.dap.model.CTMC.Action[CTMC.this.S]]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMC: it.unibo.dap.model.CTMC =
[info]     new it.unibo.dap.model.CTMC()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/CTMC.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMC() extends Object() {
[info]     this: it.unibo.dap.model.CTMC.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.CTMC.type])
[info]     case class Transition[S >: Nothing <: Any](state: S,
[info]       action: it.unibo.dap.model.CTMC.Action[S]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Transition[S] @unchecked =>
[info]                 this.state.==(x$0.state).&&(this.action.==(x$0.action)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Transition[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Transition"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "state"
[info]             case 1 => "action"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val state: S
[info]       val action: it.unibo.dap.model.CTMC.Action[S]
[info]       def copy[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def copy$default$1[S]: S = Transition.this.state
[info]       def copy$default$2[S]: it.unibo.dap.model.CTMC.Action[S] =
[info]         Transition.this.action
[info]       def _1: S = this.state
[info]       def _2: it.unibo.dap.model.CTMC.Action[S] = this.action
[info]     }
[info]     final lazy module val Transition: it.unibo.dap.model.CTMC.Transition =
[info]       new it.unibo.dap.model.CTMC.Transition()
[info]     final module class Transition() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.CTMC.Transition.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Transition.type])
[info]       def apply[S](state: S, action: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] =
[info]         new it.unibo.dap.model.CTMC.Transition[S](state, action)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Transition[S]):
[info]         it.unibo.dap.model.CTMC.Transition[S] = x$1
[info]       override def toString: String = "Transition"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Transition[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Transition.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Transition[Any](x$0.productElement(0),
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.CTMC.Action[Any]]
[info]         )
[info]     }
[info]     case class Action[S >: Nothing <: Any](rate: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Action.this.rate))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Action.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.CTMC.Action[S] @unchecked =>
[info]                 this.rate.==(x$0.rate).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.CTMC.Action[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Action"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "rate"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val rate: Double
[info]       val state: S
[info]       def copy[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Action.this.rate
[info]       def copy$default$2[S]: S = Action.this.state
[info]       def _1: Double = this.rate
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Action: it.unibo.dap.model.CTMC.Action =
[info]       new it.unibo.dap.model.CTMC.Action()
[info]     final module class Action() extends AnyRef(), scala.deriving.Mirror.Product
[info]        { this: it.unibo.dap.model.CTMC.Action.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.Action.type])
[info]       def apply[S](rate: Double, state: S): it.unibo.dap.model.CTMC.Action[S] =
[info]         new it.unibo.dap.model.CTMC.Action[S](rate, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.CTMC.Action[S]):
[info]         it.unibo.dap.model.CTMC.Action[S] = x$1
[info]       override def toString: String = "Action"
[info]       type MirroredMonoType = it.unibo.dap.model.CTMC.Action[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.CTMC.Action.MirroredMonoType =
[info]         new it.unibo.dap.model.CTMC.Action[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Seq[it.unibo.dap.model.CTMC.Transition[S]] @Repeated):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofTransitions[S](
[info]         rels.toSet[it.unibo.dap.model.CTMC.Transition[S]])
[info]     def ofTransitions[S >: Nothing <: Any](
[info]       rels: Set[it.unibo.dap.model.CTMC.Transition[S]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.CTMC.ofFunction[S]((s: S) =>
[info]         rels.filter((_$1: it.unibo.dap.model.CTMC.Transition[S]) =>
[info]           _$1.state.==(s)).map[it.unibo.dap.model.CTMC.Action[S]]((
[info]           _$2: it.unibo.dap.model.CTMC.Transition[S]) => _$2.action)
[info]       )
[info]     def ofFunction[S >: Nothing <: Any](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] = (s: S) =>
[info]       {
[info]         f.applyOrElse[S, Set[it.unibo.dap.model.CTMC.Action[S]]](s, (_$3: S) =>
[info]           Set.apply[it.unibo.dap.model.CTMC.Action[S]](
[info]             [ : it.unibo.dap.model.CTMC.Action[S]]*)
[info]         )
[info]       }
[info]     final lazy module given val given_Simulatable_CTMC:
[info]       it.unibo.dap.model.CTMC.given_Simulatable_CTMC =
[info]       new it.unibo.dap.model.CTMC.given_Simulatable_CTMC()
[info]     final module class given_Simulatable_CTMC() extends Object(), 
[info]       it.unibo.dap.model.Simulatable[CTMC] {
[info]       this: it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.CTMC.given_Simulatable_CTMC.type])
[info]       import java.util.Random
[info]       extension [S >: Nothing <: Any](self: it.unibo.dap.model.CTMC[S])
[info]         override def simulate(initialState: S)(using rnd: java.util.Random):
[info]         it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Trace[S] =
[info]         LazyList.iterate[it.unibo.dap.model.Simulatable.Event[S]](
[info]           it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](0.0d,
[info]             initialState)
[info]         )((x$1: it.unibo.dap.model.Simulatable.Event[S]) =>
[info]           x$1 match 
[info]             {
[info]               case 
[info]                 it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.unapply[S](
[info]                   t @ _, s @ _)
[info]                =>
[info]                 if self.transitions(s).isEmpty then
[info]                   it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S](
[info]                     t, s)
[info]                  else 
[info]                   {
[info]                     val choices: Set[(Double, S)] =
[info]                       self.transitions(s).map[(Double, S)]((
[info]                         t: it.unibo.dap.model.CTMC.Action[S]) =>
[info]                         Tuple2.apply[Double, S](t.rate, t.state))
[info]                     val next: List[(Double, S)] =
[info]                       it.unibo.dap.model.Stochastics.cumulative[S](
[info]                         choices.toList)
[info]                     val sumR: Double = next.last._1
[info]                     val choice: S =
[info]                       it.unibo.dap.model.Stochastics.draw[S](next)(using
[info]                         it.unibo.dap.model.Stochastics.draw$default$2[S](next))
[info]                     it.unibo.dap.model.CTMC.given_Simulatable_CTMC.Event.apply[S
[info]                       ](t.+(Math.log(1./(rnd.nextDouble()))./(sumR)), choice)
[info]                   }
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala
[info] package it.unibo.dap.model {
[info]   import it.unibo.dap.model.CTMC.*
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val DAP: it.unibo.dap.model.DAP =
[info]     new it.unibo.dap.model.DAP()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/DAP.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class DAP() extends Object() {
[info]     this: it.unibo.dap.model.DAP.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.DAP.type])
[info]     case class Rule[T >: Nothing <: Any](pre: it.unibo.dap.model.MSet[T],
[info]       rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]       eff: it.unibo.dap.model.MSet[T], msg: Option[T]) extends Object(),
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.Rule[T] @unchecked =>
[info]                 this.pre.==(x$0.pre).&&(this.rateExp.==(x$0.rateExp)).&&(
[info]                   this.eff.==(x$0.eff)).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.Rule[T] @unchecked]
[info]       override def productArity: Int = 4
[info]       override def productPrefix: String = "Rule"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case 2 => this._3
[info]             case 3 => this._4
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "pre"
[info]             case 1 => "rateExp"
[info]             case 2 => "eff"
[info]             case 3 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val pre: it.unibo.dap.model.MSet[T]
[info]       val rateExp: it.unibo.dap.model.MSet[T] => Double
[info]       val eff: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = Rule.this.pre
[info]       def copy$default$2[T]: it.unibo.dap.model.MSet[T] => Double =
[info]         Rule.this.rateExp
[info]       def copy$default$3[T]: it.unibo.dap.model.MSet[T] = Rule.this.eff
[info]       def copy$default$4[T]: Option[T] = Rule.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.pre
[info]       def _2: it.unibo.dap.model.MSet[T] => Double = this.rateExp
[info]       def _3: it.unibo.dap.model.MSet[T] = this.eff
[info]       def _4: Option[T] = this.msg
[info]     }
[info]     final lazy module val Rule: it.unibo.dap.model.DAP.Rule =
[info]       new it.unibo.dap.model.DAP.Rule()
[info]     final module class Rule() extends AnyRef(), scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.DAP.Rule.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.Rule.type])
[info]       def apply[T](pre: it.unibo.dap.model.MSet[T],
[info]         rateExp: it.unibo.dap.model.MSet[T] => Double,
[info]         eff: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] =
[info]         new it.unibo.dap.model.DAP.Rule[T](pre, rateExp, eff, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.Rule[T]):
[info]         it.unibo.dap.model.DAP.Rule[T] = x$1
[info]       override def toString: String = "Rule"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.Rule[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.Rule.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.Rule[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[
[info]             it.unibo.dap.model.MSet[Any] => Double],
[info]           x$0.productElement(2).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(3).$asInstanceOf[Option[Any]])
[info]     }
[info]     type DAP[T >: Nothing <: Any] = Set[it.unibo.dap.model.DAP.Rule[T]]
[info]     case class State[T >: Nothing <: Any](tokens: it.unibo.dap.model.MSet[T],
[info]       msg: Option[T]) extends Object(), _root_.scala.Product, _root_.scala.
[info]       Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.DAP.State[T] @unchecked =>
[info]                 this.tokens.==(x$0.tokens).&&(this.msg.==(x$0.msg)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.DAP.State[T] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "State"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "tokens"
[info]             case 1 => "msg"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       T
[info]       val tokens: it.unibo.dap.model.MSet[T]
[info]       val msg: Option[T]
[info]       def copy[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def copy$default$1[T]: it.unibo.dap.model.MSet[T] = State.this.tokens
[info]       def copy$default$2[T]: Option[T] = State.this.msg
[info]       def _1: it.unibo.dap.model.MSet[T] = this.tokens
[info]       def _2: Option[T] = this.msg
[info]     }
[info]     final lazy module val State: it.unibo.dap.model.DAP.State =
[info]       new it.unibo.dap.model.DAP.State()
[info]     final module class State() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.DAP.State.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.DAP.State.type])
[info]       def apply[T](tokens: it.unibo.dap.model.MSet[T], msg: Option[T]):
[info]         it.unibo.dap.model.DAP.State[T] =
[info]         new it.unibo.dap.model.DAP.State[T](tokens, msg)
[info]       def unapply[T](x$1: it.unibo.dap.model.DAP.State[T]):
[info]         it.unibo.dap.model.DAP.State[T] = x$1
[info]       override def toString: String = "State"
[info]       type MirroredMonoType = it.unibo.dap.model.DAP.State[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.DAP.State.MirroredMonoType =
[info]         new it.unibo.dap.model.DAP.State[Any](
[info]           x$0.productElement(0).$asInstanceOf[it.unibo.dap.model.MSet[Any]],
[info]           x$0.productElement(1).$asInstanceOf[Option[Any]])
[info]     }
[info]     def apply[T >: Nothing <: Any](
[info]       rules: Seq[it.unibo.dap.model.DAP.Rule[T]] @Repeated)(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] =
[info]       rules.toSet[it.unibo.dap.model.DAP.Rule[T]]
[info]     def apply[T >: Nothing <: Any](rules: Set[it.unibo.dap.model.DAP.Rule[T]])(
[info]       using evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.DAP.DAP[T] = rules
[info]     def toCTMC[T >: Nothing <: Any](spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]] =
[info]       it.unibo.dap.model.CTMC.ofFunction[it.unibo.dap.model.DAP.State[T]](
[info]         it.unibo.dap.model.DAP.toPartialFunction[T](spn)(evidence$1))
[info]     private[this] def toPartialFunction[T >: Nothing <: Any](
[info]       spn: it.unibo.dap.model.DAP.DAP[T])(using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       PartialFunction[it.unibo.dap.model.DAP.State[T],
[info]         Set[it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]]
[info]      = (x$1: it.unibo.dap.model.DAP.State[T]) =>
[info]       x$1 match 
[info]         {
[info]           case it.unibo.dap.model.DAP.State.unapply[T](tokens @ _, _) =>
[info]             spn.flatMap[
[info]               it.unibo.dap.model.CTMC.Action[it.unibo.dap.model.DAP.State[T]]]((
[info]               x$1: it.unibo.dap.model.DAP.Rule[T]) =>
[info]               x$1:it.unibo.dap.model.DAP.Rule[T] @unchecked match 
[info]                 {
[info]                   case 
[info]                     it.unibo.dap.model.DAP.Rule.unapply[T](pre @ _,
[info]                       rateExp @ _, eff @ _, msg @ _)
[info]                    =>
[info]                     tokens.extract(pre)(evidence$1).map[
[info]                       
[info]                         it.unibo.dap.model.CTMC.Action[
[info]                           it.unibo.dap.model.DAP.State[T]]
[info]                       
[info]                     ]((out: it.unibo.dap.model.MSet[T]) =>
[info]                       {
[info]                         val newtokens: it.unibo.dap.model.MSet[T] =
[info]                           out.union(eff)
[info]                         val rate: Double = rateExp.apply(tokens)
[info]                         it.unibo.dap.model.CTMC.Action.apply[
[info]                           it.unibo.dap.model.DAP.State[T]](rate,
[info]                           it.unibo.dap.model.DAP.State.apply[T](newtokens, msg))
[info]                         }
[info]                     )
[info]                 }
[info]             )
[info]         }
[info]     final given def given_Conversion_DAP_CTMC[T >: Nothing <: Any](using 
[info]       evidence$1: it.unibo.dap.model.Equatable[T]):
[info]       Conversion[it.unibo.dap.model.DAP.DAP[T],
[info]         it.unibo.dap.model.CTMC[it.unibo.dap.model.DAP.State[T]]]
[info]      = (spn: it.unibo.dap.model.DAP.DAP[T]) =>
[info]       it.unibo.dap.model.DAP.toCTMC[T](spn)(evidence$1)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Equatable[T >: Nothing <: Any]() extends Object, ((T, T) => Boolean) {
[info]     T
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable: it.unibo.dap.model.Equatable =
[info]     new it.unibo.dap.model.Equatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Equatable() extends Object() {
[info]     this: it.unibo.dap.model.Equatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable.type])
[info]     def apply[T >: Nothing <: Any](using x$1: it.unibo.dap.model.Equatable[T]):
[info]       it.unibo.dap.model.Equatable[T] = x$1
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Equatable$package:
[info]     it.unibo.dap.model.Equatable$package =
[info]     new it.unibo.dap.model.Equatable$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Equatable.scala")
[info]     final module class Equatable$package() extends Object() {
[info]     this: it.unibo.dap.model.Equatable$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Equatable$package.type])
[info]     extension [T >: Nothing <: Any](t1: T)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def ===
[info]     (t2: T)(using eq: it.unibo.dap.model.Equatable[T]): Boolean =
[info]       eq.apply(t1, t2)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait MSet[A >: Nothing <: Any]() extends Object, (A => Int) {
[info]     A
[info]     def union(m: it.unibo.dap.model.MSet[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def diff(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       it.unibo.dap.model.MSet[MSet.this.A]
[info]     def matches(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]): Boolean
[info]     def extract(m: it.unibo.dap.model.MSet[MSet.this.A])(using 
[info]       x$2: it.unibo.dap.model.Equatable[MSet.this.A]):
[info]       Option[it.unibo.dap.model.MSet[MSet.this.A]]
[info]     def map[B >: Nothing <: Any](f: A => B): it.unibo.dap.model.MSet[B]
[info]     def flatMap[B >: Nothing <: Any](f: A => it.unibo.dap.model.MSet[B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def filter(f: A => Boolean): it.unibo.dap.model.MSet[MSet.this.A]
[info]     def collect[B >: Nothing <: Any](f: PartialFunction[MSet.this.A, B]):
[info]       it.unibo.dap.model.MSet[B]
[info]     def size: Int
[info]     def asList: List[MSet.this.A]
[info]     def asMap: Map[MSet.this.A, Int]
[info]     def iterator: Iterator[MSet.this.A]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSet: it.unibo.dap.model.MSet =
[info]     new it.unibo.dap.model.MSet()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/MSet.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSet() extends Object() {
[info]     this: it.unibo.dap.model.MSet.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.MSet.type])
[info]     def apply[A >: Nothing <: Any](l: Seq[A] @Repeated):
[info]       it.unibo.dap.model.MSet[A] = new MSetImpl[A](l.toList)
[info]     def ofList[A >: Nothing <: Any](l: List[A]): it.unibo.dap.model.MSet[A] =
[info]       new MSetImpl[A](l)
[info]     def ofMap[A >: Nothing <: Any](m: Map[A, Int]): it.unibo.dap.model.MSet[A]
[info]        = it.unibo.dap.model.MSet.MSetImpl.apply[A](m)
[info]     import scala.collection.immutable
[info]     private[this] case class MSetImpl[A >: Nothing <: Any](asMap: Map[A, Int])
[info]        extends Object(), it.unibo.dap.model.MSet[MSetImpl.this.A],
[info]       _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(this)
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.MSet.MSetImpl[A] @unchecked =>
[info]                 this.asMap.==(x$0.asMap).&&(x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.MSet.MSetImpl[A] @unchecked]
[info]       override def productArity: Int = 1
[info]       override def productPrefix: String = "MSetImpl"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "asMap"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       A
[info]       val asMap: Map[A, Int]
[info]       def <init>[A >: Nothing <: Any](list: List[A]): Unit =
[info]         {
[info]           this[A](
[info]             list.groupBy[A]((a: A) => a).map[A, Int]((x$1: (A, List[A])) =>
[info]               x$1 match 
[info]                 {
[info]                   case Tuple2.unapply[A, List[A]](a @ _, n @ _) =>
[info]                     Tuple2.apply[A, Int](a, n.size)
[info]                 }
[info]             )
[info]           )
[info]           ()
[info]         }
[info]       override val asList: List[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.toList.flatMap[A]((x$1: (A, Int)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[A, Int](a @ _, n @ _) =>
[info]                 scala.collection.immutable.List.fill[A](n)(a)
[info]             }
[info]         )
[info]       override def apply(v1: MSetImpl.this.A): Int =
[info]         MSetImpl.this.asMap.getOrElse[Int](v1, 0)
[info]       override def union(m: it.unibo.dap.model.MSet[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.++[A](m.asList))
[info]       override def diff(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           m.asList.foldLeft[List[A]](this.asList)((acc: List[A], elem: A) =>
[info]             {
[info]               val index: Int =
[info]                 acc.indexWhere((_$1: A) =>
[info]                   it.unibo.dap.model.===[A](_$1)(elem)(x$2))
[info]               if index.>=(0) then acc.patch[A](index, Nil, 1) else acc
[info]             }
[info]           )
[info]         )
[info]       override def matches(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]): Boolean =
[info]         this.extract(m)(x$2).isDefined
[info]       override def extract(m: it.unibo.dap.model.MSet[MSetImpl.this.A])(using 
[info]         x$2: it.unibo.dap.model.Equatable[MSetImpl.this.A]):
[info]         Option[it.unibo.dap.model.MSet[MSetImpl.this.A]] =
[info]         Some.apply[it.unibo.dap.model.MSet[A]](this.diff(m)(x$2)).filter((
[info]           _$2: it.unibo.dap.model.MSet[A]) => _$2.size.==(this.size.-(m.size)))
[info]       override def iterator: Iterator[MSetImpl.this.A] =
[info]         MSetImpl.this.asMap.keysIterator
[info]       override def map[B >: Nothing <: Any](f: A => B):
[info]         it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.map[B](f))
[info]       override def flatMap[B >: Nothing <: Any](
[info]         f: A => it.unibo.dap.model.MSet[B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](
[info]           this.asList.flatMap[B]((_$3: A) => f.apply(_$3).asList))
[info]       override def filter(f: A => Boolean): it.unibo.dap.model.MSet[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[MSetImpl.this.A](
[info]           this.asList.filter(f))
[info]       override def collect[B >: Nothing <: Any](
[info]         f: PartialFunction[MSetImpl.this.A, B]): it.unibo.dap.model.MSet[B] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[B](this.asList.collect[B](f))
[info]       override def size: Int = this.asList.size
[info]       override def toString: String =
[info]         _root_.scala.StringContext.apply(["{","}" : String]*).s(
[info]           [this.asList.mkString("|") : Any]*)
[info]       def copy[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def copy$default$1[A]: Map[A, Int] = MSetImpl.this.asMap
[info]       def _1: Map[A, Int] = this.asMap
[info]     }
[info]     private[this] final lazy module val MSetImpl:
[info]       it.unibo.dap.model.MSet.MSetImpl = new it.unibo.dap.model.MSet.MSetImpl()
[info]     private[this] final module class MSetImpl() extends AnyRef(), 
[info]       scala.deriving.Mirror.Product {
[info]       this: it.unibo.dap.model.MSet.MSetImpl.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.MSet.MSetImpl.type])
[info]       def apply[A](asMap: Map[A, Int]): it.unibo.dap.model.MSet.MSetImpl[A] =
[info]         new it.unibo.dap.model.MSet.MSetImpl[A](asMap)
[info]       def unapply[A](x$1: it.unibo.dap.model.MSet.MSetImpl[A]):
[info]         it.unibo.dap.model.MSet.MSetImpl[A] = x$1
[info]       override def toString: String = "MSetImpl"
[info]       type MirroredMonoType = it.unibo.dap.model.MSet.MSetImpl[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.MSet.MSetImpl.MirroredMonoType =
[info]         new it.unibo.dap.model.MSet.MSetImpl[Any](
[info]           x$0.productElement(0).$asInstanceOf[Map[Any, Int]])
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala
[info] package it.unibo.dap.model {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Simulatable[M[_ >: Nothing <: Any] >: Nothing <: Any]() extends Object
[info]      {
[info]     M[_$1]
[info]     export it.unibo.dap.model.Simulatable.*
[info]     final def Event: it.unibo.dap.model.Simulatable.Event.type =
[info]       it.unibo.dap.model.Simulatable.Event
[info]     final type Event[S] = it.unibo.dap.model.Simulatable.Event[S]
[info]     final type Trace[S] = it.unibo.dap.model.Simulatable.Trace[S]
[info]     import java.util.Random
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S]) def simulate(
[info]       initialState: S)(using x$3: java.util.Random): Simulatable.this.Trace[S]
[info]     extension [S >: Nothing <: Any](self: Simulatable.this.M[S])
[info]       def simulateStep(s: S)(using x$3: java.util.Random):
[info]       Simulatable.this.Event[S] = this.simulate[S](self)(s)(x$3).drop(1).head
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Simulatable: it.unibo.dap.model.Simulatable =
[info]     new it.unibo.dap.model.Simulatable()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Simulatable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Simulatable() extends Object() {
[info]     this: it.unibo.dap.model.Simulatable.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Simulatable.type])
[info]     type Trace[S >: Nothing <: Any] =
[info]       LazyList[it.unibo.dap.model.Simulatable.Event[S]]
[info]     case class Event[S >: Nothing <: Any](time: Double, state: S) extends
[info]       Object(), _root_.scala.Product, _root_.scala.Serializable {
[info]       override def hashCode(): Int =
[info]         {
[info]           var acc: Int = -889275714
[info]           acc = scala.runtime.Statics.mix(acc, this.productPrefix.hashCode())
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.doubleHash(Event.this.time))
[info]           acc =
[info]             scala.runtime.Statics.mix(acc,
[info]               scala.runtime.Statics.anyHash(Event.this.state))
[info]           scala.runtime.Statics.finalizeHash(acc, 2)
[info]         }
[info]       override def equals(x$0: Any): Boolean =
[info]         this.eq(x$0.$asInstanceOf[Object]).||(
[info]           x$0 match 
[info]             {
[info]               case x$0 @ _:it.unibo.dap.model.Simulatable.Event[S] @unchecked
[info]                  =>
[info]                 this.time.==(x$0.time).&&(this.state.==(x$0.state)).&&(
[info]                   x$0.canEqual(this))
[info]               case _ => false
[info]             }
[info]         )
[info]       override def toString(): String =
[info]         scala.runtime.ScalaRunTime._toString(this)
[info]       override def canEqual(that: Any): Boolean =
[info]         that.isInstanceOf[it.unibo.dap.model.Simulatable.Event[S] @unchecked]
[info]       override def productArity: Int = 2
[info]       override def productPrefix: String = "Event"
[info]       override def productElement(n: Int): Any =
[info]         n match 
[info]           {
[info]             case 0 => this._1
[info]             case 1 => this._2
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       override def productElementName(n: Int): String =
[info]         n match 
[info]           {
[info]             case 0 => "time"
[info]             case 1 => "state"
[info]             case _ => throw new IndexOutOfBoundsException(n.toString())
[info]           }
[info]       S
[info]       val time: Double
[info]       val state: S
[info]       def copy[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def copy$default$1[S]: Double @uncheckedVariance = Event.this.time
[info]       def copy$default$2[S]: S = Event.this.state
[info]       def _1: Double = this.time
[info]       def _2: S = this.state
[info]     }
[info]     final lazy module val Event: it.unibo.dap.model.Simulatable.Event =
[info]       new it.unibo.dap.model.Simulatable.Event()
[info]     final module class Event() extends AnyRef(), scala.deriving.Mirror.Product {
[info]        this: it.unibo.dap.model.Simulatable.Event.type =>
[info]       private def writeReplace(): AnyRef =
[info]         new scala.runtime.ModuleSerializationProxy(
[info]           classOf[it.unibo.dap.model.Simulatable.Event.type])
[info]       def apply[S](time: Double, state: S):
[info]         it.unibo.dap.model.Simulatable.Event[S] =
[info]         new it.unibo.dap.model.Simulatable.Event[S](time, state)
[info]       def unapply[S](x$1: it.unibo.dap.model.Simulatable.Event[S]):
[info]         it.unibo.dap.model.Simulatable.Event[S] = x$1
[info]       override def toString: String = "Event"
[info]       type MirroredMonoType = it.unibo.dap.model.Simulatable.Event[? <: AnyKind]
[info]       def fromProduct(x$0: Product):
[info]         it.unibo.dap.model.Simulatable.Event.MirroredMonoType =
[info]         new it.unibo.dap.model.Simulatable.Event[Any](
[info]           x$0.productElement(0).$asInstanceOf[Double], x$0.productElement(1))
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala
[info] package it.unibo.dap.model {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Stochastics: it.unibo.dap.model.Stochastics =
[info]     new it.unibo.dap.model.Stochastics()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/Stochastics.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Stochastics() extends Object() {
[info]     this: it.unibo.dap.model.Stochastics.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.Stochastics.type])
[info]     import scala.util.Random
[info]     def cumulative[A >: Nothing <: Any](l: List[Tuple2[Double, A]]):
[info]       List[Tuple2[Double, A]] =
[info]       l.tail.scanLeft[(Double, A)](l.head)((x$1: (Double, A),
[info]         x$2: (Double, A) @uncheckedVariance) =>
[info]         Tuple2.apply[(Double, A), (Double, A) @uncheckedVariance](x$1, x$2)
[info]            match 
[info]           {
[info]             case 
[info]               Tuple2.unapply[(Double, A), (Double, A)](
[info]                 Tuple2.unapply[Double, A](r @ _, _),
[info]                 Tuple2.unapply[Double, A](r2 @ _, a2 @ _))
[info]              =>
[info]               Tuple2.apply[Double, A](r.+(r2), a2)
[info]           }
[info]       )
[info]     def draw[A >: Nothing <: Any](cumulativeList: List[Tuple2[Double, A]])(
[info]       using rnd: scala.util.Random): A =
[info]       {
[info]         val rndVal: Double = rnd.nextDouble().*(cumulativeList.last._1)
[info]         cumulativeList.collectFirst[A]((x$1: (Double, A)) =>
[info]           x$1 match 
[info]             {
[info]               case Tuple2.unapply[Double, A](r @ _, a @ _) if r.>=(rndVal) =>
[info]                 a:A
[info]             }
[info]         ).get
[info]       }
[info]     def draw$default$2[A >: Nothing <: Any](
[info]       cumulativeList: List[Tuple2[Double, A]]):
[info]       scala.util.Random @uncheckedVariance = new scala.util.Random()
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val CTMCDsl: it.unibo.dap.model.dsl.CTMCDsl =
[info]     new it.unibo.dap.model.dsl.CTMCDsl()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/CTMCDsl.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class CTMCDsl() extends Object() {
[info]     this: it.unibo.dap.model.dsl.CTMCDsl.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.CTMCDsl.type])
[info]     export it.unibo.dap.model.CTMC
[info]     final def CTMC: it.unibo.dap.model.CTMC.type = it.unibo.dap.model.CTMC
[info]     final type CTMC[S] = it.unibo.dap.model.CTMC[S]
[info]     export it.unibo.dap.model.dsl.CTMCDsl.CTMC.*
[info]     final def ofFunction[S](
[info]       f: PartialFunction[S, Set[it.unibo.dap.model.CTMC.Action[S]]]):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofFunction[S](f)
[info]     final def Transition: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition
[info]     final type Transition[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Transition[S]
[info]     final def Action: it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action.type =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action
[info]     final type Action[S] = it.unibo.dap.model.dsl.CTMCDsl.CTMC.Action[S]
[info]     final def ofTransitions[S](rels: Set[it.unibo.dap.model.CTMC.Transition[S]])
[info]       : it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels)
[info]     final def ofTransitions[S](rels: it.unibo.dap.model.CTMC.Transition[S]*):
[info]       it.unibo.dap.model.CTMC[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.CTMC.ofTransitions[S](rels*)
[info]     extension [S >: Nothing <: Any](state: S) def --(rate: Double):
[info]       Tuple2[S, Double] = Tuple2.apply[S, Double](state, rate)
[info]     extension [S >: Nothing <: Any](self: Tuple2[S, Double]) def -->(
[info]       finalState: S): it.unibo.dap.model.dsl.CTMCDsl.Transition[S] =
[info]       it.unibo.dap.model.dsl.CTMCDsl.Transition.apply[S](self._1,
[info]         it.unibo.dap.model.dsl.CTMCDsl.Action.apply[S](self._2, finalState))
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala
[info] package it.unibo.dap.model.dsl {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val MSetDSL: it.unibo.dap.model.dsl.MSetDSL =
[info]     new it.unibo.dap.model.dsl.MSetDSL()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/model/dsl/MSetDSL.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class MSetDSL() extends Object() {
[info]     this: it.unibo.dap.model.dsl.MSetDSL.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.model.dsl.MSetDSL.type])
[info]     export it.unibo.dap.model.MSet
[info]     final def MSet: it.unibo.dap.model.MSet.type = it.unibo.dap.model.MSet
[info]     final type MSet[A] = it.unibo.dap.model.MSet[A]
[info]     export it.unibo.dap.model.dsl.MSetDSL.given
[info]     extension [T >: Nothing <: Any](a: T) def |(b: T): List[T] =
[info]       List.apply[T]([a,b : T]*)
[info]     extension [T >: Nothing <: Any](xs: List[T]) def |(x: T): List[T] =
[info]       xs.:+[T](x)
[info]     final given def listSetConversion[T >: Nothing <: Any]:
[info]       Conversion[List[T], it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (
[info]       _$1: List[T]) => it.unibo.dap.model.dsl.MSetDSL.MSet.ofList[T](_$1)
[info]     final given def elemSetConversion[T >: Nothing <: Any]:
[info]       Conversion[T, it.unibo.dap.model.dsl.MSetDSL.MSet[T]] = (_$2: T) =>
[info]       it.unibo.dap.model.dsl.MSetDSL.MSet.apply[T]([_$2 : T]*)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.duration.FiniteDuration
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait AsyncOperations() extends Object {
[info]     def sleep(duration: scala.concurrent.duration.FiniteDuration):
[info]       scala.concurrent.Future[Unit]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Async: it.unibo.dap.utils.Async =
[info]     new it.unibo.dap.utils.Async()
[info]   @SourceFile(
[info]     "dap/shared/src/main/scala/it/unibo/dap/utils/AsyncOperations.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Async() extends Object() {
[info]     this: it.unibo.dap.utils.Async.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Async.type])
[info]     def operations: it.unibo.dap.utils.AsyncOperations =
[info]       it.unibo.dap.utils.Platform.asyncOps
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{Future, Promise}
[info]   import scala.util.Try
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait ReadableChannel[T >: Nothing <: Any]() extends Object {
[info]     +T
[info]     def poll(): Option[ReadableChannel.this.T]
[info]     def pop(): scala.concurrent.Future[ReadableChannel.this.T]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait SendableChannel[T >: Nothing <: Any]() extends Object {
[info]     -T
[info]     def push(item: SendableChannel.this.T):
[info]       Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]     def close(): Either[it.unibo.dap.utils.Channel.Error, Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Channel[T >: Nothing <: Any]() extends Object,
[info]     it.unibo.dap.utils.ReadableChannel[Channel.this.T], it.unibo.dap.utils.
[info]     SendableChannel[Channel.this.T] {
[info]     T
[info]     def asReadable: it.unibo.dap.utils.ReadableChannel[Channel.this.T] = this
[info]     def asSendable: it.unibo.dap.utils.SendableChannel[Channel.this.T] = this
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Channel: it.unibo.dap.utils.Channel =
[info]     new it.unibo.dap.utils.Channel()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Channels.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Channel() extends Object() {
[info]     this: it.unibo.dap.utils.Channel.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Channel.type])
[info]     type Error = String
[info]     def apply[T >: Nothing <: Any](): it.unibo.dap.utils.Channel[T] =
[info]       new it.unibo.dap.utils.Channel.ChannelImpl[T]()
[info]     def readable[T >: Nothing <: Any](): it.unibo.dap.utils.ReadableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Nothing]().asReadable
[info]     def sendable[T >: Nothing <: Any](): it.unibo.dap.utils.SendableChannel[T]
[info]        = it.unibo.dap.utils.Channel.apply[Any]().asSendable
[info]     private[this] class ChannelImpl[T >: Nothing <: Any]() extends Object(), 
[info]       it.unibo.dap.utils.Channel[ChannelImpl.this.T] {
[info]       T
[info]       private[this] var closed: Boolean = false
[info]       private[this] val buffer: scala.collection.mutable.Queue[T] =
[info]         scala.collection.mutable.Queue.empty[ChannelImpl.this.T]
[info]       private[this] val waiters:
[info]         scala.collection.mutable.Queue[scala.concurrent.Promise[T]] =
[info]         scala.collection.mutable.Queue.empty[
[info]           scala.concurrent.Promise[ChannelImpl.this.T]]
[info]       override def push(item: ChannelImpl.this.T):
[info]         Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing](
[info]               "Channel is closed. No more items can be pushed.")
[info]            else 
[info]             if this.waiters.nonEmpty then
[info]               it.unibo.dap.utils.unit[String, scala.concurrent.Promise[T]](
[info]                 scala.util.Try.apply[scala.concurrent.Promise[T]](
[info]                   this.waiters.dequeue().success(item)).toEither.left.map[String
[info]                   ]((_$1: Throwable) => _$1.getMessage())
[info]               )
[info]              else 
[info]               Right.apply[Nothing, Unit](
[info]                 {
[info]                   this.buffer.enqueue(item)
[info]                   ()
[info]                 }
[info]               )
[info]         )
[info]       override def pop(): scala.concurrent.Future[ChannelImpl.this.T] =
[info]         this.synchronized[scala.concurrent.Future[T]](
[info]           this.poll() match 
[info]             {
[info]               case Some.unapply[T](item @ _):Some[T] =>
[info]                 scala.concurrent.Future.successful[T](item)
[info]               case _ if this.closed =>
[info]                 scala.concurrent.Future.failed[Nothing](
[info]                   new NoSuchElementException(
[info]                     "Channel is closed and no items are available.")
[info]                 )
[info]               case _ =>
[info]                 val promise: scala.concurrent.Promise[T] =
[info]                   scala.concurrent.Promise.apply[ChannelImpl.this.T]()
[info]                 this.waiters.enqueue(promise)
[info]                 promise.future:scala.concurrent.Future[T]
[info]             }
[info]         )
[info]       override def poll(): Option[ChannelImpl.this.T] =
[info]         this.synchronized[Option[T]](
[info]           Option.when[T](this.buffer.nonEmpty)(this.buffer.dequeue()))
[info]       override def close(): Either[it.unibo.dap.utils.Channel.Error, Unit] =
[info]         this.synchronized[Either[String, Unit]](
[info]           if this.closed then
[info]             Left.apply[String, Nothing]("Channel is already closed.") else 
[info]             {
[info]               this.closed = true
[info]               this.waiters.foreach[scala.concurrent.Promise[T]]((
[info]                 _$2: scala.concurrent.Promise[T]) =>
[info]                 _$2.failure(new NoSuchElementException("Channel is closed.")))
[info]               this.waiters.clear()
[info]               Right.apply[Nothing, Unit](())
[info]             }
[info]         )
[info]     }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala
[info] package it.unibo.dap.utils {
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Iso[A >: Nothing <: Any, B >: Nothing <: Any]() extends Object {
[info]     A
[info]     B
[info]     def to(a: Iso.this.A): Iso.this.B
[info]     def from(b: Iso.this.B): Iso.this.A
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso: it.unibo.dap.utils.Iso =
[info]     new it.unibo.dap.utils.Iso()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class Iso() extends Object() {
[info]     this: it.unibo.dap.utils.Iso.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso.type])
[info]     inline def apply[A >: Nothing <: Any, B >: Nothing <: Any](toFn: A => B,
[info]       fromFn: B => A): it.unibo.dap.utils.Iso[A, B] =
[info]       {
[info]         final class $anon() extends Object(), it.unibo.dap.utils.Iso[A, B] {
[info]           def to(a: A): B = toFn.apply(a)
[info]           def from(b: B): A = fromFn.apply(b)
[info]         }
[info]         new $anon():it.unibo.dap.utils.Iso[A, B]
[info]       }:it.unibo.dap.utils.Iso[A, B]
[info]   }
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Iso$package: it.unibo.dap.utils.Iso$package =
[info]     new it.unibo.dap.utils.Iso$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala") final
[info]     module class Iso$package() extends Object() {
[info]     this: it.unibo.dap.utils.Iso$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Iso$package.type])
[info]     extension [A >: Nothing <: Any](a: A)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def as
[info]     [B >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): B =
[info]       iso.to(a)
[info]     extension [B >: Nothing <: Any](b: B)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def back
[info]     [A >: Nothing <: Any](using iso: it.unibo.dap.utils.Iso[A, B]): A =
[info]       iso.from(b)
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.{ExecutionContext, Future}
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Task[T >: Nothing <: Any]() extends Object, (() =>
[info]     scala.concurrent.Future[T]) {
[info]     T
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait Spawnable[Configuration >: Nothing <: Any]() extends Object {
[info]     Configuration
[info]     def spawn(configuration: Spawnable.this.Configuration)(using 
[info]       x$2: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
[info]   }
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Spawnable.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     trait PlainSpawnable() extends Object, it.unibo.dap.utils.Spawnable[Unit] {}
[info]   }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala
[info] package it.unibo.dap.utils {
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val TimeOps: it.unibo.dap.utils.TimeOps =
[info]     new it.unibo.dap.utils.TimeOps()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/TimeOps.scala")
[info]     @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final module class TimeOps() extends Object() {
[info]     this: it.unibo.dap.utils.TimeOps.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.TimeOps.type])
[info]     def timed[A >: Nothing <: Any](input: => A): A =
[info]       {
[info]         val t0: Long = java.lang.System.nanoTime()
[info]         try input finally 
[info]           scribe.package.info(
[info]             "Timed op (msec): ".+(java.lang.System.nanoTime().-(t0)./(1000000)))
[info]             (sourcecode.Pkg.apply("it.unibo.dap.utils"):sourcecode.Pkg,
[info]             sourcecode.FileName.apply("TimeOps.scala"):sourcecode.FileName,
[info]             sourcecode.Name.apply("timed"):sourcecode.Name,
[info]             sourcecode.Line.apply(9):sourcecode.Line, scribe.mdc.MDC.instance)
[info]       }
[info]   }
[info] }
[info] [[syntax trees at end of                  inlining]] // /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala
[info] package it.unibo.dap.utils {
[info]   import scala.concurrent.Future
[info]   import scala.concurrent.ExecutionContext
[info]   @experimental("Added by -language:experimental.experimental.betterFors")
[info]     final lazy module val Utils$package: it.unibo.dap.utils.Utils$package =
[info]     new it.unibo.dap.utils.Utils$package()
[info]   @SourceFile("dap/shared/src/main/scala/it/unibo/dap/utils/Utils.scala") final
[info]     module class Utils$package() extends Object() {
[info]     this: it.unibo.dap.utils.Utils$package.type =>
[info]     private def writeReplace(): AnyRef =
[info]       new scala.runtime.ModuleSerializationProxy(
[info]         classOf[it.unibo.dap.utils.Utils$package.type])
[info]     extension [L >: Nothing <: Any, R >: Nothing <: Any](e: Either[L, R])
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : Either[L, Unit] = e.map[Unit]((_$1: R) => ())
[info]     extension [T >: Nothing <: Any](f: scala.concurrent.Future[T])(using 
[info]       x$2: scala.concurrent.ExecutionContext)
[info]       @experimental("Added by -language:experimental.experimental.betterFors")
[info]         def unit
[info]     : scala.concurrent.Future[Unit] = f.map[Unit]((_$2: T) => ())(x$2)
[info]   }
[info] }
[warn] -- [E198] Unused Symbol Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/jvm-native/src/main/scala/it/unibo/dap/boundary/sockets/SocketNetworking.scala:27:20 
[warn] 27 |        private val acceptLoop = Future:
[warn]    |                    ^^^^^^^^^^
[warn]    |                    unused private member
[warn] -- [E198] Unused Symbol Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/native/src/main/scala/it/unibo/dap/api/NativeProductApi.scala:119:46 
[warn] 119 |    given Conversion[State[CToken], CState] = s =>
[warn]     |                                              ^
[warn]     |                                              unused local definition
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/api/ProductApi.scala:23:40 
[warn] 23 |      given Equatable[Token] = (t1, t2) => equalizer(t1, t2)
[warn]    |                                        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[warn] -- [E197] Potential Issue Warning: /Users/lucatassi/Projects/master-thesis/dap/dap/shared/src/main/scala/it/unibo/dap/utils/Iso.scala:11:8 
[warn] 11 |    new Iso[A, B]:
[warn]    |        ^
[warn]    |   New anonymous class definition will be duplicated at each inline site
[warn]    |----------------------------------------------------------------------------
[warn]    | Explanation (enabled by `-explain`)
[warn]    |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[warn]    | Anonymous class will be defined at each use site, which may lead to a larger number of classfiles.
[warn]    |
[warn]    | To inline class definitions, you may provide an explicit class name to avoid this warning.
[warn]     ----------------------------------------------------------------------------
[warn] 9 warnings found
[success] Total time: 29 s, completed May 1, 2025, 10:52:52 PM
  ~/Projects/master-thesis/dap     new-native    1  1                                                                                                   11175  22:52:52  

