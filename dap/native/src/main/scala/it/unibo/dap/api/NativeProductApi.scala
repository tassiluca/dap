package it.unibo.dap.api

import scala.scalanative.unsafe.Size.intToSize
import scala.language.postfixOps
import scala.scalanative.unsafe.*
import it.unibo.dap.utils.CUtils.freshPointer
import libdap.aliases.Token as CToken
import libdap.structs.{
  DAPState as CDAPState,
  MSet_Neighbour as CMSetNeighbour,
  MSet_Token as CMSetToken,
  Rule as CRule,
}

import scala.scalanative.libc

/** Bindings from / to Scala Native <==> Product API types.
  * Scala Native types are generated by Bindgen from the C header file and are available in
  * `libdap` package under `src/managed` target directory.
  */
object NativeProductApi extends ProductAPI:

  override val interface: NativeInterface.type = NativeInterface

  object NativeInterface extends ProductInterface with NativeADTs

  trait NativeADTs extends ADTs:
    override type Token = CToken

    given cmsetCvt: Conversion[Ptr[CMSetToken], MSet[Token]] = m =>
      MSet((0 until (!m).size.toInt).map(i => (!m).elements(i)).toList*)

    extension (m: MSet[Token])

      def toCMSetToken(using Zone): Ptr[CMSetToken] =
        val cmset = CMSetToken()
        (!cmset).size = m.elems.size.toCSize
        val elems = freshPointer[CToken](m.elems.size)
        (!cmset).elements = elems
        m.elems.zipWithIndex.foreach: (t, i) =>
          elems(i) = CToken(t.value)
        cmset

    given Conversion[Ptr[CMSetNeighbour], Set[Neighbour]] = m =>
      (0 until (!m).size.toInt)
        .map(i => (!m).elements(i))
        .map(n => fromCString(n.value))
        .toSet

    extension (r: CRule)

      def toRule: Rule =
        val rateF = (_: MSet[Token]) => r.rate(r.preconditions)
        Rule(pre = r.preconditions, rateExp = rateF, eff = r.effects, msg = Option(r.msg))

    extension (s: CDAPState) def toState: State = State(tokens = s.tokens, msg = Option(s.msg))

    extension (s: State)

      def toDAPState(using Zone): Ptr[CDAPState] =
        CDAPState(tokens = s.tokens.toCMSetToken, msg = CToken(s.msg.map(_.value).orNull))
  end NativeADTs
end NativeProductApi
