package it.unibo.dap.api

import java.util.concurrent.ForkJoinPool

import scala.scalanative.unsafe.*
import scala.scalanative.libc.stdlib
import scala.scalanative.unsafe.Size.intToSize
import scala.concurrent.ExecutionContext
import scala.scalanative.libc
import scala.scalanative.unsigned.UByte
import scala.language.postfixOps

import it.unibo.dap.utils.CUtils.freshPointer
import it.unibo.dap.utils.{ as, Iso }
import it.unibo.dap.controller.Serializable

import libdap.aliases.{ uint8_t, Token as CToken }
import libdap.structs.{ DAPState as CDAPState, MSet_Token as CMSetToken, Neighbour as CNeighbour, Rule as CRule, * }

/** Bindings from / to Scala Native <==> Product API types.
  * Scala Native types are generated by Bindgen from the C header file and are available in
  * `libdap` package under `src/managed` target directory.
  */
object NativeProductApi extends ProductApi:

  override val interface: NativeInterface.type = NativeInterface

  object NativeInterface extends ProductInterface with NativeADTs:
    override given ExecutionContext = ExecutionContext.fromExecutor(ForkJoinPool())

  trait NativeADTs extends ADTs:
    type Token = CToken

    override type IOption[T] = T | Null

    override given [T] => Iso[IOption[T], Option[T]] =
      Iso(t => Option.when(t != null)(t.asInstanceOf[T]), t => t.orNull)

    override type ISeq[T] = Ptr[T]
    override given [T] => Iso[ISeq[T], Seq[T]] = ???

    override type IFunction1[T1, R] = CFuncPtr1[T1, R]
    override given [T1, R] => Conversion[IFunction1[T1, R], T1 => R] = cf => t => cf(t)

    override type IFunction2[T1, T2, R] = CFuncPtr2[T1, T2, R]
    override given [T1, T2, R] => Conversion[IFunction2[T1, T2, R], (T1, T2) => R] = cf => (t1, t2) => cf(t1, t2)

    given Serializable[Token] with

      override def serialize(token: Token): Array[CSignedChar] =
        val data = !token.value
        val arr = new Array[Byte](data.size.toInt)
        for i <- 0 until data.size.toInt do arr(i) = data.data(i).toByte
        arr

      override def deserialize(bytes: Array[CSignedChar]): Token =
        val size = bytes.length
        val deserializedData = stdlib.malloc(sizeOf[RawData]).asInstanceOf[Ptr[RawData]]
        (!deserializedData).size = size.toCSize
        (!deserializedData).data = freshPointer[uint8_t](size)
        for i <- 0 until size do (!deserializedData).data(i) = UByte.valueOf(bytes(i))
        CToken(deserializedData)

    given cmsetCvt: Conversion[Ptr[CMSetToken], MSet[Token]] = m =>
      MSet((0 until (!m).size.toInt).map(i => (!m).elements(i)).toList*)

    extension (m: MSet[Token])

      def toCMSetToken(using Zone): Ptr[CMSetToken] =
        val cmset = CMSetToken()
        (!cmset).size = m.elems.size.toCSize
        val elems = freshPointer[CToken](m.elems.size)
        (!cmset).elements = elems
        m.elems.zipWithIndex.foreach: (t, i) =>
          elems(i) = CToken(t.value)
        cmset

    given Conversion[CNeighbour, Neighbor] = n => fromCString(n.name)

    given Conversion[CRule, Rule[Token]] = r => Rule(r.preconditions, r.rate, r.effects, r.msg)

    given Conversion[CDAPState, State[Token]] = s => State(tokens = s.tokens, msg = s.msg)

    extension (s: State[Token])

      def toDAPState(using Zone): Ptr[CDAPState] =
        CDAPState(tokens = s.tokens.toCMSetToken, msg = CToken(s.msg.as.map(_.value).orNull))
  end NativeADTs
end NativeProductApi
